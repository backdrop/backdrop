<?php
/**
 * @file
 * Enables users to comment on published content.
 *
 * When enabled, the Comment module creates a discussion board for each Backdrop
 * node. Users can post comments to discuss a blog post, article, etc.
 */

/**
 * Comment is awaiting approval.
 */
define('COMMENT_NOT_PUBLISHED', 0);

/**
 * Comment is published.
 */
define('COMMENT_PUBLISHED', 1);

/**
 * Comments are displayed in a flat list - expanded.
 */
define('COMMENT_MODE_FLAT', 0);

/**
 * Comments are displayed as a threaded list - expanded.
 */
define('COMMENT_MODE_THREADED', 1);

/**
 * Anonymous posters cannot enter their contact information.
 */
define('COMMENT_ANONYMOUS_MAYNOT_CONTACT', 0);

/**
 * Anonymous posters may leave their contact information.
 */
define('COMMENT_ANONYMOUS_MAY_CONTACT', 1);

/**
 * Anonymous posters are required to leave their contact information.
 */
define('COMMENT_ANONYMOUS_MUST_CONTACT', 2);

/**
 * Comment form should be displayed on a separate page.
 */
define('COMMENT_FORM_SEPARATE_PAGE', 0);

/**
 * Comment form should be shown below post or list of comments.
 */
define('COMMENT_FORM_BELOW', 1);

/**
 * Comments for this node are hidden.
 */
define('COMMENT_NODE_HIDDEN', 0);

/**
 * Comments for this node are closed.
 */
define('COMMENT_NODE_CLOSED', 1);

/**
 * Comments for this node are open.
 */
define('COMMENT_NODE_OPEN', 2);

/**
 * Implements hook_entity_info().
 */
function comment_entity_info() {
  $entity_info = array(
    'comment' => array(
      'label' => t('Comment'),
      'bundle label' => t('Node type'),
      'base table' => 'comment',
      'fieldable' => TRUE,
      'controller class' => 'CommentStorageController',
      'entity class' => 'Comment',
      'entity keys' => array(
        'id' => 'cid',
        'bundle' => 'node_type',
      ),
      'bundles' => array(),
      'view modes' => array(
        'full' => array(
          'label' => t('Full comment'),
          'custom settings' => FALSE,
        ),
        'token' => array(
          'label' => t('Tokens'),
          'custom settings' => FALSE,
        ),
      ),
      'static cache' => FALSE,
    ),
  );

  // If the cache table has been created, then enable entity caching.
  if (db_table_exists('cache_entity_comment')) {
    $entity_info['comment']['entity cache'] = TRUE;
    $entity_info['comment']['field cache'] = FALSE;
  }

  foreach (node_type_get_names() as $type => $name) {
    $entity_info['comment']['bundles']['comment_node_' . $type] = array(
      'label' => t('@node_type comment', array('@node_type' => $name)),
      // Provide the node type/bundle name for other modules, so it does not
      // have to be extracted manually from the bundle name.
      'node bundle' => $type,
      'admin' => array(
        // Place the Field UI paths for comments one level below the
        // corresponding paths for nodes, so that they appear in the same set
        // of local tasks. Note that the paths use a different placeholder name
        // and thus a different menu loader callback, so that Field UI page
        // callbacks get a comment bundle name from the node type in the URL.
        // See comment_menu_node_type_load() and comment_menu_alter().
        'path' => 'admin/structure/types/manage/%comment_menu_node_type/comment',
        'bundle argument' => 4,
        'real path' => 'admin/structure/types/manage/' . str_replace('_', '-', $type) . '/comment',
        'access arguments' => array('administer content types'),
      ),
    );
  }

  return $entity_info;
}

/**
 * Implements hook_field_extra_fields().
 */
function comment_field_extra_fields() {
  $return = array();

  foreach (node_type_get_types() as $type) {
    if ($type->settings['comment_subject_field']) {
      $return['comment']['comment_node_' . $type->type] = array(
        'form' => array(
          'author' => array(
            'label' => t('Author'),
            'description' => t('Author textfield'),
            'weight' => -2,
          ),
          'subject' => array(
            'label' => t('Title'),
            'description' => t('Title textfield'),
            'weight' => -1,
          ),
        ),
      );
    }
  }

  return $return;
}

/**
 * Implements hook_theme().
 */
function comment_theme() {
  $base = array(
    'file' => 'comment.theme.inc',
  );

  return array(
    'comment_block' => array(
      'variables' => array('comments' => array()),
    ) + $base,
    'comment_preview' => array(
      'variables' => array('comment' => NULL),
    ) + $base,
    'comment' => array(
      'template' => 'templates/comment',
      'render element' => 'elements',
    ) + $base,
    'comment_post_forbidden' => array(
      'variables' => array('node' => NULL),
    ) + $base,
  );
}

/**
 * Implements hook_menu().
 */
function comment_menu() {
  $items['admin/content/comment'] = array(
    'title' => 'Manage comments',
    'description' => 'List and edit site comments and the comment approval queue.',
    'page callback' => 'comment_admin',
    'access arguments' => array('administer comments'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'comment.admin.inc',
  );
  // Tabs begin here.
  $items['admin/content/comment/new'] = array(
    'title' => 'Published comments',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/content/comment/approval'] = array(
    'title' => 'Unapproved comments',
    'title callback' => 'comment_count_unpublished',
    'page arguments' => array('approval'),
    'access arguments' => array('administer comments'),
    'type' => MENU_LOCAL_TASK,
  );
  $items['comment/%'] = array(
    'title' => 'Comment permalink',
    'page callback' => 'comment_permalink',
    'page arguments' => array(1),
    'access arguments' => array('access comments'),
  );
  $items['comment/%/view'] = array(
    'title' => 'View comment',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  // Every other comment path uses %, but this one loads the comment directly,
  // so we don't end up loading it twice (in the page and access callback).
  $items['comment/%comment/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'comment_edit_page',
    'page arguments' => array(1),
    'access callback' => 'comment_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 0,
  );
  $items['comment/%/approve'] = array(
    'title' => 'Approve',
    'page callback' => 'comment_approve',
    'page arguments' => array(1),
    'access arguments' => array('administer comments'),
    'file' => 'comment.pages.inc',
    'weight' => 1,
  );
  $items['comment/%/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'comment_confirm_delete_page',
    'page arguments' => array(1),
    'access arguments' => array('administer comments'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'comment.admin.inc',
    'weight' => 2,
  );
  $items['comment/reply/%node'] = array(
    'title' => 'Add comment',
    'page callback' => 'comment_reply',
    'page arguments' => array(2),
    'access callback' => 'node_access',
    'access arguments' => array('view', 2),
    'file' => 'comment.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function comment_menu_alter(&$items) {
  // Add comments to the description for admin/content.
  $items['admin/content']['description'] = 'Administer content and comments.';

  // Adjust the Field UI tabs on admin/structure/types/manage/[node-type].
  // See comment_entity_info().
  $items['admin/structure/types/manage/%comment_menu_node_type/comment/fields']['title'] = 'Comment fields';
  $items['admin/structure/types/manage/%comment_menu_node_type/comment/fields']['weight'] = 3;
  $items['admin/structure/types/manage/%comment_menu_node_type/comment/display']['title'] = 'Comment display';
  $items['admin/structure/types/manage/%comment_menu_node_type/comment/display']['weight'] = 4;
}

/**
 * Loads the comment bundle name corresponding a given content type.
 *
 * This function is used as a menu loader callback in comment_menu().
 *
 * @param $name
 *   The URL-formatted machine name of the node type whose comment fields are
 *   to be edited. 'URL-formatted' means that underscores are replaced by
 *   hyphens.
 *
 * @return
 *   The comment bundle name corresponding to the node type.
 *
 * @see comment_menu_alter()
 */
function comment_menu_node_type_load($name) {
  if ($type = node_type_get_type(strtr($name, array('-' => '_')))) {
    return 'comment_node_' . $type->type;
  }
}

/**
 * Returns a menu title which includes the number of unapproved comments.
 */
function comment_count_unpublished() {
  $count = db_query('SELECT COUNT(cid) FROM {comment} WHERE status = :status', array(
    ':status' => COMMENT_NOT_PUBLISHED,
  ))->fetchField();
  return t('Unapproved comments (@count)', array('@count' => $count));
}

/**
 * Implements hook_node_type_load().
 */
function comment_node_type_load(&$types) {
  foreach ($types as $type_name => $type) {
    $types[$type_name]->settings += array(
      'comment_enabled' => FALSE,
      'comment_default' => COMMENT_NODE_CLOSED,
      'comment_per_page' => 50,
      'comment_mode' => COMMENT_MODE_THREADED,
      'comment_anonymous' => COMMENT_ANONYMOUS_MAYNOT_CONTACT,
      'comment_subject_field' => FALSE,
      'comment_user_picture' => TRUE,
      'comment_form_location' => COMMENT_FORM_BELOW,
      'comment_preview' => BACKDROP_OPTIONAL,
      'comment_close_enabled' => FALSE,
      'comment_close_days' => 14
    );
  }
}

/**
 * Implements hook_node_type_insert().
 *
 * Creates a comment body field for a node type created while the Comment module
 * is enabled. For node types created before the Comment module is enabled,
 * hook_modules_enabled() serves to create the body fields.
 *
 * @see comment_modules_enabled()
 */
function comment_node_type_insert($info) {
  _comment_body_field_create($info);
}

/**
 * Implements hook_node_type_update().
 */
function comment_node_type_update($info) {
  if (!empty($info->old_type) && $info->type != $info->old_type) {
    field_attach_rename_bundle('comment', 'comment_node_' . $info->old_type, 'comment_node_' . $info->type);
  }
}

/**
 * Implements hook_node_type_delete().
 */
function comment_node_type_delete($info) {
  field_attach_delete_bundle('comment', 'comment_node_' . $info->type);
}

 /**
 * Creates a comment_body field instance for a given node type.
 *
 * @param $info
 *   An object representing the content type. The only property that is
 *   currently used is $info->type, which is the machine name of the content
 *   type for which the body field (instance) is to be created.
 */
function _comment_body_field_create($info) {
  // Create the field if needed.
  if (!field_read_field('comment_body', array('include_inactive' => TRUE))) {
    $field = array(
      'field_name' => 'comment_body',
      'type' => 'text_long',
      'entity_types' => array('comment'),
    );
    field_create_field($field);
  }
  // Create the instance if needed.
  if (!field_read_instance('comment', 'comment_body', 'comment_node_' . $info->type, array('include_inactive' => TRUE))) {
    field_attach_create_bundle('comment', 'comment_node_' . $info->type);
    // Attaches the body field by default.
    $instance = array(
      'field_name' => 'comment_body',
      'label' => 'Comment',
      'entity_type' => 'comment',
      'bundle' => 'comment_node_' . $info->type,
      'settings' => array('text_processing' => 1),
      'required' => TRUE,
      'display' => array(
        'default' => array(
          'label' => 'hidden',
          'type' => 'text_default',
          'weight' => 0,
        ),
      ),
    );
    field_create_instance($instance);
  }
}

/**
 * Implements hook_permission().
 */
function comment_permission() {
  return array(
    'administer comments' => array(
      'title' => t('Administer comments and comment settings'),
    ),
    'access comments' => array(
      'title' => t('View comments'),
    ),
    'post comments' => array(
      'title' => t('Post comments'),
    ),
    'skip comment approval' => array(
      'title' => t('Skip comment approval'),
    ),
    'edit own comments' => array(
      'title' => t('Edit own comments'),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function comment_views_api() {
  return array(
    'api' => '3.0',
    'path' => backdrop_get_path('module', 'comment') . '/views',
  );
}

/**
 * Implements hook_block_info().
 */
function comment_block_info() {
  $blocks['recent'] = array(
    'info' => t('Recent comments'),
    'description' => t('A list of recent comments posted to the site.'),
  );

  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function comment_block_configure($delta = '', $settings = array()) {
  $settings += array(
    'comment_count' => 10,
  );
  $form['comment_count'] = array(
    '#type' => 'select',
    '#title' => t('Number of recent comments'),
    '#default_value' => $settings['comment_count'],
    '#options' => backdrop_map_assoc(array(2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 25, 30)),
  );

  return $form;
}

/**
 * Implements hook_block_view().
 *
 * Generates a block with the most recent comments.
 */
function comment_block_view($delta = '', $settings = array()) {
  if (user_access('access comments') && $delta === 'recent') {
    $settings += array(
      'comment_count' => 10,
    );
    $comments = comment_get_recent($settings['comment_count']);
    $block['subject'] = t('Recent comments');
    $block['content'] = theme('comment_block', array('comments' => $comments));

    return $block;
  }
}

/**
 * Redirects comment links to the correct page depending on comment settings.
 *
 * Since comments are paged there is no way to guarantee which page a comment
 * appears on. Comment paging and threading settings may be changed at any time.
 * With threaded comments, an individual comment may move between pages as
 * comments can be added either before or after it in the overall discussion.
 * Therefore we use a central routing function for comment links, which
 * calculates the page number based on current comment settings and returns
 * the full comment view with the pager set dynamically.
 *
 * @param $cid
 *   A comment identifier.
 *
 * @return
 *   The comment listing set to the page on which the comment appears.
 */
function comment_permalink($cid) {
  if (($comment = comment_load($cid)) && ($node = node_load($comment->nid))) {

    // Find the current display page for this comment.
    $page = comment_get_display_page($comment->cid, $node->type);

    // Set $_GET['q'] and $_GET['page'] ourselves so that the node callback
    // behaves as it would when visiting the page directly.
    $_GET['q'] = 'node/' . $node->nid;
    $_GET['page'] = $page;

    // Return the node view, this will show the correct comment in context.
    return menu_execute_active_handler('node/' . $node->nid, FALSE, 'menu_default_route_handler');
  }
  return MENU_NOT_FOUND;
}

/**
 * Finds the most recent comments that are available to the current user.
 *
 * @param integer $number
 *   (optional) The maximum number of comments to find. Defaults to 10.
 *
 * @return
 *   An array of comment objects or an empty array if there are no recent
 *   comments visible to the current user.
 */
function comment_get_recent($number = 10) {
  $query = db_select('comment', 'c');
  $query->innerJoin('node', 'n', 'n.nid = c.nid');
  $query->addTag('node_access');
  $comments = $query
    ->fields('c')
    ->condition('c.status', COMMENT_PUBLISHED)
    ->condition('n.status', NODE_PUBLISHED)
    ->orderBy('c.created', 'DESC')
    // Additionally order by cid to ensure that comments with the same timestamp
    // are returned in the exact order posted.
    ->orderBy('c.cid', 'DESC')
    ->range(0, $number)
    ->execute()
    ->fetchAll();

  return $comments ? $comments : array();
}

/**
 * Calculates the page number for the first new comment.
 *
 * @param $num_comments
 *   Number of comments.
 * @param $new_replies
 *   Number of new replies.
 * @param Node $node
 *   The first new comment node.
 *
 * @return
 *   "page=X" if the page number is greater than zero; empty string otherwise.
 */
function comment_new_page_count($num_comments, $new_replies, Node $node) {
  $node_type = node_type_get_type($node->type);
  $mode = $node_type->settings['comment_mode'];
  $comments_per_page = $node_type->settings['comment_per_page'];
  $pagenum = NULL;
  $flat = $mode == COMMENT_MODE_FLAT ? TRUE : FALSE;
  if ($num_comments <= $comments_per_page) {
    // Only one page of comments.
    $pageno = 0;
  }
  elseif ($flat) {
    // Flat comments.
    $count = $num_comments - $new_replies;
    $pageno = $count / $comments_per_page;
  }
  else {
    // Threaded comments: we build a query with a subquery to find the first
    // thread with a new comment.

    // 1. Find all the threads with a new comment.
    $unread_threads_query = db_select('comment')
      ->fields('comment', array('thread'))
      ->condition('nid', $node->nid)
      ->condition('status', COMMENT_PUBLISHED)
      ->orderBy('created', 'DESC')
      ->orderBy('cid', 'DESC')
      ->range(0, $new_replies);

    // 2. Find the first thread.
    $first_thread = db_select($unread_threads_query, 'thread')
      ->fields('thread', array('thread'))
      ->orderBy('SUBSTRING(thread, 1, (LENGTH(thread) - 1))')
      ->range(0, 1)
      ->execute()
      ->fetchField();

    // Remove the final '/'.
    $first_thread = substr($first_thread, 0, -1);

    // Find the number of the first comment of the first unread thread.
    $count = db_query('SELECT COUNT(*) FROM {comment} WHERE nid = :nid AND status = :status AND SUBSTRING(thread, 1, (LENGTH(thread) - 1)) < :thread', array(
      ':status' => COMMENT_PUBLISHED,
      ':nid' => $node->nid,
      ':thread' => $first_thread,
    ))->fetchField();

    $pageno = $count / $comments_per_page;
  }

  if ($pageno >= 1) {
    $pagenum = array('page' => intval($pageno));
  }

  return $pagenum;
}

/**
 * Implements hook_node_view().
 */
function comment_node_view(Node $node, $view_mode) {
  $links = array();

  if ($node->comment != COMMENT_NODE_HIDDEN) {
    $node_type = node_type_get_type($node->type);
    if ($view_mode == 'rss') {
      // Add a comments RSS element which is a URL to the comments of this node.
      $node->rss_elements[] = array(
        'key' => 'comments',
        'value' => url('node/' . $node->nid, array('fragment' => 'comments', 'absolute' => TRUE))
      );
    }
    elseif ($view_mode == 'teaser') {
      // Teaser view: display the number of comments that have been posted,
      // or a link to add new comments if the user has permission, the node
      // is open to new comments, and there currently are none.
      if (user_access('access comments')) {
        if (!empty($node->comment_count)) {
          $links['comment-comments'] = array(
            'title' => format_plural($node->comment_count, '1 comment', '@count comments'),
            'href' => "node/$node->nid",
            'attributes' => array('title' => t('Jump to the first comment of this posting.')),
            'fragment' => 'comments',
            'html' => TRUE,
          );
          // Show a link to the first new comment.
          if ($new = comment_num_new($node->nid)) {
            $links['comment-new-comments'] = array(
              'title' => format_plural($new, '1 new comment', '@count new comments'),
              'href' => "node/$node->nid",
              'query' => comment_new_page_count($node->comment_count, $new, $node),
              'attributes' => array('title' => t('Jump to the first new comment of this posting.')),
              'fragment' => 'new',
              'html' => TRUE,
            );
          }
        }
      }
      if ($node->comment == COMMENT_NODE_OPEN) {
        $comment_form_location = $node_type->settings['comment_form_location'];
        if (Comment::createAccess()) {
          $links['comment-add'] = array(
            'title' => t('Add comment'),
            'href' => "node/$node->nid",
            'attributes' => array('title' => t('Add a new comment to this page.')),
            'fragment' => 'comment-form',
          );
          if ($comment_form_location == COMMENT_FORM_SEPARATE_PAGE) {
            $links['comment-add']['href'] = "comment/reply/$node->nid";
          }
        }
        else {
          $links['comment-forbidden'] = array(
            'title' => theme('comment_post_forbidden', array('node' => $node)),
            'html' => TRUE,
          );
        }
      }
    }
    elseif ($view_mode != 'search_index' && $view_mode != 'search_result') {
      // Node in other display modes: add a "post comment" link if the user is
      // allowed to post comments and if this node is allowing new comments.
      // But we don't want this link if we're building the node for search
      // indexing or constructing a search result excerpt.
      if ($node->comment == COMMENT_NODE_OPEN) {
        $comment_form_location = $node_type->settings['comment_form_location'];
        if (Comment::createAccess()) {
          // Show the "post comment" link if the form is on another page, or
          // if there are existing comments that the link will skip past.
          if ($comment_form_location == COMMENT_FORM_SEPARATE_PAGE || (!empty($node->comment_count) && user_access('access comments'))) {
            $links['comment-add'] = array(
              'title' => t('Add comment'),
              'attributes' => array('title' => t('Share your thoughts and opinions related to this posting.')),
              'href' => "node/$node->nid",
              'fragment' => 'comment-form',
            );
            if ($comment_form_location == COMMENT_FORM_SEPARATE_PAGE) {
              $links['comment-add']['href'] = "comment/reply/$node->nid";
            }
          }
        }
        else {
          $links['comment-forbidden'] = array(
            'title' => theme('comment_post_forbidden', array('node' => $node)),
            'html' => TRUE,
          );
        }
      }
    }

    $node->content['links']['comment'] = array(
      '#theme' => 'links__node__comment',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}

/**
 * Builds the comment-related elements for node detail pages.
 *
 * @param Node $node
 *   The node entity for which to build the comment-related elements.
 *
 * @return
 *   A renderable array representing the comment-related page elements for the
 *   node.
 */
function comment_node_page_additions(Node $node) {
  $node_type = node_type_get_type($node->type);

  $additions = array(
    'comments' => array(),
    'comment_form' => array(),
  );

  // Only attempt to render comments if the node has visible comments.
  // Unpublished comments are not included in $node->comment_count, so show
  // comments unconditionally if the user is an administrator.
  if ((!empty($node->comment_count) && user_access('access comments')) || user_access('administer comments')) {
    $mode = $node_type->settings['comment_mode'];
    $comments_per_page = $node_type->settings['comment_per_page'];
    if ($cids = comment_get_thread($node, $mode, $comments_per_page)) {
      $comments = comment_load_multiple($cids);
      comment_prepare_thread($comments);
      $build = comment_view_multiple($comments, $node);
      $build['pager']['#theme'] = 'pager';
      $additions['comments'] = $build;
    }
  }

  // Append comment form if needed.
  if (Comment::createAccess() && $node->comment == COMMENT_NODE_OPEN && ($node_type->settings['comment_form_location'] == COMMENT_FORM_BELOW)) {
    $comment = entity_create('comment', array('nid' => $node->nid));
    $additions['comment_form'] = backdrop_get_form("comment_node_{$node->type}_form", $comment);
  }

  return $additions;
}

/**
 * Retrieves comments for a thread.
 *
 * @param Node $node
 *   The node whose comment(s) needs rendering.
 * @param $mode
 *   The comment display mode; COMMENT_MODE_FLAT or COMMENT_MODE_THREADED.
 * @param $comments_per_page
 *   The amount of comments to display per page.
 *
 * @return
 *   An array of the IDs of the comment to be displayed.
 *
 * To display threaded comments in the correct order we keep a 'thread' field
 * and order by that value. This field keeps this data in
 * a way which is easy to update and convenient to use.
 *
 * A "thread" value starts at "1". If we add a child (A) to this comment,
 * we assign it a "thread" = "1.1". A child of (A) will have "1.1.1". Next
 * brother of (A) will get "1.2". Next brother of the parent of (A) will get
 * "2" and so on.
 *
 * First of all note that the thread field stores the depth of the comment:
 * depth 0 will be "X", depth 1 "X.X", depth 2 "X.X.X", etc.
 *
 * Now to get the ordering right, consider this example:
 *
 * 1
 * 1.1
 * 1.1.1
 * 1.2
 * 2
 *
 * If we "ORDER BY thread ASC" we get the above result, and this is the
 * natural order sorted by time. However, if we "ORDER BY thread DESC"
 * we get:
 *
 * 2
 * 1.2
 * 1.1.1
 * 1.1
 * 1
 *
 * Clearly, this is not a natural way to see a thread, and users will get
 * confused. The natural order to show a thread by time desc would be:
 *
 * 2
 * 1
 * 1.2
 * 1.1
 * 1.1.1
 *
 * which is what we already did before the standard pager patch. To achieve
 * this we add a "/" at the end of each "thread" value. This way, the thread
 * fields will look like this:
 *
 * 1/
 * 1.1/
 * 1.1.1/
 * 1.2/
 * 2/
 *
 * we add "/" since this char is, in ASCII, higher than every number, so if
 * now we "ORDER BY thread DESC" we get the correct order. However this would
 * spoil the reverse ordering, "ORDER BY thread ASC" -- here, we do not need
 * to consider the trailing "/" so we use a substring only.
 */
function comment_get_thread(Node $node, $mode, $comments_per_page) {
  $query = db_select('comment', 'c')->extend('PagerDefault');
  $query->addField('c', 'cid');
  $query
    ->condition('c.nid', $node->nid)
    ->addTag('node_access')
    ->addTag('comment_filter')
    ->addMetaData('node', $node)
    ->limit($comments_per_page);

  $count_query = db_select('comment', 'c');
  $count_query->addExpression('COUNT(*)');
  $count_query
    ->condition('c.nid', $node->nid)
    ->addTag('node_access')
    ->addTag('comment_filter')
    ->addMetaData('node', $node);

  if (!user_access('administer comments')) {
    $query->condition('c.status', COMMENT_PUBLISHED);
    $count_query->condition('c.status', COMMENT_PUBLISHED);
  }
  if ($mode === COMMENT_MODE_FLAT) {
    $query->orderBy('c.cid', 'ASC');
  }
  else {
    // See comment above. Analysis reveals that this doesn't cost too
    // much. It scales much much better than having the whole comment
    // structure.
    $query->addExpression('SUBSTRING(c.thread, 1, (LENGTH(c.thread) - 1))', 'torder');
    $query->orderBy('torder', 'ASC');
  }

  $query->setCountQuery($count_query);
  $cids = $query->execute()->fetchCol();

  return $cids;
}

/**
 * Calculates the indentation level of each comment in a comment thread.
 *
 * This function loops over an array representing a comment thread. For each
 * comment, the function calculates the indentation level and saves it in the
 * 'divs' property of the comment object.
 *
 * @param array $comments
 *   An array of comment objects, keyed by comment ID.
 */
function comment_prepare_thread(&$comments) {
  // A flag stating if we are still searching for first new comment on the thread.
  $first_new = TRUE;

  // A counter that helps track how indented we are.
  $divs = 0;

  foreach ($comments as $key => $comment) {
    if ($first_new && $comment->new != MARK_READ) {
      // Assign the anchor only for the first new comment. This avoids duplicate
      // id attributes on a page.
      $first_new = FALSE;
      $comment->first_new = TRUE;
    }

    // The $divs element instructs #prefix whether to add an indent div or
    // close existing divs (a negative value).
    $comment->depth = count(explode('.', $comment->thread)) - 1;
    if ($comment->depth > $divs) {
      $comment->divs = 1;
      $divs++;
    }
    else {
      $comment->divs = $comment->depth - $divs;
      while ($comment->depth < $divs) {
        $divs--;
      }
    }
    $comments[$key] = $comment;
  }

  // The final comment must close up some hanging divs
  $comments[$key]->divs_final = $divs;
}

/**
 * Generates an array for rendering a comment.
 *
 * @param Comment $comment
 *   The comment object.
 * @param Node $node
 *   The node the comment is attached to.
 * @param $view_mode
 *   (optional) Display mode, e.g. 'full' or 'teaser'. Defaults to 'full'.
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return
 *   An array as expected by backdrop_render().
 */
function comment_view(Comment $comment, Node $node, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->langcode;
  }

  // Populate $comment->content with a render() array.
  comment_build_content($comment, $node, $view_mode, $langcode);

  $build = $comment->content;
  // We don't need duplicate rendering info in comment->content.
  unset($comment->content);

  $build += array(
    '#theme' => 'comment__node_' . $node->type . '__' . $view_mode,
    '#comment' => $comment,
    '#node' => $node,
    '#view_mode' => $view_mode,
    '#language' => $langcode,
  );
  $node_type = node_type_get_type($node->type);

  if (empty($comment->in_preview)) {
    $prefix = '';
    $is_threaded = isset($comment->divs) && $node_type->settings['comment_mode'] == COMMENT_MODE_THREADED;

    // Add 'new' anchor if needed.
    if (!empty($comment->first_new)) {
      $prefix .= "<a id=\"new\"></a>\n";
    }

    // Add indentation div or close open divs as needed.
    if ($is_threaded) {
      $prefix .= $comment->divs <= 0 ? str_repeat('</div>', abs($comment->divs)) : "\n" . '<div class="indented">';
    }

    // Add anchor for each comment.
    $prefix .= "<a id=\"comment-$comment->cid\"></a>\n";
    $build['#prefix'] = $prefix;

    // Close all open divs.
    if ($is_threaded && !empty($comment->divs_final)) {
      $build['#suffix'] = str_repeat('</div>', $comment->divs_final);
    }
  }

  // Allow modules to modify the structured comment.
  $type = 'comment';
  backdrop_alter(array('comment_view', 'entity_view'), $build, $type);

  return $build;
}

/**
 * Builds a structured array representing the comment's content.
 *
 * The content built for the comment (field values, comments, file attachments
 * or other comment components) will vary depending on the $view_mode parameter.
 *
 * @param Comment $comment
 *   A comment object.
 * @param Node $node
 *   The node the comment is attached to.
 * @param $view_mode
 *   (optional) Display mode, e.g. 'full' or 'teaser'. Defaults to 'full'.
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 */
function comment_build_content(Comment $comment, Node $node, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->langcode;
  }

  // Remove previously built content, if exists.
  $comment->content = array();

  // Allow modules to change the display mode.
  $view_mode = key(entity_view_mode_prepare('comment', array($comment->cid => $comment), $view_mode, $langcode));

  // Build fields content.
  field_attach_prepare_view('comment', array($comment->cid => $comment), $view_mode, $langcode);
  entity_prepare_view('comment', array($comment->cid => $comment), $langcode);
  $comment->content += field_attach_view('comment', $comment, $view_mode, $langcode);

  $comment->content['links'] = array(
    '#theme' => 'links__comment',
    '#pre_render' => array('backdrop_pre_render_links'),
    '#attributes' => array('class' => array('links', 'inline')),
  );
  if (empty($comment->in_preview)) {
    $comment->content['links']['comment'] = array(
      '#theme' => 'links__comment__comment',
      '#links' => comment_links($comment, $node),
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }

  // Allow modules to make their own additions to the comment.
  module_invoke_all('comment_view', $comment, $view_mode, $langcode);
  module_invoke_all('entity_view', $comment, 'comment', $view_mode, $langcode);

  // Make sure the current display mode is stored if no module has already
  // populated the related key.
  $comment->content += array('#view_mode' => $view_mode);
}

/**
 * Adds reply, edit, delete, etc. links, depending on user permissions.
 *
 * @param Comment $comment
 *   The comment object.
 * @param Node $node
 *   The node the comment is attached to.
 *
 * @return
 *   A structured array of links.
 */
function comment_links(Comment $comment, Node $node) {
  $links = array();
  if ($node->comment == COMMENT_NODE_OPEN) {
    if ($comment->access('delete')) {
      $links['comment-delete'] = array(
        'title' => t('delete'),
        'href'  => "comment/$comment->cid/delete",
        'html'  => TRUE,
      );
    }
    if ($comment->access('update')) {
      $links['comment-edit'] = array(
        'title' => t('edit'),
        'href'  => "comment/$comment->cid/edit",
        'html'  => TRUE,
      );
    }
    if (Comment::createAccess()) {
      $links['comment-reply'] = array(
        'title' => t('reply'),
        'href'  => "comment/reply/$comment->nid/$comment->cid",
        'html'  => TRUE,
      );
    }
    if ($comment->status == COMMENT_NOT_PUBLISHED && $comment->access('approve')) {
      $links['comment-approve'] = array(
        'title' => t('approve'),
        'href' => "comment/$comment->cid/approve",
        'html' => TRUE,
        'query' => array('token' => backdrop_get_token("comment/$comment->cid/approve")),
      );
    }
    if (empty($links)) {
      $links['comment-forbidden']['title'] = theme('comment_post_forbidden', array('node' => $node));
      $links['comment-forbidden']['html'] = TRUE;
    }
  }
  return $links;
}

/**
 * Constructs render array from an array of loaded comments.
 *
 * @param $comments
 *   An array of comments as returned by comment_load_multiple().
 * @param Node $node
 *   The node the comments are attached to.
 * @param $view_mode
 *   (optional) Display mode, e.g. 'full' or 'teaser'. Defaults to 'full'.
 * @param $weight
 *   An integer representing the weight of the first comment in the list.
 * @param $langcode
 *   A string indicating the language field values are to be shown in. If no
 *   language is provided the current content language is used.
 *
 * @return
 *   An array in the format expected by backdrop_render().
 *
 * @see backdrop_render()
 */
function comment_view_multiple($comments, Node $node, $view_mode = 'full', $weight = 0, $langcode = NULL) {
  $build = array();
  $entities_by_view_mode = entity_view_mode_prepare('comment', $comments, $view_mode, $langcode);
  foreach ($entities_by_view_mode as $entity_view_mode => $entities) {
    field_attach_prepare_view('comment', $entities, $entity_view_mode, $langcode);
    entity_prepare_view('comment', $entities, $langcode);

    foreach ($entities as $entity) {
      $build[$entity->cid] = comment_view($entity, $node, $entity_view_mode, $langcode);
    }
  }
  foreach ($comments as $comment) {
    $build[$comment->cid]['#weight'] = $weight;
    $weight++;
  }
  // Sort here, to preserve the input order of the entities that were passed to
  // this function.
  backdrop_sort($build, array('#weight'));
  $build['#sorted'] = TRUE;

  return $build;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function comment_form_node_type_form_alter(&$form, $form_state) {
  $node_type = $form['#node_type'];

  if (isset($form['type'])) {
    $form['comment'] = array(
      '#type' => 'fieldset',
      '#title' => t('Comment settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
      '#attributes' => array(
        'class' => array('comment-node-type-settings-form'),
      ),
      '#attached' => array(
        'js' => array(backdrop_get_path('module', 'comment') . '/js/comment.admin.js'),
      ),
      '#weight' => 25,
    );
    // Unlike coment_form_node_form_alter(), all of these settings are applied
    // as defaults to all new nodes. Therefore, it would be wrong to use #states
    // to hide the other settings based on the primary comment setting.
    $form['comment']['comment_default'] = array(
      '#type' => 'radios',
      '#title' => t('Default comment setting for new content'),
      '#default_value' => $node_type->settings['comment_default'],
      '#options' => array(
        COMMENT_NODE_OPEN => t('Open comments'),
        COMMENT_NODE_CLOSED => t('Closed comments'),
      ),
    );
    $form['comment']['comment_per_page'] = array(
      '#type' => 'select',
      '#title' => t('Comments per page'),
      '#default_value' => $node_type->settings['comment_per_page'],
      '#options' => _comment_per_page(),
    );
    $form['comment']['comment_mode'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show comment replies in a threaded list'),
      '#default_value' => $node_type->settings['comment_mode'],
      '#description' => t('A threaded list differs from a chronological list in that each comment follows its parent, and is usually indented.'),
    );
    $form['comment']['comment_anonymous'] = array(
      '#type' => 'select',
      '#title' => t('Anonymous commenting'),
      '#default_value' => $node_type->settings['comment_anonymous'],
      '#options' => array(
        COMMENT_ANONYMOUS_MAYNOT_CONTACT => t('Anonymous posters may not enter their contact information'),
        COMMENT_ANONYMOUS_MAY_CONTACT => t('Anonymous posters may leave their contact information'),
        COMMENT_ANONYMOUS_MUST_CONTACT => t('Anonymous posters must leave their contact information'),
      ),
      '#access' => user_access('post comments', backdrop_anonymous_user()),
    );
    $form['comment']['comment_subject_field'] = array(
      '#type' => 'checkbox',
      '#title' => t('Allow comment title'),
      '#default_value' => $node_type->settings['comment_subject_field'],
    );
    if (config_get('system.core', 'user_pictures')) {
      $form['comment']['comment_user_picture'] = array(
        '#type' => 'checkbox',
        '#title' => t('Display pictures for comment authors'),
        '#default_value' => $node_type->settings['comment_user_picture'],
      );
    }
    $form['comment']['comment_form_location'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show reply form on the same page as comments'),
      '#default_value' => $node_type->settings['comment_form_location'],
    );
    $form['comment']['comment_preview'] = array(
      '#type' => 'radios',
      '#title' => t('Preview comment'),
      '#default_value' => $node_type->settings['comment_preview'],
      '#options' => array(
        BACKDROP_DISABLED => t('Disabled'),
        BACKDROP_OPTIONAL => t('Optional'),
        BACKDROP_REQUIRED => t('Required'),
      ),
    );
    $form['comment']['comment_close_enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Automatically close comments on old content'),
      '#default_value' => $node_type->settings['comment_close_enabled'],
    );
    $form['comment']['comment_close_days'] = array(
      '#type' => 'number',
      '#min' => 1,
      '#step' => 1,
      '#size' => 4,
      '#maxlength' => 4,
      '#states' => array(
        'invisible' => array(
          ':input[name="comment_close_enabled"]' => array('checked' => FALSE),
        ),
      ),
      '#field_prefix' => t('Close comments after'),
      '#default_value' => $node_type->settings['comment_close_days'],
      '#field_suffix' => t('days'),
    );
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function comment_form_node_form_alter(&$form, $form_state) {
  $node = $form['#node'];
  $form['comment_settings'] = array(
    '#type' => 'fieldset',
    '#access' => user_access('administer comments'),
    '#title' => t('Comment settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
    '#attributes' => array(
      'class' => array('comment-node-settings-form'),
    ),
    '#attached' => array(
      'js' => array(backdrop_get_path('module', 'comment') . '/js/comment.admin.js'),
     ),
    '#weight' => 80,
  );
  $comment_count = isset($node->nid) ? db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = :nid', array(':nid' => $node->nid))->fetchField() : 0;
  $comment_settings = ($node->comment == COMMENT_NODE_HIDDEN) ? COMMENT_NODE_CLOSED : $node->comment;
  $form['comment_settings']['comment'] = array(
    '#type' => 'radios',
    '#title' => t('Comments'),
    '#title_display' => 'invisible',
    '#parents' => array('comment'),
    '#default_value' => $comment_settings,
    '#options' => array(
      COMMENT_NODE_OPEN => t('Open'),
      COMMENT_NODE_CLOSED => t('Closed'),
    ),
    COMMENT_NODE_OPEN => array(
      '#description' => t('People with the "Post comments" permission will be able to post comments.'),
    ),
    COMMENT_NODE_CLOSED => array(
      '#description' => t('People will not be able to post comments.'),
    ),
  );
  // If the node has comments, add the "hidden" option too.
  if (!empty($comment_count)) {
    $form['comment_settings']['comment_hidden'] = array(
      '#type' => 'checkbox',
      '#title' => t('Hide existing comments.'),
      '#default_value' => ($node->comment == COMMENT_NODE_HIDDEN) ? TRUE : FALSE,
      '#states' => array(
        'visible' => array(
          ':input[name="comment"]' => array('value' => COMMENT_NODE_CLOSED),
        ),
      ),
    );
  }

  $node_type = node_type_load($node->type);
  $enable = $node_type->settings['comment_close_enabled'];

  if ($enable) {
    $form['comment_settings']['comment_close_enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Automatically close comments @close-days days after the Authored on date', array('@close-days' => $node_type->settings['comment_close_days'])),
      '#description' => t('If unchecked, comments will stay on until manually closed.'),
      // Opposite value is saved. We want to have the *unchecked* box mean the
      // "override" is enabled. So we reverse the value to display.
      '#default_value' => isset($node->comment_close_override) ? !$node->comment_close_override : 1,
      '#states' => array(
        'visible' => array(
          ':input[name="comment"]' => array('value' => COMMENT_NODE_OPEN),
        ),
      ),
    );
  }
}

/**
 * Implements hook_node_presave().
 */
function comment_node_presave(Node $node) {
  if ($node->comment == COMMENT_NODE_CLOSED && property_exists($node, 'comment_hidden') && $node->comment_hidden) {
    $node->comment = COMMENT_NODE_HIDDEN;
    unset($node->comment_hidden);
  }
  // As in comment_form_node_form_alter(), an unchecked value means the comment
  // override should be enabled.
  if (isset($node->comment_close_enabled)) {
    $node->comment_close_override = !$node->comment_close_enabled;
    unset($node->comment_close_enabled);
  }
}

/**
 * Implements hook_node_load().
 */
function comment_node_load($nodes, $types) {
  $comments_enabled = array();

  // Check if comments are enabled for each node. If comments are disabled,
  // assign values without hitting the database.
  foreach ($nodes as $node) {
    // Store whether comments are enabled for this node.
    if ($node->comment != COMMENT_NODE_HIDDEN) {
      $comments_enabled[] = $node->nid;
    }
    else {
      $node->cid = 0;
      $node->last_comment_timestamp = $node->created;
      $node->last_comment_name = '';
      $node->last_comment_uid = $node->uid;
      $node->comment_count = 0;
    }
  }

  // For nodes with comments enabled, fetch information from the database.
  if (!empty($comments_enabled)) {
    $result = db_query('SELECT nid, cid, last_comment_timestamp, last_comment_name, last_comment_uid, comment_count FROM {node_comment_statistics} WHERE nid IN (:comments_enabled)', array(':comments_enabled' => $comments_enabled));
    foreach ($result as $record) {
      $nodes[$record->nid]->cid = $record->cid;
      $nodes[$record->nid]->last_comment_timestamp = $record->last_comment_timestamp;
      $nodes[$record->nid]->last_comment_name = $record->last_comment_name;
      $nodes[$record->nid]->last_comment_uid = $record->last_comment_uid;
      $nodes[$record->nid]->comment_count = $record->comment_count;
    }
  }
}

/**
 * Implements hook_node_prepare().
 */
function comment_node_prepare(Node $node) {
  if (!isset($node->comment)) {
    $node_type = node_type_get_type($node->type);
    $node->comment = $node_type->settings['comment_default'];
  }
}

/**
 * Implements hook_node_insert().
 */
function comment_node_insert(Node $node) {
  // Allow bulk updates and inserts to temporarily disable the
  // maintenance of the {node_comment_statistics} table.
  if (state_get('comment_maintain_node_statistics', TRUE)) {
    db_insert('node_comment_statistics')
      ->fields(array(
        'nid' => $node->nid,
        'cid' => 0,
        'last_comment_timestamp' => $node->changed,
        'last_comment_name' => NULL,
        'last_comment_uid' => $node->uid,
        'comment_count' => 0,
      ))
      ->execute();
  }
}

/**
 * Implements hook_node_predelete().
 */
function comment_node_predelete(Node $node) {
  $cids = db_query('SELECT cid FROM {comment} WHERE nid = :nid', array(':nid' => $node->nid))->fetchCol();
  comment_delete_multiple($cids);
  db_delete('node_comment_statistics')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_node_update_index().
 */
function comment_node_update_index(Node $node) {
  $index_comments = &backdrop_static(__FUNCTION__);

  if ($index_comments === NULL) {
    // Find and save roles that can 'access comments' or 'search content'.
    $perms = array(
      'access comments' => array(),
      'search content' => array(),
    );
    $roles = user_roles(FALSE, NULL, TRUE);
    foreach ($roles as $role_name => $role) {
      if (in_array('access comments', $role->permissions)) {
        $perms['access comments'][$role_name] = $role_name;
      }
      if (in_array('search content', $role->permissions)) {
        $perms['search content'][$role_name] = $role_name;
      }
    }

    // Prevent indexing of comments if there are any roles that can search but
    // not view comments.
    $index_comments = TRUE;
    foreach ($perms['search content'] as $role_name) {
      if (!isset($perms['access comments'][$role_name]) && ($role_name === BACKDROP_ANONYMOUS_ROLE || $role_name === BACKDROP_AUTHENTICATED_ROLE || !isset($perms['access comments'][BACKDROP_AUTHENTICATED_ROLE]))) {
        $index_comments = FALSE;
        break;
      }
    }
  }

  if ($index_comments) {
    $node_type = node_type_get_type($node->type);
    $mode = $node_type->settings['comment_mode'];
    $comments_per_page = $node_type->settings['comment_per_page'];
    if ($node->comment && $cids = comment_get_thread($node, $mode, $comments_per_page)) {
      $comments = comment_load_multiple($cids);
      comment_prepare_thread($comments);
      $build = comment_view_multiple($comments, $node);
      return backdrop_render($build);
    }
  }
  return '';
}

/**
 * Implements hook_update_index().
 */
function comment_update_index() {
  // Store the maximum possible comments per thread (used for ranking by reply count)
  state_set('node_cron_comments_scale', 1.0 / max(1, db_query('SELECT MAX(comment_count) FROM {node_comment_statistics}')->fetchField()));
}

/**
 * Implements hook_node_search_result().
 *
 * Formats a comment count string and returns it, for display with search
 * results.
 */
function comment_node_search_result(Node $node) {
  // Do not make a string if comments are hidden.
  if (user_access('access comments') && $node->comment != COMMENT_NODE_HIDDEN) {
    $comments = db_query('SELECT comment_count FROM {node_comment_statistics} WHERE nid = :nid', array('nid' => $node->nid))->fetchField();
    // Do not make a string if comments are closed and there are currently
    // zero comments.
    if ($node->comment != COMMENT_NODE_CLOSED || $comments > 0) {
      return array('comment' => format_plural($comments, '1 comment', '@count comments'));
    }
  }
}

/**
 * Implements hook_user_cancel().
 */
function comment_user_cancel($edit, $account, $method) {
  switch ($method) {
    case 'user_cancel_block_unpublish':
      $comments = comment_load_multiple(array(), array('uid' => $account->uid));
      foreach ($comments as $comment) {
        $comment->status = 0;
        comment_save($comment);
      }
      break;

    case 'user_cancel_reassign':
      $comments = comment_load_multiple(array(), array('uid' => $account->uid));
      foreach ($comments as $comment) {
        $comment->uid = 0;
        comment_save($comment);
      }
      break;
  }
}

/**
 * Implements hook_user_predelete().
 */
function comment_user_predelete($account) {
  $cids = db_query('SELECT c.cid FROM {comment} c WHERE uid = :uid', array(':uid' => $account->uid))->fetchCol();
  comment_delete_multiple($cids);
}

/**
 * Implements hook_config_create_validate()
 */
function comment_config_create_validate(Config $staging_config, $all_changes) {
  $config_name = $staging_config->getName();

  // Ensure entity types and bundles exist or will be imported.
  if (strpos($config_name, 'field.instance.comment.') === 0) {
    list($node_type, $field_name) = explode('.', str_replace('field.instance.comment.', '', $config_name));
    $node_type = str_replace('comment_node_', '', $node_type);

    // Check that the node type does or will exist.
    $type_exists = (bool) node_type_get_type($node_type);
    $type_created = $all_changes['node.type.' . $node_type];
    if (!$type_exists && !$type_created) {
      throw new ConfigValidateException(t('The comment field "@name" cannot be added because the node type "@type" does not exist.', array('@name' => $field_name, '@type' => $node_type)));
    }
  }
}

/**
 * Determines whether the current user has access to a particular comment.
 *
 * Authenticated users can edit their comments, as long they have not been
 * replied to. This prevents people from changing or revising their statements,
 * based on the replies to their posts.
 *
 * @param string $op
 *   The operation to be performed on the comment. Possible values are:
 *   - create
 *   - view
 *   - update
 *   - delete
 *   - approve
 * @param Comment $comment
 *   (optional) The comment object, or NULL when using 'create' op.
 *
 * @return bool
 *   TRUE if the current user has acces to the comment, FALSE otherwise.
 *
 * @since 1.13.0 The "create" $op option was added.
 * @since 1.13.0 The "edit" $op option is deprecated. Use "update" instead.
 */
function comment_access($op, Comment $comment = NULL) {
  if ($op == 'edit') {
    // Normalize 'edit' operation to 'update'.
    $op = 'update';
    // Log to watchdog for DX. @todo add watchdog_deprecated_parameter().
    $message = 'The function comment_access() was called with the operation <em>edit</em>. This operation is now named <em>update</em>. The <em>edit</em> operation will be removed in the next major release of Backdrop.';
    $variables = array();
    watchdog('comment', $message, $variables, WATCHDOG_DEPRECATED);
  }

  if ($op == 'create') {
    return Comment::createAccess();
  }
  else {
    return $comment->access($op);
  }
}

/**
 * Saves a new or updated comment.
 *
 * @param Comment $comment
 *   A comment entity.
 *
 * @return int
 *   Either SAVED_NEW or SAVED_UPDATED depending on the operation performed.
 */
function comment_save(Comment $comment) {
  return $comment->save();
}

/**
 * Deletes a comment and all its replies.
 *
 * @param $cid
 *   The ID of the comment to delete.
 */
function comment_delete($cid) {
  comment_delete_multiple(array($cid));
}

/**
 * Deletes comments and all their replies.
 *
 * @param $cids
 *   The IDs of the comments to delete.
 *
 * @see hook_comment_predelete()
 * @see hook_comment_delete()
 */
function comment_delete_multiple($cids) {
  entity_delete_multiple('comment', $cids);
}

/**
 * Loads comments from the database.
 *
 * @param $cids
 *   An array of comment IDs.
 * @param $conditions
 *   (deprecated) An associative array of conditions on the {comments}
 *   table, where the keys are the database fields and the values are the
 *   values those fields must have. Instead, it is preferable to use
 *   EntityFieldQuery to retrieve a list of entity IDs loadable by
 *   this function.
 * @param $reset
 *   Whether to reset the internal static entity cache. Note that the static
 *   cache is disabled in comment_entity_info() by default.
 *
 * @return
 *   An array of comment objects, indexed by comment ID.
 *
 * @see entity_load()
 * @see EntityFieldQuery
 */
function comment_load_multiple($cids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('comment', $cids, $conditions, $reset);
}

/**
 * Loads the entire comment by comment ID.
 *
 * @param $cid
 *   The ID of the comment to be loaded.
 * @param $reset
 *   Whether to reset the internal static entity cache. Note that the static
 *   cache is disabled in comment_entity_info() by default.
 *
 * @return
 *   The comment object.
 */
function comment_load($cid, $reset = FALSE) {
  $comment = comment_load_multiple(array($cid), array(), $reset);
  return $comment ? $comment[$cid] : FALSE;
}

/**
 * Gets the number of new comments for the current user and the specified node.
 *
 * @param $nid
 *   Node ID to count comments for.
 * @param $timestamp
 *   Time to count from (defaults to time of last user access
 *   to node).
 *
 * @return
 *   The number of new comments or FALSE if the user is not logged in.
 */
function comment_num_new($nid, $timestamp = 0) {
  global $user;

  if ($user->uid) {
    // Retrieve the timestamp at which the current user last viewed this node.
    if (!$timestamp) {
      $timestamp = node_last_viewed($nid);
    }
    $timestamp = ($timestamp > NODE_NEW_LIMIT ? $timestamp : NODE_NEW_LIMIT);

    // Use the timestamp to retrieve the number of new comments.
    return db_query('SELECT COUNT(cid) FROM {comment} WHERE nid = :nid AND created > :timestamp AND status = :status', array(
      ':nid' => $nid,
      ':timestamp' => $timestamp,
      ':status' => COMMENT_PUBLISHED,
      ))->fetchField();
  }
  else {
    return FALSE;
  }

}

/**
 * Gets the display ordinal for a comment, starting from 0.
 *
 * Count the number of comments which appear before the comment we want to
 * display, taking into account display settings and threading.
 *
 * @param int $cid
 *   The comment ID.
 * @param string $node_type
 *   The node type of the comment's parent.
 *
 * @return
 *   The display ordinal for the comment.
 *
 * @see comment_get_display_page()
 */
function comment_get_display_ordinal($cid, $node_type) {
  // Count how many comments (c1) are before $cid (c2) in display order. This is
  // the 0-based display ordinal.
  $query = db_select('comment', 'c1');
  $query->innerJoin('comment', 'c2', 'c2.nid = c1.nid');
  $query->addExpression('COUNT(*)', 'count');
  $query->condition('c2.cid', $cid);
  if (!user_access('administer comments')) {
    $query->condition('c1.status', COMMENT_PUBLISHED);
  }
  $type = node_type_get_type($node_type);
  $mode = $type->settings['comment_mode'];

  if ($mode == COMMENT_MODE_FLAT) {
    // For flat comments, cid is used for ordering comments due to
    // unpredicatable behavior with timestamp, so we make the same assumption
    // here.
    $query->condition('c1.cid', $cid, '<');
  }
  else {
    // For threaded comments, the c.thread column is used for ordering. We can
    // use the sorting code for comparison, but must remove the trailing slash.
    // See comment_view_multiple().
    $query->where('SUBSTRING(c1.thread, 1, (LENGTH(c1.thread) -1)) < SUBSTRING(c2.thread, 1, (LENGTH(c2.thread) -1))');
  }

  return $query->execute()->fetchField();
}

/**
 * Returns the page number for a comment.
 *
 * Finds the correct page number for a comment taking into account display
 * and paging settings.
 *
 * @param int $cid
 *   The comment ID.
 * @param string $node_type
 *   The node type the comment is attached to.
 *
 * @return
 *   The page number.
 */
function comment_get_display_page($cid, $node_type) {
  $ordinal = comment_get_display_ordinal($cid, $node_type);
  $type = node_type_get_type($node_type);
  $comments_per_page = $type->settings['comment_per_page'];
  return floor($ordinal / $comments_per_page);
}

/**
 * Page callback: Displays the comment editing form.
 *
 * @param $comment
 *   The comment object representing the comment to be edited.
 *
 * @see comment_menu()
 */
function comment_edit_page($comment) {
  backdrop_set_title(t('Edit comment %comment', array('%comment' => $comment->subject)), PASS_THROUGH);
  $node = node_load($comment->nid);
  return backdrop_get_form("comment_node_{$node->type}_form", $comment);
}

/**
 * Implements hook_forms().
 */
function comment_forms() {
  $forms = array();
  foreach (node_type_get_types() as $type) {
    $forms["comment_node_{$type->type}_form"]['callback'] = 'comment_form';
  }
  return $forms;
}

/**
 * Form constructor for the basic commenting form.
 *
 * @see comment_form_validate()
 * @see comment_form_submit()
 * @see comment_form_build_preview()
 * @ingroup forms
 */
function comment_form($form, &$form_state, $comment) {
  global $user, $language_content;

  // During initial form build, add the comment entity to the form state for
  // use during form building and processing. During a rebuild, use what is in
  // the form state.
  if (!isset($form_state['comment'])) {
    $form_state['comment'] = $comment;
  }
  else {
    $comment = $form_state['comment'];
  }

  $node = node_load($comment->nid);
  $node_type = node_type_get_type($node->type);
  $form['#node'] = $node;

  // Use #comment-form as unique jump target, regardless of node type.
  $form['#id'] = backdrop_html_id('comment_form');
  $form['#theme'] = array('comment_form__node_' . $node->type, 'comment_form');

  $anonymous_contact = $node_type->settings['comment_anonymous'];
  $is_admin = (!empty($comment->cid) && user_access('administer comments'));

  if (!$user->uid && $anonymous_contact != COMMENT_ANONYMOUS_MAYNOT_CONTACT) {
    $form['#attached']['library'][] = array('system', 'jquery.cookie');
    $form['#attributes']['class'][] = 'user-info-from-cookie';
  }

  // If not replying to a comment, use our dedicated page callback for new
  // comments on nodes.
  if (empty($comment->cid) && empty($comment->pid)) {
    $form['#action'] = url('comment/reply/' . $comment->nid);
  }

  if (isset($form_state['comment_preview'])) {
    $form += $form_state['comment_preview'];
  }

  // Display author information in a fieldset for comment moderators.
  if ($is_admin) {
    $form['author'] = array(
      '#type' => 'fieldset',
      '#title' => t('Administration'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => -2,
    );
  }
  else {
    // Sets the author form elements above the subject.
    $form['author'] = array(
      '#weight' => -2,
    );
  }

  // Prepare default values for form elements.
  if ($is_admin) {
    $author = (!$comment->uid && $comment->name ? $comment->name : $comment->registered_name);
    $status = (isset($comment->status) ? $comment->status : COMMENT_NOT_PUBLISHED);
    $date = (!empty($comment->date) ? $comment->date : format_date($comment->created, 'custom', 'Y-m-d H:i O'));
  }
  else {
    if ($user->uid) {
      $author = $user->name;
    }
    else {
      $author = ($comment->name ? $comment->name : '');
    }
    $status = (user_access('skip comment approval') ? COMMENT_PUBLISHED : COMMENT_NOT_PUBLISHED);
    $date = '';
  }

  // Add the author name field depending on the current user.
  if ($is_admin) {
    $form['author']['name'] = array(
      '#type' => 'textfield',
      '#title' => t('Authored by'),
      '#default_value' => $author,
      '#maxlength' => 60,
      '#size' => 30,
      '#description' => t('Leave blank for %anonymous.', array('%anonymous' => config_get_translated('system.core', 'anonymous'))),
      '#autocomplete_path' => 'user/autocomplete',
    );
  }
  elseif ($user->uid) {
    $form['author']['_author'] = array(
      '#type' => 'item',
      '#title' => t('Your name'),
      '#markup' => theme('username', array('account' => $user)),
    );
    $form['author']['name'] = array(
      '#type' => 'value',
      '#value' => $author,
    );
  }
  else {
    $form['author']['name'] = array(
      '#type' => 'textfield',
      '#title' => t('Your name'),
      '#default_value' => $author,
      '#required' => (!$user->uid && $anonymous_contact == COMMENT_ANONYMOUS_MUST_CONTACT),
      '#maxlength' => 60,
      '#size' => 30,
    );
  }

  // Add author e-mail and homepage fields depending on the current user.
  $form['author']['mail'] = array(
    '#type' => 'email',
    '#title' => t('E-mail'),
    '#default_value' => $comment->mail,
    '#required' => (!$user->uid && $anonymous_contact == COMMENT_ANONYMOUS_MUST_CONTACT),
    '#maxlength' => 64,
    '#size' => 30,
    '#description' => t('The content of this field is kept private and will not be shown publicly.'),
    '#access' => $is_admin || (!$user->uid && $anonymous_contact != COMMENT_ANONYMOUS_MAYNOT_CONTACT),
  );
  $form['author']['homepage'] = array(
    '#type' => 'url',
    '#title' => t('Homepage'),
    '#default_value' => $comment->homepage,
    '#maxlength' => 255,
    '#size' => 30,
    '#access' => $is_admin || (!$user->uid && $anonymous_contact != COMMENT_ANONYMOUS_MAYNOT_CONTACT),
  );

  // Add administrative comment publishing options.
  $form['author']['date'] = array(
    '#type' => 'textfield',
    '#title' => t('Authored on'),
    '#default_value' => $date,
    '#maxlength' => 25,
    '#size' => 20,
    '#access' => $is_admin,
  );
  $form['author']['status'] = array(
    '#type' => 'radios',
    '#title' => t('Status'),
    '#default_value' => $status,
    '#options' => array(
      COMMENT_PUBLISHED => t('Published'),
      COMMENT_NOT_PUBLISHED => t('Not published'),
    ),
    '#access' => $is_admin,
  );

  $form['subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#maxlength' => 64,
    '#default_value' => $comment->subject,
    '#access' => $node_type->settings['comment_subject_field'],
    '#weight' => -1,
  );

  // Used for conditional validation of author fields.
  $form['is_anonymous'] = array(
    '#type' => 'value',
    '#value' => ($comment->cid ? !$comment->uid : !$user->uid),
  );

  // Add internal comment properties.
  foreach (array('cid', 'pid', 'nid', 'uid') as $key) {
    $form[$key] = array('#type' => 'value', '#value' => $comment->$key);
  }
  $form['node_type'] = array(
    '#type' => 'value',
    '#value' => 'comment_node_' . $node->type,
  );

  // If a content type has multilingual support we set the comment to inherit the
  // content language. Otherwise mark the comment as language neutral.
  $comment_langcode = $comment->langcode;
  if (($comment_langcode == LANGUAGE_NONE) && $node_type->settings['language']) {
    $comment_langcode = $language_content->langcode;
  }
  $form['langcode'] = array(
    '#type' => 'value',
    '#value' => $comment_langcode,
  );

  // Prepare cancel link.
  if (isset($_GET['destination'])) {
    $path = $_GET['destination'];
  }
  elseif (isset($node->nid) && !isset($comment->cid)) {
    $path = 'node/' . $node->nid;
  }
  elseif (isset($_SERVER['HTTP_REFERER'])) {
    $path = $_SERVER['HTTP_REFERER'];
  }
  elseif (isset($comment->cid)) {
    $path = 'comment/' . $comment->cid . '#comment-' . $comment->cid;
  }
  else {
    $path = '<front>';
  }
  $options = backdrop_parse_url($path);
  $options['attributes']['class'][] = 'form-cancel';

  // Only show the save button if comment previews are optional or if we are
  // already previewing the submission.
  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#access' => ($comment->cid && user_access('administer comments')) || $node_type->settings['comment_preview'] != BACKDROP_REQUIRED || isset($form_state['comment_preview']),
    '#weight' => 19,
  );
  $form['actions']['preview'] = array(
    '#type' => 'submit',
    '#value' => t('Preview'),
    '#access' => ($node_type->settings['comment_preview'] != BACKDROP_DISABLED),
    '#weight' => 20,
    '#submit' => array('comment_form_build_preview'),
  );
  $form['actions']['cancel'] = array(
    '#type' => 'link',
    '#title' => t('Cancel'),
    '#href' => $options['path'],
    '#options' => $options,
    '#weight' => 21,
  );

  // Attach fields.
  $comment->node_type = 'comment_node_' . $node->type;
  field_attach_form('comment', $comment, $form, $form_state);

  return $form;
}

/**
 * Form submission handler for the 'preview' button in comment_form().
 */
function comment_form_build_preview($form, &$form_state) {
  $comment = comment_form_submit_build_comment($form, $form_state);
  $form_state['comment_preview'] = comment_preview($comment);
  $form_state['rebuild'] = TRUE;
}

/**
 * Generates a comment preview.
 *
 * @see comment_form_build_preview()
 */
function comment_preview($comment) {
  global $user;

  backdrop_set_title(t('Preview comment'), PASS_THROUGH);

  $node = node_load($comment->nid);

  if (!form_get_errors()) {
    $comment->format = $comment->comment_body[LANGUAGE_NONE][0]['format'];
    // Attach the user and time information.
    if (!empty($comment->name)) {
      $account = user_load_by_name($comment->name);
    }
    elseif ($user->uid && empty($comment->is_anonymous)) {
      $account = $user;
    }

    if (!empty($account->uid)) {
      $comment->uid = $account->uid;
      $comment->name = check_plain($account->name);
      $comment->signature = $account->signature;
      $comment->signature_format = $account->signature_format;
      $comment->picture = $account->picture;
    }
    elseif (empty($comment->name)) {
      $comment->name = config_get('system.core', 'anonymous');
    }

    $comment->created = !empty($comment->created) ? $comment->created : REQUEST_TIME;
    $comment->changed = REQUEST_TIME;
    $comment->in_preview = TRUE;
    $comment_build = comment_view($comment, $node);
    $comment_build['#weight'] = -100;

    $form['comment_preview'] = $comment_build;
  }

  if ($comment->pid) {
    $build = array();
    if ($comments = comment_load_multiple(array($comment->pid), array('status' => COMMENT_PUBLISHED))) {
      $parent_comment = $comments[$comment->pid];
      $build = comment_view($parent_comment, $node);
    }
  }
  else {
    $build = node_view($node);
  }

  $form['comment_output_below'] = $build;
  $form['comment_output_below']['#weight'] = 100;

  return $form;
}

/**
 * Form validation handler for comment_form().
 *
 * @see comment_form_submit()
 */
function comment_form_validate($form, &$form_state) {
  global $user;

  entity_form_field_validate('comment', $form, $form_state);

  if (!empty($form_state['values']['cid'])) {
    // Verify the name in case it is being changed from being anonymous.
    $account = user_load_by_name($form_state['values']['name']);
    $form_state['values']['uid'] = $account ? $account->uid : 0;

    if ($form_state['values']['date'] && strtotime($form_state['values']['date']) === FALSE) {
      form_set_error('date', t('You have to specify a valid date.'));
    }
    if ($form_state['values']['name'] && !$form_state['values']['is_anonymous'] && !$account) {
      form_set_error('name', t('You have to specify a valid author.'));
    }
  }
  elseif ($form_state['values']['is_anonymous']) {
    // Validate anonymous comment author fields (if given). If the (original)
    // author of this comment was an anonymous user, verify that no registered
    // user with this name exists.
    if ($form_state['values']['name']) {
      $query = db_select('users', 'u');
      $query->addField('u', 'uid', 'uid');
      $taken = $query
        ->condition('name', db_like($form_state['values']['name']), 'LIKE')
        ->countQuery()
        ->execute()
        ->fetchField();
      if ($taken) {
        form_set_error('name', t('The name you used belongs to a registered user.'));
      }
    }
  }
}

/**
 * Prepare a comment for submission.
 */
function comment_submit($comment) {
  if (empty($comment->date)) {
    $comment->date = 'now';
  }
  $comment->created = strtotime($comment->date);
  $comment->changed = REQUEST_TIME;

  // If the comment was posted by a registered user, assign the author's ID.
  // @todo Too fragile. Should be prepared and stored in comment_form() already.
  if (!$comment->is_anonymous && !empty($comment->name) && ($account = user_load_by_name($comment->name))) {
    $comment->uid = $account->uid;
  }
  // If the comment was posted by an anonymous user and no author name was
  // required, use "Anonymous" by default.
  if ($comment->is_anonymous && (!isset($comment->name) || $comment->name === '')) {
    $comment->name = config_get('system.core', 'anonymous');
  }

  // Validate the comment's subject. If not specified, extract from comment body.
  if (trim($comment->subject) == '') {
    // The body may be in any format, so:
    // 1) Filter it into HTML
    // 2) Strip out all HTML tags
    // 3) Convert entities back to plain-text.
    $comment_body = $comment->comment_body[LANGUAGE_NONE][0];
    if (isset($comment_body['format'])) {
      $comment_text = check_markup($comment_body['value'], $comment_body['format']);
    }
    else {
      $comment_text = check_plain($comment_body['value']);
    }
    $comment->subject = truncate_utf8(trim(decode_entities(strip_tags($comment_text))), 29, TRUE);
    // Edge cases where the comment body is populated only by HTML tags will
    // require a default subject.
    if ($comment->subject == '') {
      $comment->subject = t('(No subject)');
    }
  }
  return $comment;
}

/**
 * Updates the comment entity by processing the submission's values.
 *
 * This is the default builder function for the comment form. It is called
 * during the "Save" and "Preview" submit handlers to retrieve the entity to
 * save or preview. This function can also be called by a "Next" button of a
 * wizard to update the form state's entity with the current step's values
 * before proceeding to the next step.
 *
 * @see comment_form()
 * @see comment_form_preview()
 * @see comment_form_submit()
 */
function comment_form_submit_build_comment($form, &$form_state) {
  $comment = $form_state['comment'];
  entity_form_submit_build_entity('comment', $comment, $form, $form_state);
  comment_submit($comment);
  return $comment;
}

/**
 * Form submission handler for comment_form().
 *
 * @see comment_form_validate()
 * @see comment_form_submit_build_comment()
 */
function comment_form_submit($form, &$form_state) {
  $node = node_load($form_state['values']['nid']);
  $comment = comment_form_submit_build_comment($form, $form_state);
  if (Comment::createAccess() && (user_access('administer comments') || $node->comment == COMMENT_NODE_OPEN)) {
    // Save the anonymous user information to a cookie for reuse.
    if (user_is_anonymous()) {
      user_cookie_save(array_intersect_key($form_state['values'], array_flip(array('name', 'mail', 'homepage'))));
    }

    comment_save($comment);
    $form_state['values']['cid'] = $comment->cid;

    // Add an entry to the watchdog log.
    watchdog('content', 'Comment posted: %subject.', array('%subject' => $comment->subject), WATCHDOG_NOTICE, l(t('view'), 'comment/' . $comment->cid, array('fragment' => 'comment-' . $comment->cid)));

    // Explain the approval queue if necessary.
    if ($comment->status == COMMENT_NOT_PUBLISHED) {
      if (!user_access('administer comments')) {
        backdrop_set_message(t('Your comment has been queued for review by site administrators and will be published after approval.'));
      }
    }
    else {
      backdrop_set_message(t('Your comment has been posted.'));
    }
    $query = array();
    // Find the current display page for this comment.
    $page = comment_get_display_page($comment->cid, $node->type);
    if ($page > 0) {
      $query['page'] = $page;
    }
    // Redirect to the newly posted comment.
    $redirect = array('node/' . $node->nid, array('query' => $query, 'fragment' => 'comment-' . $comment->cid));
  }
  else {
    watchdog('content', 'Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $comment->subject), WATCHDOG_WARNING);
    backdrop_set_message(t('Comment: unauthorized comment submitted or comment submitted to a closed post %subject.', array('%subject' => $comment->subject)), 'error');
    // Redirect the user to the node they are commenting on.
    $redirect = 'node/' . $node->nid;
  }
  $form_state['redirect'] = $redirect;
}

/**
 * Implements hook_preprocess_block().
 */
function comment_preprocess_block(&$variables) {
  if ($variables['block']->module == 'comment') {
    $variables['attributes']['role'] = 'navigation';
  }
}

/**
 * Prepares variables for comment.tpl.php
 *
 * @param $variables
 *   An array containing the following arguments:
 *   - $node
 *   - $view_mode
 *   - $page
 *
 * @see comment.tpl.php
 */
function comment_preprocess_node(&$variables) {
  $node = $variables['node'];
  $node_type = node_type_get_type($node->type);

  // Only append comments when we are building a node on its own node detail
  // page. We compare $node and $page_node to ensure that comments are not
  // appended to other nodes shown on the page, for example a node_reference
  // displayed in 'full' display mode within another node.
  if ($node->comment && $variables['view_mode'] == 'full' && node_is_page($node) && empty($node->in_preview)) {
    $variables['comments'] = comment_node_page_additions($node);
    $variables['comment_display_mode'] = $node_type->settings['comment_mode'];
  }
  // Simplify the variables if there are no comment parts.
  if (empty($variables['comments']['comments']) && empty($variables['comments']['comment_form'])) {
    $variables['comments'] = FALSE;
  }
}

/**
 * Returns an array of viewing modes for comment listings.
 *
 * We can't use a global variable array because the locale system
 * is not initialized yet when the Comment module is loaded.
 */
function _comment_get_modes() {
  return array(
    COMMENT_MODE_FLAT => t('Flat list'),
    COMMENT_MODE_THREADED => t('Threaded list')
  );
}

/**
 * Returns an array of "comments per page" values that users can select from.
 */
function _comment_per_page() {
  return backdrop_map_assoc(array(10, 30, 50, 70, 90, 150, 200, 250, 300));
}

/**
 * Generates a sorting code.
 *
 * Consists of a leading character indicating length, followed by N digits
 * with a numerical value in base 36 (alphadecimal). These codes can be sorted
 * as strings without altering numerical order.
 *
 * It goes:
 * 00, 01, 02, ..., 0y, 0z,
 * 110, 111, ... , 1zy, 1zz,
 * 2100, 2101, ..., 2zzy, 2zzz,
 * 31000, 31001, ...
 */
function comment_int_to_alphadecimal($i = 0) {
  $num = base_convert((int) $i, 10, 36);
  $length = strlen($num);

  return chr($length + ord('0') - 1) . $num;
}

/**
 * Decodes a sorting code back to an integer.
 *
 * @see comment_int_to_alphadecimal()
 */
function comment_alphadecimal_to_int($c = '00') {
  return base_convert(substr($c, 1), 36, 10);
}

/**
 * Increments a sorting code to the next value.
 *
 * @see comment_int_to_alphadecimal()
 */
function comment_increment_alphadecimal($c = '00') {
  return comment_int_to_alphadecimal(comment_alphadecimal_to_int($c) + 1);
}

/**
 * Implements hook_action_info().
 */
function comment_action_info() {
  return array(
    'comment_publish_action' => array(
      'label' => t('Publish comment'),
      'type' => 'comment',
      'callback' => 'comment_publish_action',
    ),
    'comment_unpublish_action' => array(
      'label' => t('Unpublish comment'),
      'type' => 'comment',
      'callback' => 'comment_unpublish_action',
    ),
  );
}

/**
 * Publishes a comment.
 *
 * @param $comment
 *   The comment object.
 *
 * @ingroup actions
 */
function comment_publish_action($comment, $context = array()) {
  $comment->status = COMMENT_PUBLISHED;
  $comment->save();
}

/**
 * Unpublishes a comment.
 *
 * @param $comment
 *   An optional comment object.
 * @param array $context
 *   Array with components:
 *   - 'cid': Comment ID. Required if $comment is not given.
 *
 * @ingroup actions
 */
function comment_unpublish_action($comment, $context = array()) {
  $comment->status = COMMENT_NOT_PUBLISHED;
  $comment->save();
}

/**
 * Implements hook_ranking().
 */
function comment_ranking() {
  return array(
    'comments' => array(
      'title' => t('Number of comments'),
      'join' => array(
        'type' => 'LEFT',
        'table' => 'node_comment_statistics',
        'alias' => 'node_comment_statistics',
        'on' => 'node_comment_statistics.nid = i.sid',
      ),
      // Inverse law that maps the highest reply count on the site to 1 and 0 to 0.
      'score' => '2.0 - 2.0 / (1.0 + node_comment_statistics.comment_count * CAST(:scale AS DECIMAL))',
      'arguments' => array(':scale' => state_get('node_cron_comments_scale', 0)),
    ),
  );
}

/**
 * Implements hook_file_download_access().
 */
function comment_file_download_access($field, $entity_type, $entity) {
  if ($entity_type == 'comment') {
    if (user_access('access comments') && $entity->status == COMMENT_PUBLISHED || user_access('administer comments')) {
      $node = node_load($entity->nid);
      return node_access('view', $node);
    }
    return FALSE;
  }
}

/**
 * Implements hook_cron().
 */
function comment_cron() {
  _comment_close_all();
}

/**
 * Close all comments that meet the current threshold.
 */
function _comment_close_all() {
  $content_types = node_type_get_names();

  foreach ($content_types as $type => $name) {
    // Get the content type settings.
    $node_type = node_type_load($type);
    $days = $node_type->settings['comment_close_days'];
    $enable = $node_type->settings['comment_close_enabled'];

    // If a day is set, do this one.
    if (!empty($enable) && !empty($days)) {
      $oldest_allowed = strtotime("-$days days", REQUEST_TIME);

      // Fetch nodes that should have comments closed.
      $result = db_query("SELECT nid FROM {node} WHERE created < :oldest AND comment_close_override = 0 AND type = :type AND comment = :comment",
        array(':oldest' => $oldest_allowed, ':type' => $type, ':comment' => COMMENT_NODE_OPEN)
      );
      $nids = $result->fetchCol();

      // Update those rows.
      foreach ($nids as $nid) {
        $node = node_load($nid);
        $node->comment = COMMENT_NODE_CLOSED;
        node_save($node);
      }

      $count  = $result->rowCount();
      if ($count) {
        $vars = array(
          '!count' => $count,
          '@type' => $name,
          '!date' => format_date($oldest_allowed),
        );
        $msg = 'Closed comments on !count @type posts created at, or before, !date.';
        watchdog('comment', $msg, $vars, WATCHDOG_NOTICE);
      }
    }
  }
}

/**
 * Implements hook_autoload_info().
 */
function comment_autoload_info() {
  return array(
    'Comment' => 'comment.entity.inc',
    'CommentStorageController' => 'comment.entity.inc',

    // Views handlers:
    'views_handler_argument_comment_user_uid' => 'views/views_handler_argument_comment_user_uid.inc',
    'views_handler_field_comment' => 'views/views_handler_field_comment.inc',
    'views_handler_field_comment_depth' => 'views/views_handler_field_comment_depth.inc',
    'views_handler_field_comment_link' => 'views/views_handler_field_comment_link.inc',
    'views_handler_field_comment_link_approve' => 'views/views_handler_field_comment_link_approve.inc',
    'views_handler_field_comment_link_delete' => 'views/views_handler_field_comment_link_delete.inc',
    'views_handler_field_comment_link_edit' => 'views/views_handler_field_comment_link_edit.inc',
    'views_handler_field_comment_link_reply' => 'views/views_handler_field_comment_link_reply.inc',
    'views_handler_field_comment_node_link' => 'views/views_handler_field_comment_node_link.inc',
    'views_handler_field_comment_username' => 'views/views_handler_field_comment_username.inc',
    'views_handler_field_ncs_last_comment_name' => 'views/views_handler_field_ncs_last_comment_name.inc',
    'views_handler_field_ncs_last_updated' => 'views/views_handler_field_ncs_last_updated.inc',
    'views_handler_field_node_comment' => 'views/views_handler_field_node_comment.inc',
    'views_handler_field_node_new_comments' => 'views/views_handler_field_node_new_comments.inc',
    'views_handler_field_last_comment_timestamp' => 'views/views_handler_field_last_comment_timestamp.inc',
    'views_handler_filter_comment_user_uid' => 'views/views_handler_filter_comment_user_uid.inc',
    'views_handler_filter_ncs_last_updated' => 'views/views_handler_filter_ncs_last_updated.inc',
    'views_handler_filter_node_comment' => 'views/views_handler_filter_node_comment.inc',
    'views_handler_sort_comment_thread' => 'views/views_handler_sort_comment_thread.inc',
    'views_handler_sort_ncs_last_comment_name' => 'views/views_handler_sort_ncs_last_comment_name.inc',
    'views_handler_sort_ncs_last_updated' => 'views/views_handler_sort_ncs_last_updated.inc',
    'views_plugin_row_comment_rss' => 'views/views_plugin_row_comment_rss.inc',
    'views_plugin_row_comment_view' => 'views/views_plugin_row_comment_view.inc',
  );
}
