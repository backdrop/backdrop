<?php

/**
 * @file
 * Defines taxonomy term reference field.
 */

/**
 * Implements hook_taxonomy_vocabulary_update().
 */
function taxonomy_term_reference_taxonomy_vocabulary_update(TaxonomyVocabulary $vocabulary) {
  // Reflect machine name changes in the definitions of existing 'taxonomy'
  // fields.
  if (!empty($vocabulary->original->machine_name) && $vocabulary->original->machine_name != $vocabulary->machine_name) {
    $fields = field_read_fields();
    foreach ($fields as $field_name => $field) {
      $update = FALSE;
      if ($field['type'] == 'taxonomy_term_reference') {
        foreach ($field['settings']['allowed_values'] as $key => &$value) {
          if ($value['vocabulary'] == $vocabulary->original->machine_name) {
            $value['vocabulary'] = $vocabulary->machine_name;
            $update = TRUE;
          }
        }
        if ($update) {
          field_update_field($field);
        }
      }
    }
  }
}

/**
 * Implements hook_field_info().
 *
 * Field settings:
 * - allowed_values: a list array of one or more vocabulary trees:
 *   - vocabulary: a vocabulary machine name.
 *   - parent: a term ID of a term whose children are allowed. This should be
 *     '0' if all terms in a vocabulary are allowed. The allowed values do not
 *     include the parent term.
 *
 */
function taxonomy_term_reference_field_info() {
  return array(
    'taxonomy_term_reference' => array(
      'label' => t('Term reference'),
      'description' => t('This field stores a reference to a taxonomy term.'),
      'default_widget' => 'options_select',
      'default_formatter' => 'taxonomy_term_reference_link',
      'default_token_formatter' => 'taxonomy_term_reference_plain',
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => '',
            'parent' => '0',
          ),
        ),
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_info().
 */
function taxonomy_term_reference_field_widget_info() {
  return array(
    'taxonomy_autocomplete' => array(
      'label' => t('Autocomplete term widget (tagging)'),
      'field types' => array('taxonomy_term_reference'),
      'settings' => array(
        'size' => 60,
        'autocomplete_path' => 'taxonomy/autocomplete',
        'follow_content_language' => TRUE,

      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_info_alter().
 */
function taxonomy_term_reference_field_widget_info_alter(&$info) {
  $info['options_select']['field types'][] = 'taxonomy_term_reference';
  $info['options_buttons']['field types'][] = 'taxonomy_term_reference';
}

/**
 * Implements hook_options_list().
 */
function taxonomy_term_reference_options_list($field, $instance, $entity_type, $entity) {
  $function = !empty($field['settings']['options_list_callback']) ? $field['settings']['options_list_callback'] : 'taxonomy_allowed_values';
  return $function($field);
}

/**
 * Implements hook_field_validate().
 *
 * Taxonomy field settings allow for either a single vocabulary ID, multiple
 * vocabulary IDs, or sub-trees of a vocabulary to be specified as allowed
 * values, although only the first of these is supported via the field UI.
 * Confirm that terms entered as values meet at least one of these conditions.
 *
 * Possible error codes:
 * - 'taxonomy_term_illegal_value': The value is not part of the list of allowed values.
 */
function taxonomy_term_reference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  // Build an array of existing term IDs so they can be loaded with
  // taxonomy_term_load_multiple();
  foreach ($items as $delta => $item) {
    if (!empty($item['tid']) && $item['tid'] != 'autocreate') {
      $tids[] = $item['tid'];
    }
  }
  if (!empty($tids)) {
    $terms = taxonomy_term_load_multiple($tids);

    // Check each existing item to ensure it can be found in the
    // allowed values for this field.
    foreach ($items as $delta => $item) {
      $validate = TRUE;
      if (!empty($item['tid']) && $item['tid'] != 'autocreate') {
        $validate = FALSE;
        foreach ($field['settings']['allowed_values'] as $settings) {
          // If no parent is specified, check if the term is in the vocabulary.
          if (isset($settings['vocabulary']) && empty($settings['parent'])) {
            if ($settings['vocabulary'] == $terms[$item['tid']]->vocabulary) {
              $validate = TRUE;
              break;
            }
          }
          // If a parent is specified, then to validate it must appear in the
          // array returned by taxonomy_term_load_parents_all().
          elseif (!empty($settings['parent'])) {
            $ancestors = taxonomy_term_load_parents_all($item['tid']);
            foreach ($ancestors as $ancestor) {
              if ($ancestor->tid == $settings['parent']) {
                $validate = TRUE;
                break 2;
              }
            }
          }
        }
      }
      if (!$validate) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'taxonomy_term_reference_illegal_value',
          'message' => t('%name: illegal value.', array('%name' => $instance['label'])),
        );
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function taxonomy_term_reference_field_is_empty($item, $field) {
  if (!is_array($item) || (empty($item['tid']) && (string) $item['tid'] !== '0')) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_field_formatter_info().
 */
function taxonomy_term_reference_field_formatter_info() {
  return array(
    'taxonomy_term_reference_link' => array(
      'label' => t('Link'),
      'field types' => array('taxonomy_term_reference'),
    ),
    'taxonomy_term_reference_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('taxonomy_term_reference'),
    ),
    'taxonomy_term_reference_rss_category' => array(
      'label' => t('RSS category'),
      'field types' => array('taxonomy_term_reference'),
    ),
    'taxonomy_term_reference_rendered' => array(
      'label' => t('Rendered term'),
      'description' => t('Display the referenced term in a specific display mode'),
      'field types' => array('taxonomy_term_reference'),
      'settings' => array('view_mode' => 'default'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function taxonomy_term_reference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  // Terms whose tid is 'autocreate' do not exist
  // yet and $item['taxonomy_term'] is not set. Theme such terms as
  // just their name.

  switch ($display['type']) {
    case 'taxonomy_term_reference_link':
      foreach ($items as $delta => $item) {
        if ($item['tid'] == 'autocreate') {
          $element[$delta] = array(
            '#markup' => check_plain($item['name']),
          );
        } else {
          $term = $item['taxonomy_term'];
          $uri = entity_uri('taxonomy_term', $term);
          $element[$delta] = array(
            '#type' => 'link',
            '#title' => $term->name,
            '#href' => $uri['path'],
            '#options' => $uri['options'],
          );
        }
      }
      break;

    case 'taxonomy_term_reference_plain':
      foreach ($items as $delta => $item) {
        $name = ($item['tid'] != 'autocreate' ? $item['taxonomy_term']->name : $item['name']);
        $element[$delta] = array(
          '#markup' => check_plain($name),
        );
      }
      break;

    case 'taxonomy_term_reference_rss_category':
      foreach ($items as $delta => $item) {
        $entity->rss_elements[] = array(
          'key' => 'category',
          'value' => $item['tid'] != 'autocreate' ? $item['taxonomy_term']->name : $item['name'],
          'attributes' => array(
            'domain' => $item['tid'] != 'autocreate' ? url('taxonomy/term/' . $item['tid'], array('absolute' => TRUE)) : '',
          ),
        );
      }
      break;

    case 'taxonomy_term_reference_rendered':
      // To prevent infinite recursion caused by reference cycles, we store
      // diplayed terms in a recursion queue.
      $recursion_queue = &backdrop_static(__FUNCTION__, array());

      // If no 'referencing entity' is set, we are starting a new 'reference
      // thread' and need to reset the queue.
      if (!isset($entity->referencing_entity)) {
        $recursion_queue = array();
      }

      // The recursion queue only needs to track terms.
      if (in_array($entity_type, array('taxonomy_term'))) {
        $recursion_queue[$entity->id()] = $entity->id();
      }

      // Check the recursion queue to determine which terms should be fully
      // displayed, and which terms will only be displayed as a title.
      $terms_display = array();
      foreach ($items as $delta => $item) {
        if (!isset($recursion_queue[$item['tid']])) {
          $terms_display[$item['tid']] = $item['taxonomy_term'];
        }
      }

      // Load and build the fully displayed terms.
      if ($terms_display) {
        foreach ($terms_display as $tid => $term) {
          $terms_display[$tid]->referencing_entity = $entity;
          $terms_display[$tid]->referencing_field = $field['field_name'];
        }
        $terms_built = taxonomy_term_view_multiple($terms_display, $settings['view_mode']);
      }

      // Assemble the render array.
      foreach ($items as $delta => $item) {
        if (isset($terms_display[$item['tid']])) {
          $element[$delta] = $terms_built['taxonomy_terms'][$item['tid']];
        } else {
          $term = $item['taxonomy_term'];
          $label = entity_label('taxonomy_term', $term);
          $uri = entity_uri('taxonomy_term', $term);
          $element[$delta] = array(
            '#type' => 'link',
            '#title' => $label,
            '#href' => $uri['path'],
            '#options' => $uri['options'],
          );
        }
      }

      break;
  }

  return $element;
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function taxonomy_term_reference_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  switch ($display['type']) {
    case 'taxonomy_term_reference_rendered':
      $entity_info = entity_get_info('taxonomy_term');
      $modes = $entity_info['view modes'];
      $options = array('default' => t("Default"));
      foreach ($modes as $name => $mode) {
        $options[$name] = $mode['label'];
      }
      $element['view_mode'] = array(
        '#title' => t('Display mode'),
        '#type' => 'select',
        '#options' => $options,
        '#default_value' => $settings['view_mode'],
        // Never empty, so no #empty_option
      );
      break;
  }
  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function taxonomy_term_reference_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $summary = array();

  switch ($display['type']) {
    case 'taxonomy_term_reference_rendered':
      $entity_info = entity_get_info('taxonomy_term');
      $modes = $entity_info['view modes'];
      $mode = $settings['view_mode'];
      if (!empty($modes[$settings['view_mode']]['label'])) {
        $mode = $modes[$settings['view_mode']]['label'];
      }
      if ($settings['view_mode'] == 'default') {
        $mode = t("Default");
      }
      $summary[] = t('Display mode: %mode', array('%mode' => $mode));
      break;
  }

  return implode('<br />', $summary);
}

/**
 * Returns the set of valid terms for a taxonomy field.
 *
 * @param $field
 *   The field definition.
 * @return
 *   The array of valid terms for this field, keyed by term id.
 */
function taxonomy_term_reference_allowed_values($field) {
  $options = array();
  foreach ($field['settings']['allowed_values'] as $tree) {
    if ($vocabulary = taxonomy_vocabulary_load($tree['vocabulary'])) {
      if ($terms = taxonomy_get_tree($vocabulary->machine_name, $tree['parent'])) {
        foreach ($terms as $term) {
          $options[$term->tid] = str_repeat('· ', $term->depth) . $term->name;
        }
      }
    }
  }
  return $options;
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * This preloads all taxonomy terms for multiple loaded objects at once and
 * unsets values for invalid terms that do not exist.
 */
function taxonomy_term_reference_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $tids = array();

  // Collect every possible term attached to any of the fieldable entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      // Force the array key to prevent duplicates.
      if ($item['tid'] != 'autocreate') {
        $tids[$item['tid']] = $item['tid'];
      }
    }
  }
  if ($tids) {
    $terms = taxonomy_term_load_multiple($tids);

    // Iterate through the fieldable entities again to attach the loaded term data.
    foreach ($entities as $id => $entity) {
      $rekey = FALSE;

      foreach ($items[$id] as $delta => $item) {
        // Check whether the taxonomy term field instance value could be loaded.
        if (isset($terms[$item['tid']])) {
          // Replace the instance value with the term data.
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['tid']];
        }
        // Terms to be created are not in $terms, but are still legitimate.
        elseif ($item['tid'] == 'autocreate') {
          // Leave the item in place.
        }
        // Otherwise, unset the instance value, since the term does not exist.
        else {
          unset($items[$id][$delta]);
          $rekey = TRUE;
        }
      }

      if ($rekey) {
        // Rekey the items array.
        $items[$id] = array_values($items[$id]);
      }
    }
  }
}

/**
 * Implodes a list of tags of a certain vocabulary into a string.
 *
 * @see backdrop_explode_tags()
 */
function taxonomy_implode_tags($tags, $vocabulary_name = NULL) {
  $typed_tags = array();
  foreach ($tags as $tag) {
    // Extract terms belonging to the vocabulary in question.
    if (!isset($vocabulary_name) || $tag->vocabulary == $vocabulary_name) {
      // Make sure we have a completed loaded taxonomy term.
      if (isset($tag->name)) {
        // Commas and quotes in tag names are special cases, so encode 'em.
        if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {
          $typed_tags[] = '"' . str_replace('"', '""', $tag->name) . '"';
        } else {
          $typed_tags[] = $tag->name;
        }
      }
    }
  }
  return implode(', ', $typed_tags);
}

/**
 * Implements hook_field_widget_form().
 */
function taxonomy_term_reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $tags = array();
  foreach ($items as $item) {
    $tags[$item['tid']] = isset($item['taxonomy_term']) ? $item['taxonomy_term'] : taxonomy_term_load($item['tid']);
  }

  $element += array(
    '#type' => 'textfield',
    '#default_value' => taxonomy_implode_tags($tags),
    '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $field['field_name'],
    '#size' => $instance['widget']['settings']['size'],
    '#maxlength' => 1024,
    '#element_validate' => array('taxonomy_autocomplete_validate'),
  );

  return $element;
}

/**
 * Form element validate handler for taxonomy term autocomplete element.
 */
function taxonomy_term_reference_autocomplete_validate($element, &$form_state) {
  $langcode = LANGUAGE_NONE;
  if (isset($form_state['values']['langcode'])) {
    $langcode = $form_state['values']['langcode'];
  }
  // Autocomplete widgets do not send their tids in the form, so we must detect
  // them here and process them independently.
  $value = array();
  if ($tags = $element['#value']) {
    // Collect candidate vocabularies.
    $field = field_widget_field($element, $form_state);
    $instance = field_widget_instance($element, $form_state);
    $vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $tree) {
      if ($vocabulary = taxonomy_vocabulary_load($tree['vocabulary'])) {
        $vocabularies[$vocabulary->machine_name] = $vocabulary;
      }
    }

    // Translate term names into actual terms.
    $typed_terms = backdrop_explode_tags($tags);
    foreach ($typed_terms as $typed_term) {
      // See if the term exists in the chosen vocabulary and return the tid;
      // otherwise, create a new 'autocreate' term for insert/update.
      if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => trim($typed_term), 'vocabulary' => array_keys($vocabularies)))) {
        $term = array_pop($possibilities);
      } else {
        $vocabulary = reset($vocabularies);
        $term = array(
          'tid' => 'autocreate',
          'name' => $typed_term,
          'vocabulary' => $vocabulary->machine_name,
          'langcode' => LANGUAGE_NONE,
        );
        if (module_exists('language') && $vocabulary->language == TAXONOMY_LANGUAGE_ENABLED  && $instance['widget']['settings']['follow_content_language']) {
          $term['langcode'] = $langcode;
        }
      }
      $value[] = (array)$term;
    }
  }

  form_set_value($element, $value, $form_state);
}

/**
 * Implements hook_field_widget_error().
 */
function taxonomy_term_reference_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}

/**
 * Implements hook_field_settings_form().
 */
function taxonomy_term_reference_field_settings_form($field, $instance, $has_data) {
  // Get proper values for 'allowed_values_function', which is a core setting.
  $vocabularies = taxonomy_vocabulary_load_multiple(FALSE);
  $options = array();
  foreach ($vocabularies as $vocabulary) {
    $options[$vocabulary->machine_name] = $vocabulary->name;
  }
  $form['allowed_values'] = array(
    '#tree' => TRUE,
  );

  foreach ($field['settings']['allowed_values'] as $delta => $tree) {
    $form['allowed_values'][$delta]['vocabulary'] = array(
      '#type' => 'select',
      '#title' => t('Vocabulary'),
      '#default_value' => $tree['vocabulary'],
      '#options' => $options,
      '#required' => TRUE,
      '#description' => t('The vocabulary which supplies the options for this field.'),
      '#disabled' => $has_data,
    );
    $form['allowed_values'][$delta]['parent'] = array(
      '#type' => 'value',
      '#value' => $tree['parent'],
    );
  }

  return $form;
}

/**
 * Implements hook_field_widget_settings_form().
 */
function taxonomy_term_reference_field_widget_settings_form($field, $instance) {
  $element = array(
    'follow_content_language' => array(
      '#type' => 'checkbox',
      '#title' => t('Follow content language'),
      '#default_value' => isset($instance['widget']['settings']['follow_content_language']) ? $instance['widget']['settings']['follow_content_language'] : TRUE,
      '#description' => t('If enabled, and if the selected vocabulary has multilingual support enabled, terms will be added in the language of the content.'),
      '#access' => (module_exists('language') && $instance['widget']['type'] == 'taxonomy_autocomplete'),
    ),
  );

  return $element;
}

/**
 * Implements hook_field_presave().
 *
 * Create any new terms defined in a freetagging vocabulary.
 */
function taxonomy_term_reference_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  foreach ($items as $delta => $item) {
    if ($item['tid'] == 'autocreate') {
      $term = entity_create('taxonomy_term', $item);
      unset($term->tid);
      taxonomy_term_save($term);
      $items[$delta]['tid'] = $term->tid;
    }
  }
}
