<?php
/**
 * @file
 * Enables users to customize URLs and provide automatic alias patterns.
 */

 /**
  * @defgroup redirect_api Redirection API
  * @{
  * Functions related to URL redirects.
  *
  * @} End of "defgroup redirect_api".
  */

 /**
  * Modules should return this value from hook_redirect_access() to allow access
  * to a redirect.
  */
 define('REDIRECT_ACCESS_ALLOW', 'allow');

 /**
  * Modules should return this value from hook_redirect_access() to deny access
  * to a redirect.
  */
 define('REDIRECT_ACCESS_DENY', 'deny');

 /**
  * Modules should return this value from hook_redirect_access() to not affect
  * redirect access.
  */
 define('REDIRECT_ACCESS_IGNORE', NULL);

/**
 * Implements hook_permission().
 */
function path_permission() {
  return array(
    'administer url aliases' => array(
      'title' => t('Administer URL aliases'),
    ),
    'create url aliases' => array(
      'title' => t('Create and edit URL aliases'),
    ),
    'administer path patterns' => array(
      'title' => t('Administer path patterns'),
      'description' => t('Allows a user to configure patterns for automated aliases and bulk delete URL-aliases.'),
    ),
    'notify of path changes' => array(
      'title' => t('Notify of automatic path changes'),
      'description' => t('Determines whether or not users are shown a notice when an automatic alias changes.'),
    ),
    'administer redirects' => array(
      'title' => t('Administer URL redirections'),
    ),
  );
}

/**
 * Implements hook_help().
 */
function path_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/config/search/redirect/404':
      $output = '<p>' . t('This page lists all paths that have resulted in 404 errors and do not yet have any redirects assigned to them.') . '</p>';
      break;
    case 'admin/reports/page-not-found':
      break;
  }
  return $output;
}

/**
 * Implements hook_menu().
 */
function path_menu() {
  $items['admin/config/search/path'] = array(
    'title' => 'URL aliases',
    'description' => "Change your site's URL paths by aliasing them.",
    'page callback' => 'path_admin_overview',
    'access arguments' => array('administer url aliases'),
    'weight' => -5,
    'file' => 'path.admin.inc',
  );
  $items['admin/config/search/path/edit/%path'] = array(
    'title' => 'Edit alias',
    'page callback' => 'path_admin_edit',
    'page arguments' => array(5),
    'access arguments' => array('administer url aliases'),
    'file' => 'path.admin.inc',
  );
  $items['admin/config/search/path/delete/%path'] = array(
    'title' => 'Delete alias',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('path_admin_delete_confirm', 5),
    'access arguments' => array('administer url aliases'),
    'file' => 'path.admin.inc',
  );
  $items['admin/config/search/path/list'] = array(
    'title' => 'List URL aliases',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/config/search/path/add'] = array(
    'title' => 'Add URL alias',
    'page callback' => 'path_admin_edit',
    'access arguments' => array('administer url aliases'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'path.admin.inc',
  );
  $items['admin/config/search/path/patterns'] = array(
    'title' => 'Patterns',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('path_patterns_form'),
    'access arguments' => array('administer path patterns'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
    'file' => 'path.admin.inc',
  );
  $items['admin/config/search/path/patterns/list'] = array(
    'title' => 'List patterns',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('path_patterns_form'),
    'access arguments' => array('administer path patterns'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
    'file' => 'path.admin.inc',
  );
  $items['admin/config/search/path/patterns/settings'] = array(
    'title' => 'Pattern Settings',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('path_patterns_settings_form'),
    'access arguments' => array('administer path patterns'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
    'file' => 'path.admin.inc',
  );
  $items['admin/config/search/path/bulk-update'] = array(
    'title' => 'Bulk generate',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('path_bulk_update_form'),
    'access arguments' => array('administer url aliases'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 30,
    'file' => 'path.admin.inc',
  );
  $items['admin/config/search/path/bulk-delete'] = array(
    'title' => 'Delete aliases',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('path_admin_bulk_delete'),
    'access arguments' => array('administer url aliases'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 40,
    'file' => 'path.admin.inc',
  );

  // Redirect menu items.
  $items['admin/config/search/redirect'] = array(
    'title' => 'URL redirects',
    'description' => 'Redirect users from one URL to another.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('redirect_list_form'),
    'access arguments' => array('administer redirects'),
    'file' => 'redirect.admin.inc',
  );
  $items['admin/config/search/redirect/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/config/search/redirect/add'] = array(
    'title' => 'Add redirect',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('redirect_edit_form'),
    'access callback' => 'redirect_access',
    'access arguments' => array('create', 'redirect'),
    'file' => 'redirect.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/config/search/redirect/edit/%redirect'] = array(
    'title' => 'Edit redirect',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('redirect_edit_form', 5),
    'access callback' => 'redirect_access',
    'access arguments' => array('update', 5),
    'file' => 'redirect.admin.inc',
  );
  $items['admin/config/search/redirect/delete/%redirect'] = array(
    'title' => 'Delete redirect',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('redirect_delete_form', 5),
    'access callback' => 'redirect_access',
    'access arguments' => array('delete', 5),
    'file' => 'redirect.admin.inc',
  );
  $items['admin/config/search/redirect/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure behavior for URL redirects.',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('redirect_settings_form'),
    'access arguments' => array('administer redirects'),
    'file' => 'redirect.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 50,
  );

  // Add an action link to the 404 page.
  $site_404 = config_get('system.site_404');
  if (empty($path)) {
    $site_404 = 'system/404';
  }
  $items[$site_404 . '/add-redirect'] = array(
    'title' => 'Add URL redirect from this page to another location',
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'redirect_add_redirect_page',
    'access callback' => 'redirect_access',
    'access arguments' => array('create', 'redirect'),
    'file' => 'redirect.admin.inc',
  );

  // If the database logging module is enabled, add special 404 listing pages.
  if (module_exists('dblog')) {
    $items['admin/config/search/redirect/404'] = array(
      'title' => 'Fix 404 pages',
      'description' => 'Add redirects for 404 pages.',
      'page callback' => 'redirect_404_list',
      'access arguments' => array('administer redirects'),
      'file' => 'redirect.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 20,
    );
    $items['admin/reports/page-not-found/redirect'] = array(
      'title' => 'Fix 404 pages with URL redirects',
      'page callback' => 'backdrop_goto',
      'page arguments' => array('admin/config/search/redirect/404'),
      'access arguments' => array('administer redirects'),
      'type' => MENU_LOCAL_ACTION,
    );
  }

  // Devel generate integration.
  if (module_exists('devel_generate')) {
    $items['admin/config/development/generate/redirects'] = array(
      'title' => 'Generate redirects',
      'description' => 'Generate a given number of redirects. Optionally delete current redirects.',
      'page callback' => 'backdrop_get_form',
      'page arguments' => array('redirect_generate_form'),
      'access arguments' => array('administer redirects'),
      'file' => 'redirect.generate.inc',
    );
    $items['admin/config/search/redirect/generate'] = $items['admin/config/development/generate/redirects'];
    $items['admin/config/search/redirect/generate']['type'] = MENU_LOCAL_ACTION;
  }

  return $items;
}

function redirect_set_current_redirect($redirect) {
  $static = &backdrop_static(__FUNCTION__);
  $static = $redirect;
}

function redirect_get_current_redirect() {
  $redirect = backdrop_static('redirect_set_current_redirect', NULL);

  // If a redirect has not been set with redirect_set_current_redirect(), then
  // attempt to find a redirect matching the current path, query string, and
  // language code.
  if (!isset($redirect)) {
    $redirect = redirect_load_by_source(current_path(), $GLOBALS['language']->langcode, backdrop_get_query_parameters());
  }

  // @todo Add an alter hook here?
  return $redirect;
}

/**
 * Implements hook_url_inbound_alter().
 */
function path_url_inbound_alter(&$path, $original_path, $path_language) {
  // If the current path global does not exist, then backdrop_get_path_alias()
  // will fail. This condition only happens when $path is the front page.
  // @todo Remove when http://drupal.org/node/1329914 is fixed in core.
  if (empty($_GET['q'])) {
    $_GET['q'] = config_get('system.core', 'site_frontpage');
    return;
  }

  // If the inbound path has been changed, then attempt to find a redirect
  // matching the original path and save it for processing later in
  // redirect_init(). For example, if the Sub-pathauto module changes the path
  // 'foo/redirect' to 'node/1/redirect', and there is a redirect enabled for
  // the path 'foo/redirect', then redirect_init() would normally fail since it
  // would not find a match.
  if ($path != $original_path && $original_path == current_path()) {
    $current_langcode = !empty($path_language) ? $path_language : $GLOBALS['language']->langcode;
    $current_query = backdrop_get_query_parameters();
    if ($redirect = redirect_load_by_source($original_path, $current_langcode, $current_query)) {
      redirect_set_current_redirect($redirect);
    }
  }

  // Redirect to canonical URLs.
  // Commented out per https://www.drupal.org/node/2048137.
  //if ($path && variable_get('redirect_canonical', 1)) {
    //$alias = backdrop_get_path_alias($path, $path_language);
    //if ($alias != $path && $alias != $original_path) {
      //return redirect_redirect(array('redirect' => $alias, 'type' => 'global'));
    //}

    // Redirect from default entity paths to the proper entity path.
    //if ($path_entity = redirect_load_entity_from_path($path)) {
    //  if ($uri = entity_uri($path_entity['entity_type'], $path_entity['entity'])) {
    //    if ($path != $uri['path']) {
    //      return redirect_redirect(array('redirect' => $uri['path'], 'redirect_options' => $uri['options'], 'type' => 'global'));
    //    }
    //  }
    //}
  //}
}

/**
 * Implements hook_entity_info_alter().
 */
function path_entity_info_alter(&$info) {
  $default_paths = array(
    'node' => 'node/%node',
    'user' => 'user/%user',
    'taxonomy_term' => 'taxonomy/term/%taxonomy_term',
  );

  foreach ($default_paths as $entity_type => $default_path) {
    if (isset($info[$entity_type]) && !isset($info[$entity_type]['default path'])) {
      $info[$entity_type]['default path'] = $default_path;
    }
  }

  // Disable support for some entity types that cause problems.
  $unsupported_entity_types = array(
    'comment',
    'media',
  );
  foreach ($unsupported_entity_types as $unsupported_entity_type) {
    if (isset($info[$unsupported_entity_type])) {
      $info[$unsupported_entity_type]['redirect'] = FALSE;
    }
  }
}

/**
 * Check if an entity type supports redirects.
 *
 * @param $entity_type
 *   An entity type.
 *
 * @return
 *   TRUE if the entity type has an uri callback and supports redirects, or
 *   FALSE otherwise.
 */
function redirect_entity_type_supports_redirects($entity_type) {
  $types = &backdrop_static(__FUNCTION__);

  if (!isset($types)) {
    $types = array();
    foreach (entity_get_info() as $type => $entity_info) {
      $types[$type] = !empty($entity_info['uri callback']) && (!isset($entity_info['redirect']) || !empty($entity_info['redirect']));
    }
  }

  return isset($types[$entity_type]) ? $types[$entity_type] : FALSE;
}

/**
 * Implements hook_init().
 */
function path_init() {
  if (!redirect_can_redirect()) {
    return;
  }

  // Fetch the current redirect.
  if ($redirect = redirect_get_current_redirect()) {
    redirect_redirect($redirect);
  }

  $redirect_global = FALSE;
  $request_uri = $original_uri = ltrim(request_uri(), '/');

  // Redirect from non-clean URLs to clean URLs.
  if (config_get('redirect.settings', 'global_clean') && config_get('system.core', 'clean_url') && strpos($request_uri, '?q=') !== FALSE) {
    //$redirect_global = TRUE;
    //$request_uri = str_replace('?q=', '', $request_uri);
  }

  if (strpos($request_uri, 'index.php') !== FALSE) {
    //$redirect_global = TRUE;
    //$request_uri = str_replace('index.php', '', $request_uri);
  }

  //$request_uri = ltrim($request_uri, '/');
  //$parsed = parse_url($request_uri);

  if ($redirect_global && $request_uri != $original_uri) {
    redirect_redirect(array(/*'redirect' => $request_uri,*/ 'type' => 'global'));
  }
}

/**
 * Implements hook_cron().
 */
function path_cron() {
  // Purge inactive self-managed redirects from the database.
  redirect_purge_inactive_redirects();
}

/**
 * Implements hook_exit().
 */
function path_exit($destination = NULL) {
  // If the current page is being cached, track it.
  if (backdrop_get_http_header('Location') && $rid = backdrop_get_http_header('X-Redirect-ID')) {
    // Ensure the database is loaded. This is only the next bootstrap step
    // after BACKDROP_BOOTSTRAP_DATABASE
    backdrop_bootstrap(BACKDROP_BOOTSTRAP_DATABASE);
    db_update('redirect')
      ->fields(array('access' => REQUEST_TIME))
      ->expression('count', 'count + 1')
      ->condition('rid', $rid)
      ->execute();
  }
}

/**
 * Implements hook_hook_info().
 */
function path_hook_info() {
  $hooks = array(
    'path_info',
    'path_info_alter',
    'path_pattern_alter',
    'path_alias_alter',
    'path_is_alias_reserved',
    'redirect_load',
    'redirect_load_by_source_alter',
    'redirect_access',
    'redirect_prepare',
    'redirect_validate',
    'redirect_presave',
    'redirect_insert',
    'redirect_update',
    'redirect_delete',
    'redirect_alter',
  );
  return array_fill_keys($hooks, array('group' => 'path'));
}

/**
 * Implements hook_action_info().
 */
function path_action_info() {
  $info['path_node_update_action'] = array(
    'type' => 'node',
    'label' => t('Update node alias'),
    'callback' => 'path_save_automatic_entity_alias',
    'file' => 'path.inc',
  );
  $info['path_taxonomy_term_update_action'] = array(
    'type' => 'taxonomy_term',
    'label' => t('Update taxonomy term alias'),
    'callback' => 'path_save_automatic_entity_alias',
    'file' => 'path.inc',
  );
  $info['path_user_update_action'] = array(
    'type' => 'user',
    'label' => t('Update user alias'),
    'callback' => 'path_save_automatic_entity_alias',
    'file' => 'path.inc',
  );

  return $info;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form().
 *
 * @see path_form_element_validate()
 */
function path_form_node_form_alter(&$form, $form_state) {
  $node = $form['#node'];
  $form['path'] = path_form_element($node);
  $form['path']['alias']['#description'] = t('The alternative URL for this content. Use a relative path without a trailing slash. For example, enter "about" for the about page.');
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function path_form_node_type_form_alter(&$form, $form_state) {
  $url_pattern = config_get('path.settings', 'node_pattern');
  if (isset($form['type']['#default_value'])) {
    $type = $form['type']['#default_value'];
    $specific_url_pattern = config_get('path.settings', 'node_' . $type . '_pattern');
    if ($specific_url_pattern != NULL) {
      $url_pattern = $specific_url_pattern;
    }
  }

  $settings = array(
    'default' => $url_pattern,
    'description' => t('New pages will have URLs that match a pattern based on wildcards called <em>tokens</em>. For example the URL "blog/my-first-post" could be created using the pattern "blog/[node:title]" if the title of the blog post was "My first post".'),
    'token_types' => array('node'),
  );
  $form += path_pattern_settings_form($settings);
  $form['#submit'][] = 'path_node_type_form_submit';
}

/**
 * Submit handler for node type form.
 */
function path_node_type_form_submit($form, &$form_state) {
  if (isset($form_state['values']['path_pattern'])) {
    $config = config('path.settings');
    $pattern_type  = 'node_' . $form['type']['#default_value'] . '_pattern';
    $pattern = trim($form_state['values']['path_pattern']);
    $generic_pattern = $config->get('node_pattern');
    // Don't save the specific pattern if it matches the general pattern.
    if ($pattern && $pattern !== $generic_pattern) {
      $config->set($pattern_type, $pattern);
    }
    else {
      // If the specific pattern matches the general pattern or is empty delete
      // the specific pattern.
      $config->clear($pattern_type);
      if (empty($pattern)) {
        backdrop_set_message(t('The Default URL pattern was empty, so the generic pattern of "@pattern" will still be used. This may be changed on the !url_alias_patterns page.', array('@pattern' => $generic_pattern, '!url_alias_patterns' => l('URL alias patterns', 'admin/config/search/path/patterns'))));
      }
    }
    $config->save();
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_form_term().
 */
function path_form_taxonomy_form_term_alter(&$form, $form_state) {
  // Make sure this does not show up on the delete confirmation form.
  $term = $form['#term'];
  if (is_array($term)) {
    $term = new TaxonomyTerm($term);
  }
  $form['path'] = path_form_element($term);
  $form['path']['alias']['#description'] = t("Optionally specify an alternative URL by which this term can be accessed. Use a relative path and don't add a trailing slash or the URL alias won't work.");
}

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_form_vocabulary().
 */
function path_form_taxonomy_form_vocabulary_alter(&$form, $form_state) {
  $url_pattern = config_get('path.settings', 'taxonomy_term_pattern');
  if (isset($form['#vocabulary']->machine_name)) {
    $specific_url_pattern = config_get('path.settings', 'taxonomy_term_' . $form['#vocabulary']->machine_name . '_pattern');
    if ($specific_url_pattern != NULL) {
      $url_pattern = $specific_url_pattern;
    }
  }

  $settings = array(
    'default' => $url_pattern,
    'description' => t('New pages will have URLs that match a pattern based on wildcards called <em>tokens</em>. For example the URL "tags/environment" could be created using the pattern "[term:vocabulary]/[term:name]" if the vocabulary is named "Tags" and the term is named "Environment".'),
    'token_types' => array('vocabulary', 'term'),
  );
  $form += path_pattern_settings_form($settings);
  $form['#submit'][] = 'path_taxonomy_form_vocabulary_submit';
}

/**
 * Submit handler for taxonomy_form_vocabulary().
 */
function path_taxonomy_form_vocabulary_submit($form, &$form_state) {
  if (isset($form_state['values']['path_pattern'])) {
    $config = config('path.settings');
    $pattern_type  = 'taxonomy_term_' . $form['#vocabulary']->machine_name . '_pattern';
    $pattern = trim($form_state['values']['path_pattern']);
    $generic_pattern = $config->get('taxonomy_term_pattern');

    // Don't save the specific pattern if it matches the general pattern.
    if ($pattern && $pattern !== $generic_pattern) {
      $config->set($pattern_type, $pattern);
    }
    else {
      // If the specific pattern matches the general pattern or is empty delete
      // the specific pattern.
      $config->clear($pattern_type);
      if (empty($pattern)) {
        backdrop_set_message(t('The Default URL pattern was empty, so the generic pattern of "@pattern" will still be used. This may be changed on the !url_alias_patterns page.', array('@pattern' => $generic_pattern, '!url_alias_patterns' => l('URL alias patterns', 'admin/config/search/path/patterns'))));
      }
    }
    $config->save();
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for user_admin_settings().
 */
function path_form_user_admin_settings_alter(&$form, $form_state) {
  $settings = array(
    'default' => config_get('path.settings', 'user_pattern'),
    'description' => t('New pages will have URLs that match a pattern based on wildcards called <em>tokens</em>. For example the URL "members/jane-doe" could be created using the pattern "members/[user:name]" if the user name is "Jane Doe".'),
    'token_types' => array('user'),
  );
  $form += path_pattern_settings_form($settings);
  $form['path']['#weight'] = -1;
  $form['path']['#collapsible'] = FALSE;
  $form['#submit'][] = 'path_user_admin_settings_submit';
}

/**
 * Submit handler for user_admin_settings().
 */
function path_user_admin_settings_submit($form, &$form_state) {
  if (isset($form_state['values']['path_pattern'])) {
    config_set('path.settings', 'user_pattern', $form_state['values']['path_pattern']);
  }
}

/**
 * Return URL pattern settings form for easy addition into other forms.
 *
 * @param $settings
 *   Array of variables needed to complete the form, including:
 *     default: Default value for URL pattern field.
 *     description: Description for the Default URL pattern field.
 *     token_types: Array of token types available.
 *
 * @return $form
 *   The complete form with path pattern settings fields added.
 */
function path_pattern_settings_form($settings) {
  $form['path'] = array(
    '#type' => 'fieldset',
    '#title' => t('URL pattern'),
    '#group' => 'additional_settings',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#access' => user_access('administer path patterns'),
  );
  $form['path']['path_pattern'] = array(
    '#type' => 'textfield',
    '#title' => t('Default URL pattern'),
    '#default_value' => $settings['default'],
    '#description' => $settings['description'],
  );
  $form['path']['path_tokens'] = array(
    '#theme' => 'token_tree_link',
    '#token_types' => $settings['token_types'],
    '#global_types' => FALSE,
    '#click_insert' => TRUE,
  );

  return $form;
}

/**
 * Implements hook_entity_load().
 */
function path_entity_load($entities, $type) {
  static $path_entity_types;

  // Compile the list of supported entity types.
  if (!isset($path_entity_types)) {
    $path_entity_types = array();
    $all_path_info = path_get_info();
    foreach ($all_path_info as $path_info) {
      if (isset($path_info['entity type'])) {
        $path_entity_types[] = $path_info['entity type'];
      }
    }
  }

  // Modify the entity if supported to include canonical path information.
  if (in_array($type, $path_entity_types)) {
    path_load_multiple_by_entities($entities);
  }
}

/**
 * Implements hook_entity_insert().
 */
function path_entity_insert(Entity $entity) {
  $langcode = isset($entity->langcode) ? $entity->langcode : LANGUAGE_NONE;
  $uri = $entity->uri();

  $path = array();
  if (isset($entity->path)) {
    $path = $entity->path;
    $path['source'] = $uri['path'];
  }

  // If no pattern exists for this entity type, default to a manual alias.
  $pattern = path_get_pattern_by_entity_type($entity->entityType(), $entity->bundle(), $langcode);
  $path += array(
    'pid' => NULL,
    'alias' => '',
    'source' => $uri['path'],
    'langcode' => $langcode,
    'auto' => strlen($pattern) === 0 ? FALSE : TRUE,
  );

  // Trim whitespace and slashes from alias start and end.
  $path['alias'] = trim($path['alias'], " \t\n\r\0\x0B/");

  // Save an automatic alias if specified.
  if ($path['auto']) {
    module_load_include('inc', 'path');
    $path = path_save_automatic_entity_alias($entity);
  }
  // Otherwise save any specified alias.
  elseif ($path['alias']) {
    path_save($path);
  }

  // Save the updated path into the entity.
  if ($path) {
    $entity->path = $path;
  }
}

/**
 * Implements hook_entity_update().
 */
function path_entity_update(Entity $entity) {
  if (isset($entity->path)) {
    $langcode = isset($entity->langcode) ? $entity->langcode : LANGUAGE_NONE;
    $uri = $entity->uri();
    $path = $entity->path;
    $path_original = $entity->original->path;
    $path['source'] = $uri['path'];

    //save a redirect if the path is changed on node save.
    if (!config_get('redirect.settings', 'auto_redirect')) {
      return;
    }
    elseif (isset($path['redirect']) && !$path['redirect']) {
      return;
    }

    if (
        // !empty($path_original['pid']) &&
        // $path_original['pid'] == $path['pid'] &&
        // $path_original['alias'] != $path['alias']
        $entity->title != $entity->original->title
      ) {
      $redirect = new Redirect(array(
        'source' => $path_original['alias'],
        'redirect' => $path['source'],
        'langcode' => $path_original['langcode'],
      ));

      // Check if the redirect exists before saving.
      $hash = redirect_hash($redirect);
      if (!redirect_load_by_hash($hash)) {
        redirect_save($redirect);
      }
    }

    // If no pattern exists for this entity type, default to a manual alias.
    $pattern = path_get_pattern_by_entity_type($entity->entityType(), $entity->bundle(), $langcode);
    $path += array(
      'pid' => NULL,
      'alias' => '',
      'langcode' => $langcode,
      'auto' => strlen($pattern) === 0 ? FALSE : TRUE,
    );

    // Trim whitespace and slashes from alias start and end.
    $path['alias'] = trim($path['alias'], " \t\n\r\0\x0B/");

    // Save an automatic alias if specified.
    if ($path['auto']) {
      module_load_include('inc', 'path');
      $path = path_save_automatic_entity_alias($entity);

      // Ideally this would be in hook_taxonomy_term_update() instead, but
      // as hook_entity_update() fires second, we have to include it directly
      // here.
      if ($entity->entityType() === 'taxonomy_term') {
        // Generate new aliases for all children as well.
        foreach (taxonomy_get_tree($entity->vocabulary, $entity->tid, NULL, TRUE) as $subterm) {
          path_save_automatic_entity_alias($subterm);
        }
      }
    }
    else {
      // Delete old alias if user erased it.
      if (!empty($path['pid']) && empty($path['alias'])) {
        path_delete($path['pid']);
      }
      // Update or create any specified alias.
      if (!empty($path['alias'])) {
        path_save($path);
      }
    }

    // Save the updated path into the entity.
    if ($path) {
      $entity->path = $path;
    }
  }
}

/**
 * Implements hook_entity_info().
 */
function path_entity_info() {
  $info['redirect'] = array(
    'label' => t('Redirect'),
    'base table' => 'redirect',
    'entity class' => 'Redirect',
    'controller class' => 'RedirectController',
    'entity keys' => array(
      'id' => 'rid',
      'bundle' => 'type',
    ),
    'fieldable' => FALSE,
    'uuid' => FALSE,
    'redirect' => FALSE,
  );

  return $info;
}

/**
 *  Create a redirect hash.
 *  @param
 *   Redirect entity.
 *
 *  @return
 *    A redirect hash string.
 */
function redirect_hash(Redirect $redirect) {
  $hash = array(
    'source' => $redirect->source,
    'langcode' => $redirect->langcode,
  );
  if (!empty($redirect->source_options['query'])) {
    $hash['source_query'] = $redirect->source_options['query'];
  }
  backdrop_alter('redirect_hash', $hash, $redirect);
  redirect_sort_recursive($hash, 'ksort');
  $redirect->hash = backdrop_hash_base64(serialize($hash));
  return $redirect->hash;
}

/**
 * Sort an array recusively.
 *
 * @param $array
 *   The array to sort, by reference.
 * @param $callback
 *   The sorting callback to use (e.g. 'sort', 'ksort', 'asort').
 *
 * @return
 *   TRUE on success or FALSE on failure.
 */
function redirect_sort_recursive(&$array, $callback = 'sort') {
  $result = $callback($array);
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      $result &= redirect_sort_recursive($array[$key], $callback);
    }
  }
  return $result;
}

/**
 * Load an URL redirect from the database.
 *
 * @param $rid
 *   The URL redirect ID.
 * @param $reset
 *   Whether to reset the redirect_load_multiple cache.
 *
 * @return
 *   An URL redirect object, or FALSE if loading failed.
 *
 * @ingroup redirect_api
 */
function redirect_load($rid, $reset = FALSE) {
  $redirects = entity_load('redirect', array($rid), array(), $reset);
  return !empty($redirects) ? reset($redirects) : FALSE;
}

/**
 * Load an URL redirect from the database by {redirect}.hash.
 *
 * @param $hash
 *   The hash of the URL redirect.
 * @param $reset
 *   Whether to reset the redirect_load_multiple cache.
 *
 * @return
 *   An URL redirect object, or FALSE if loading failed.
 *
 * @ingroup redirect_api
 */
function redirect_load_by_hash($hash, $reset = FALSE) {
  $redirects = entity_load('redirect', FALSE, array('hash' => $hash), $reset);
  return !empty($redirects) ? reset($redirects) : FALSE;
}

/**
 * Load multiple URL redirects from the database by {redirect}.source.
 *
 * @param $source
 *   The source of the URL redirect.
 * @param $langcode
 *   Language code of the source URL.
 * @param $query
 *   Array of URL query parameters.
 *
 * @return
 *   The first matched URL redirect object, or FALSE if there aren't any.
 *
 * @see redirect_load_multiple()
 * @see _redirect_uasort()
 * @see redirect_compare_array_recursive()
 *
 * @ingroup redirect_api
 */
function redirect_load_by_source($source, $langcode = LANGUAGE_NONE, array $query = array()) {
  // Run a case-insensitive query for matching RIDs first.
  $rid_query = db_select('redirect');
  $rid_query->addField('redirect', 'rid');
  $sys_config = config('system.core');
  if ($source != $sys_config->get('site_frontpage', 'node')) {
    $rid_query->condition('source', db_like($source), 'LIKE');
  }
  else {
    $source_condition = db_or();
    $source_condition->condition('source', db_like($source), 'LIKE');
    $source_condition->condition('source', '');
    $rid_query->condition($source_condition);
  }
  $rid_query->condition('langcode', array($langcode, LANGUAGE_NONE));
  $rids = $rid_query->execute()->fetchCol();

  if ($rids && $redirects = redirect_load_multiple($rids)) {
    // Narrow down the list of candidates.
    foreach ($redirects as $rid => $redirect) {
      if (!empty($redirect->source_options['query'])) {
        if (empty($query) || !redirect_compare_array_recursive($redirect->source_options['query'], $query)) {
          unset($redirects[$rid]);
          continue;
        }
      }

      // Add a case sensitive matches condition to be used in sorting.
      if ($source !== $redirect->source) {
        $redirects[$rid]->weight = 1;
      }
    }

    if (!empty($redirects)) {
      // Sort the redirects in the proper order.
      uasort($redirects, '_redirect_uasort');

      // Allow other modules to alter the redirect candidates before selecting the top one.
      $context = array('langcode' => $langcode, 'query' => $query);
      backdrop_alter('redirect_load_by_source', $redirects, $source, $context);

      return !empty($redirects) ? reset($redirects) : FALSE;
    }
  }

  return FALSE;
}

/**
 * Load multiple URL redirects from the database.
 *
 * @param $rids
 *   An array of redirect IDs.
 * @param $conditions
 *   An array of conditions on the {redirect} table in the form 'field' =>
 *   $value.
 * @param $reset
 *   Whether to reset the redirect_load_multiple cache.
 *
 * @return
 *   An array of URL redirect objects indexed by redirect IDs.
 *
 * @ingroup redirect_api
 */
function redirect_load_multiple($rids = array(), array $conditions = array(), $reset = FALSE) {
  return entity_load('redirect', $rids, $conditions, $reset);
}

/**
 * Determine whether the current user may perform the given operation on the
 * specified redirect.
 *
 * @param $op
 *   The operation to be performed on the redirect. Possible values are:
 *   - "create"
 *   - "update"
 *   - "delete"
 * @param $redirect
 *   The redirect object on which the operation is to be performed, or redirect
 *   type (e.g. 'feedburner') for the "create" operation.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 *
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function redirect_access($op, $redirect, $account = NULL) {
  global $user;

  $rights = &backdrop_static(__FUNCTION__, array());

  if (!$redirect || !in_array($op, array('create', 'update', 'delete'), TRUE)) {
    // If there was no redirect to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $user;
  }

  $cid = isset($redirect->rid) ? $redirect->rid : $redirect;

  // Return cached value if access already checked for this redirect, user and op.
  if (isset($rights[$account->uid][$cid][$op])) {
    return $rights[$account->uid][$cid][$op];
  }

  // Administrators can access all redirects.
  if (user_access('administer redirects', $account)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  // We grant access to the redirect if both of the following conditions are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  $access = module_invoke_all('redirect_access', $op, $redirect, $account);
  if (in_array(REDIRECT_ACCESS_DENY, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }
  elseif (in_array(REDIRECT_ACCESS_ALLOW, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  return FALSE;
}

/**
 * Validate a redirect.
 */
function redirect_validate(Redirect $redirect, $form, &$form_state) {
  // Check that there there are no redirect loops.
  if (url($redirect->source) == url($redirect->redirect)) {
    form_set_error('redirect', t('You are attempting to redirect the page to itself. This will result in an infinite loop.'));
  }

  redirect_hash($redirect);
  if ($existing = redirect_load_by_hash($redirect->hash)) {
    if ($redirect->rid != $existing->rid) {
      form_set_error('source', t('The source path %source is already being redirected. Do you want to <a href="@edit-page">edit the existing redirect</a>?', array('%source' => redirect_url($redirect->source, $redirect->source_options), '@edit-page' => url('admin/config/search/redirect/edit/'. $existing->rid))));
    }
  }

  // Allow other modules to validate the redirect.
  foreach (module_implements('redirect_validate') as $module) {
    $function = $module . '_redirect_validate';
    $function($redirect, $form, $form_state);
  }
}

function redirect_object_prepare($redirect, $defaults = array()) {
  $defaults += array(
    'rid' => NULL,
    'type' => 'redirect',
    'uid' => $GLOBALS['user']->uid,
    'source_options' => array(),
    'redirect_options' => array(),
    'langcode' => LANGUAGE_NONE,
    'status_code' => 0,
    'count' => 0,
    'access' => 0,
    'hash' => '',
  );

  foreach ($defaults as $key => $default) {
    if (!isset($redirect->{$key})) {
      $redirect->{$key} = $default;
    }
  }

  module_invoke_all('redirect_prepare', $redirect);
}

/**
 * Save an URL redirect.
 *
 * @param $redirect
 *   The URL redirect object to be saved. If $redirect->rid is omitted (or
 *   $redirect->is_new is TRUE), a new redirect will be added.
 *
 * @ingroup redirect_api
 */
function redirect_save(Redirect $redirect) {
  $redirect->save();
}

/**
 * Perform an URL redirect.
 *
 * @param $redirect
 *   An optional URL redirect array.
 *
 * @ingroup redirect_api
 */
function redirect_redirect($redirect = NULL) {
  if (!isset($redirect)) {
    $redirect = new Redirect(array(
      'redirect' => current_path(),
      'type' => 'manual',
      'cache' => TRUE,
    ));
  }

  if (config_get('redirect.settings', 'passthrough_querystring')) {
    // Preserve the current query parameters in the redirect.
    $redirect->redirect_options += array('query' => array());
    $redirect->redirect_options['query'] += backdrop_get_query_parameters();
  }

  // Prevent the destination query parameter from overriding this redirect.
  //if (isset($_GET['destination'])) {
    // Simply unset the parameter since it has already been passed into
    // $options['query'] in the previous code.
  //  unset($_GET['destination']);
  //}

  // Allow other modules to alter the redirect before passing to backdrop_goto().
  backdrop_alter('redirect', $redirect);

  // Continue if the redirect has not been disabled by hook_redirect_alter().
  if (isset($redirect->redirect) && isset($redirect->callback) && $redirect->redirect !== FALSE && function_exists($redirect->callback)) {
    // Perform the actual redirect.
    $callback = $redirect->callback;
    $callback($redirect);
  }
}

/**
 * Redirect callback; perform an URL redirect.
 */
function redirect_goto($redirect) {
  $redirect->redirect_options['absolute'] = TRUE;
  $url = url($redirect->redirect, $redirect->redirect_options);
  backdrop_add_http_header('Location', $url);
  backdrop_add_http_header('Status', redirect_status_code_options($redirect->status_code));

  if (!empty($redirect->rid)) {
    // Add a custom header for the redirect ID so when the redirect is served
    // from the page cache, we can track it.
    backdrop_add_http_header('X-Redirect-ID', $redirect->rid);
  }
  $config = config('redirect.settings');
  $sys_config = config('system.core');
  if (!$config->get('page_cache') || !$sys_config->get('cache') || !backdrop_page_is_cacheable() || empty($redirect->cache)) {
    backdrop_exit($url);
  }

  // @see backdrop_exit()
  if (backdrop_get_bootstrap_phase() == BACKDROP_BOOTSTRAP_FULL) {
    if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {
      module_invoke_all('exit', $url);
    }
    backdrop_session_commit();
    if ($sys_config->get('cache')) {
      // We must output something to allow the request to be cached.
      echo ' ';
      if ($cache = backdrop_page_set_cache()) {
        // When caching this redirect for the first time we still need to ensure
        // that the correct cache headers are sent.
        // @see backdrop_page_footer()
        backdrop_serve_page_from_cache($cache);
      }
    }
  }

  exit;
}

/**
 * Clear a page from the page cache.
 */
function redirect_page_cache_clear($redirect = NULL) {
  $config = config('redirect.settings');
  if (!$config->get('page_cache')) {
    return;
  }

  if (isset($redirect)) {
    $path = url($redirect->source, array('absolute' => TRUE));
    // Use a wildcard to catch paths with query strings.
    cache_clear_all($path, 'cache_page', TRUE);
  }
  else {
    // Clear the entire page cache.
    cache_clear_all('*', 'cache_page', TRUE);
  }
}

/**
 * Given a path determine if it is an entity default path.
 *
 * @param $path
 *   The internal path. The id of the entity should be in the string as '[id]'.
 * @return
 *   An array with the entity type and the loaded entity object.
 */
function redirect_load_entity_from_path($path) {
  $entity_paths = &backdrop_static(__FUNCTION__);

  if (!isset($entity_paths)) {
    $entity_paths = array();
    foreach (entity_get_info() as $entity_type => $entity_info) {
      if (isset($entity_info['default path'])) {
        $default_path = $entity_info['default path'];
        $default_path = preg_quote($default_path, '/');
        $default_path = str_replace(preg_quote('%' . $entity_type, '/'), '(\d+)', $default_path);
        $entity_paths[$entity_type] = $default_path;
      }
    }
  }

  foreach ($entity_paths as $entity_type => $default_path) {
    if (preg_match("/^{$default_path}$/", $path, $matches)) {
      if ($entity = entity_load($entity_type, array($matches[1]))) {
        return array('entity_type' => $entity_type, 'entity' => reset($entity));
      }
      break;
    }
  }
}

/**
 * Check the ability to perform redirects with the current request context.
 *
 * This function checks the following conditions:
 * - If the PHP entry point is the root index.php file.
 * - If PHP is not running as CLI.
 * - If the site is not offline or in install/update mode.
 * - If the curerent page is not an admin page (check can be disabled).
 * - If the current request does not have any POST data since a redirect
 *   may interrupt form submission.
 *
 * @return
 *   TRUE if redirections can be performed, or FALSE otherwise.
 */
function redirect_can_redirect() {
  $can_redirect = &backdrop_static(__FUNCTION__);
  $config = config('redirect.settings');
  if (!isset($can_redirect)) {
    $path = current_path();
    $can_redirect = TRUE;

    if ($_SERVER['SCRIPT_NAME'] != $GLOBALS['base_path'] . 'index.php') {
      // Do not redirect if the root script is not /index.php.
      $can_redirect = FALSE;
    }
    elseif (!empty($_POST)) {
      // Do not redirect if this is a post request with data.
      $can_redirect = FALSE;
    }
    elseif (backdrop_is_cli()) {
      // If this is a command line request (Drush, etc), skip processing.
      $can_redirect = FALSE;
    }
    elseif ((state_get('maintenance_mode', 0) || defined('MAINTENANCE_MODE')) && !user_access('access site in maintenance mode')) {
      // Do not redirect in offline or maintenance mode.
      $can_redirect = FALSE;
    }
    elseif (!$config->get('global_admin_paths') && path_is_admin($path)) {
      // Do not redirect on admin paths.
      $can_redirect = FALSE;
    }
  }

  return $can_redirect;
}

/**
 * Compare that all values and associations in one array match another array.
 *
 * We cannot use array_diff_assoc() here because we need to be recursive.
 *
 * @param $match
 *   The array that has the values.
 * @param $haystack
 *   The array that will be searched for values.
 * @return
 *   TRUE if all the elements of $match were found in $haystack, or FALSE
 *   otherwise.
 */
function redirect_compare_array_recursive($match, $haystack) {
  foreach ($match as $key => $value) {
    if (!array_key_exists($key, $haystack)) {
      return FALSE;
    }
    elseif (is_array($value)) {
      if (!is_array($haystack[$key])) {
        return FALSE;
      }
      elseif (!redirect_compare_array_recursive($value, $haystack[$key])) {
        return FALSE;
      }
    }
    elseif ($value != $haystack[$key]) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Load a language object by its language code.
 *
 * @todo Remove when http://drupal.org/node/660736 is fixed in Drupal core.
 *
 * @param $langcode
 *   A language code. If not provided the default language will be returned.
 * @return
 *   A language object.
 */
function redirect_language_load($langcode = LANGUAGE_NONE) {
  $languages = &backdrop_static(__FUNCTION__);

  if (!isset($languages)) {
    $languages = language_list();
    $languages[LANGUAGE_NONE] = NULL;
  }

  return isset($languages[$langcode]) ? $languages[$langcode] : NULL;
}

/**
 * Build the URL of a redirect for display purposes only.
 */
function redirect_url($path, array $options = array(), $clean_url = NULL) {
  if (!isset($clean_url)) {
    $clean_url = config_get('system.core', 'clean_url');
  }

  if ($path == '') {
    $path = '<front>';
  }

  if (!isset($options['alter']) || !empty($options['alter'])) {
    backdrop_alter('redirect_url', $path, $options);
  }

  // The base_url might be rewritten from the language rewrite in domain mode.
  if (!isset($options['base_url'])) {
    if (isset($options['https']) && settings_get('https', FALSE)) {
      if ($options['https'] === TRUE) {
        $options['base_url'] = $GLOBALS['base_secure_url'];
        $options['absolute'] = TRUE;
      }
      elseif ($options['https'] === FALSE) {
        $options['base_url'] = $GLOBALS['base_insecure_url'];
        $options['absolute'] = TRUE;
      }
    }
    else {
      $options['base_url'] = $GLOBALS['base_url'];
    }
  }

  if (empty($options['absolute']) || url_is_external($path)) {
    $url = $path;
  }
  else {
    $url = $options['base_url'] . base_path() . $path;
  }

  if (isset($options['query'])) {
    $url .= $clean_url ? '?' : '&';
    $url .= backdrop_http_build_query($options['query']);
  }
  if (isset($options['fragment'])) {
    $url .= '#' . $options['fragment'];
  }

  return $url;
}

function redirect_variables() {
  return array(
    'redirect_default_status_code' => 301,
    'redirect_auto_redirect' => TRUE,
    'redirect_warning' => FALSE,
    'redirect_passthrough_querystring' => 1,
    'redirect_page_cache' => 0,
    'redirect_purge_inactive' => 0,
    'redirect_global_home' => 1,
    'redirect_global_clean' => 1,
    'redirect_global_canonical' => 1,
    'redirect_global_admin_paths' => 0,
  );
}

//function redirect_get_redirect_info() {
//  $info = &backdrop_static(__FUNCTION__);
//
//  if (!isset($info)) {
//    if ($cache = cache_get('redirect:info')) {
//      $info = $cache->data;
//    }
//    else {
//      $info = module_invoke_all('redirect_info');
//      backdrop_alter('redirect_info', $info);
//      cache_set('redirect:info', $info);
//    }
//  }
//
//  return $info;
//}

function redirect_parse_url($url) {
  $original_url = $url;
  $url = trim($url, " \t\n\r\0\x0B\/");
  $parsed = parse_url($url);

  if (isset($parsed['fragment'])) {
    $url = substr($url, 0, -strlen($parsed['fragment']));
    $url = trim($url, '#');
  }
  if (isset($parsed['query'])) {
    $url = substr($url, 0, -strlen($parsed['query']));
    $url = trim($url, '?&');
    $parsed['query'] = backdrop_get_query_array($parsed['query']);
  }

  // Convert absolute to relative.
  if (isset($parsed['scheme']) && isset($parsed['host'])) {
    $base_secure_url = rtrim($GLOBALS['base_secure_url'] . base_path(), '/');
    $base_insecure_url = rtrim($GLOBALS['base_insecure_url'] . base_path(), '/');
    if (strpos($url, $base_secure_url) === 0) {
      $url = str_replace($base_secure_url, '', $url);
      $parsed['https'] = TRUE;
    }
    elseif (strpos($url, $base_insecure_url) === 0) {
      $url = str_replace($base_insecure_url, '', $url);
    }
  }

  $url = trim($url, '/');

  // Convert to frontpage paths.
  if ($url == '<front>') {
    $url = '';
  }

  //$parsed['url'] = http_build_query($url, HTTP_URL_STRIP_QUERY | HTTP_URL_STRIP_FRAGMENT);
  $parsed['url'] = $url;

  // Allow modules to alter the parsed URL.
  backdrop_alter('redirect_parse_url', $parsed, $original_url);

  return $parsed;
}

function redirect_status_code_options($code = NULL) {
  $codes = array(
    300 => t('300 Multiple Choices'),
    301 => t('301 Moved Permanently'),
    302 => t('302 Found'),
    303 => t('303 See Other'),
    304 => t('304 Not Modified'),
    305 => t('305 Use Proxy'),
    307 => t('307 Temporary Redirect'),
  );
  return isset($codes[$code]) ? $codes[$code] : $codes;
}

/**
 * uasort callback; Compare redirects based on language neutrality and rids.
 */
function _redirect_uasort($a, $b) {
  $a_weight = isset($a->weight) ? $a->weight : 0;
  $b_weight = isset($b->weight) ? $b->weight : 0;
  if ($a_weight != $b_weight) {
    // First sort by weight (case sensitivity).
    return $a_weight > $b_weight;
  }
  elseif ($a->langcode != $b->langcode) {
    // Then sort by language specific over language neutral.
    return $a->langcode == LANGUAGE_NONE;
  }
  elseif (!empty($a->source_options['query']) != !empty($b->source_options['query'])) {
    // Then sort by redirects that do not have query strings over ones that do.
    return empty($a->source_options['query']);
  }
  else {
    // Lastly sort by the highest redirect ID.
    return $a->rid < $b->rid;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() on behalf of locale.module.
 */
function locale_form_redirect_edit_form_alter(&$form, &$form_state) {
  $language_options = array(
    LANGUAGE_NONE => t('All languages'),
  );
  $languages = language_list();
  foreach ($languages as $langcode => $language) {
    $language_options[$langcode] = $language->name;
  }

  $form['langcode'] = array(
    '#type' => 'select',
    '#title' => t('Language'),
    '#options' => $language_options,
    '#default_value' => isset($form['langcode']['#value']) ? $form['langcode']['#value'] : LANGUAGE_NONE,
    '#description' => t('A redirect set for a specific language will always be used when requesting this page in that language, and takes precedence over redirects set for <em>All languages</em>.'),
  );
}

/**
 * Implements hook_field_attach_form().
 *
 * @todo Investigate using hook_entity_load() to load all entity redirects.
 * @todo Figure out how to support entity URIs that contain query strings.
 */
function path_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  list($id) = entity_extract_ids($entity_type, $entity);
  if (!empty($form['redirect']) || empty($id)) {
    return;
  }

  /**
   * todo: fix redirect_entity_type_supports_redirects function
   * todo: to correctly detect if entity type supports redirects
   */
  // Check if this entity type supports redirects.
  /*if (!redirect_entity_type_supports_redirects($entity_type)) {
    return;
  }*/

  $uri = entity_uri($entity_type, $entity);
  if (empty($uri['path'])) {
    // If the entity has no source path, then we cannot lookup the existing
    // redirects.
    return;
  }

  $info = entity_get_info($entity_type);
  $form['redirect'] = array(
    '#type' => 'fieldset',
    '#title' => t('URL redirects'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#access' => user_access('administer redirects'),
    '#weight' => 30,
    '#attributes' => array('class' => array('redirect-list')),
  );

  // Only support vertical tabs if there is a vertical tab element.
  foreach (element_children($form) as $key) {
    $my_type = &backdrop_static(__FUNCTION__);
    if (isset($form[$key]['#type']) && $form[$key]['#type'] == 'vertical_tabs') {
      $form['redirect']['#group'] = $key;
      $form['redirect']['#attached']['js']['vertical-tabs'] = backdrop_get_path('module', 'redirect') . '/redirect.js';
    }
  }

  $redirect = array(
    'redirect' => $uri['path'],
    'redirect_options' => array_diff_key($uri['options'], array('entity_type' => '', 'entity' => '')),
    'langcode' => $langcode,
  );

  $form['redirect']['actions'] = array(
    '#theme' => 'links',
    '#links' => array(),
    '#attributes' => array('class' => array('action-links')),
  );
  if (redirect_access('create', 'redirect')) {
    $form['redirect']['actions']['#links']['add'] = array(
      'title' => t('Add URL redirect to this @entitytype', array('@entitytype' => backdrop_strtolower($info['label']))),
      'href' => 'admin/config/search/redirect/add',
      'query' => array_filter($redirect) + backdrop_get_destination(),
    );
  }

  // We don't have to put our include in $form_state['build_info']['files']
  // since the build array will already be cached.
  module_load_include('inc', 'redirect', 'redirect.admin');
  $redirects = redirect_load_multiple(FALSE, array('redirect' => $uri['path']));
  $header = array('source', 'status_code', 'language', 'count', 'access', 'operations');
  $form['redirect'] += redirect_list_table($redirects, $header);
}

/**
 * Implements hook_field_extra_fields().
 */
function redirect_field_extra_fields() {
  $info = array();
  $entity_info = entity_get_info();
  foreach (array_keys($entity_info) as $entity_type) {
    /*if (!redirect_entity_type_supports_redirects($entity_type)) {
      // Redirect is explicitly disabled for this entity type.
      continue;
    }*/
    foreach (array_keys($entity_info[$entity_type]['bundles']) as $bundle) {
      /*if (!isset($entity_info[$entity_type]['bundles'][$bundle]['uri callback']) && !isset($entity_info[$entity_type]['uri callback'])) {
        // The bundle or base entity must have an URI callback defined otherwise
        // we cannot use the entity_uri() function to lookup the entity's source
        // path.
        continue;
      }*/
      $info[$entity_type][$bundle]['form']['redirect'] = array(
        'label' => t('URL redirects'),
        'description' => t('Redirect module form elements'),
        'weight' => 30,
      );
    }
  }
  return $info;
}

/**
 * Fetch an array of redirect bulk operations.
 *
 * @see hook_redirect_operations()
 * @see hook_redirect_operations_alter()
 */
function redirect_get_redirect_operations() {
  $operations = &backdrop_static(__FUNCTION__);

  if (!isset($operations)) {
    $operations = module_invoke_all('redirect_operations');
    backdrop_alter('redirect_operations', $operations);
  }

  return $operations;
}

/**
 * Implements hook_redirect_operations().
 */
function redirect_redirect_operations() {
  $operations['delete'] = array(
    'action' => t('Delete'),
    'action_past' => t('Deleted'),
    'callback' => 'redirect_delete_multiple',
    'confirm' => TRUE,
  );
  return $operations;
}

/**
 * Implements hook_entity_delete().
 */
function path_entity_delete(Entity $entity) {
  path_delete_all_by_entity($entity);
  if (redirect_entity_type_supports_redirects($entity->type)) {
    redirect_delete_by_entity_path($entity->type, $entity);
  }
}

/**
 * Implements hook_field_attach_rename_bundle().
 *
 * Respond to machine name changes for pattern variables.
 */
function path_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {
  $config = config('path.settings');
  $path_config_data = $config->get();
  foreach ($path_config_data as $config_key => $config_value) {
    if (strpos($config_key, "{$entity_type}_{$bundle_old}_") === 0) {
      $config->clear($config_key);
      $config_key = str_replace("{$entity_type}_{$bundle_old}", "{$entity_type}_{$bundle_new}", $config_key);
      $config->set($config_key, $config_value);
    }
  }
  $config->save();
}

/**
 * Implements hook_field_attach_delete_bundle().
 *
 * Respond to sub-types being deleted, their patterns can be removed.
 */
function path_field_attach_delete_bundle($entity_type, $bundle) {
  $config = config('path.settings');
  $path_config_data = $config->get();
  foreach ($path_config_data as $config_key => $config_value) {
    if (strpos($config_key, "{$entity_type}_{$bundle}_") === 0) {
      $config->clear($config_key);
    }
  }
  $config->save();
}

/**
 * Implements hook_config_info().
 */
function path_config_info() {
  $prefixes['path.settings'] = array(
    'label' => t('Path settings'),
    'group' => t('Configuration'),
  );
  $prefixex['redirect.settings'] = array(
    'label' => t('Redirect settings'),
    'group' => t('Configuration'),
  );
  return $prefixes;
}

/**
 * Get all path information from modules implementing hook_path_info().
 */
function path_get_info() {
  $all_info = backdrop_static(__FUNCTION__);

  if (!isset($info)) {
    module_load_include('inc', 'path', 'path.path');
    $modules = module_implements('path_info');
    foreach ($modules as $module) {
      $callback = $module . '_path_info';
      $module_path_info = $callback();
      foreach ($module_path_info as $path_type => $path_info) {
        $path_info += array(
          'module' => $module,
          'batch file path' => backdrop_get_path('module', $module),
        );
        $all_info[$path_type] = $path_info;
      }
    }
    backdrop_alter('path_info', $all_info);
  }

  return $all_info;
}

/**
 * Load an URL alias pattern by entity, bundle, and language.
 *
 * @param string $entity_type
 *   An entity type (e.g. node, taxonomy, user, etc.)
 * @param string $bundle
 *   A bundle (e.g. content type, vocabulary ID, etc.)
 * @param string $langcode
 *   A language code, defaults to the LANGUAGE_NONE constant.
 */
function path_get_pattern_by_entity_type($entity_type, $bundle = '', $langcode = LANGUAGE_NONE) {
  $config = config('path.settings');
  $patterns = &backdrop_static(__FUNCTION__, array());

  $pattern_id = "$entity_type:$bundle:$langcode";

  if (!isset($patterns[$pattern_id])) {
    $variables = array();
    if ($langcode != LANGUAGE_NONE) {
      $variables[] = "{$entity_type}_{$bundle}_{$langcode}_pattern";
    }
    if ($bundle) {
      $variables[] = "{$entity_type}_{$bundle}_pattern";
    }
    $variables[] = "{$entity_type}_pattern";

    foreach ($variables as $variable) {
      if ($pattern = trim($config->get($variable))) {
        break;
      }
    }

    $patterns[$pattern_id] = $pattern;
  }

  return $patterns[$pattern_id];
}

/**
 * Populate the canonical path property for an entity.
 *
 * @param Entity $entity
 *   An entity (node/user/term/etc.) object for which the path should be loaded.
 */
function path_load_by_entity(Entity $entity) {
  $uri = $entity->uri();
  $langcode = isset($entity->langcode) ? $entity->langcode : LANGUAGE_NONE;
  $conditions = array(
    'source' => $uri['path'],
    'langcode' => $langcode,
  );
  $path = path_load($conditions);
  if ($path === FALSE) {
    // If no path is found, this is an unaliased entity that may specifically
    // have had its alias removed, so "auto" defaults to FALSE.
    $path = array(
      'pid' => NULL,
      'source' => $uri['path'],
      'alias' => NULL,
      'langcode' => $langcode,
      'auto' => FALSE,
    );
  }
  return $path;
}

/**
 * Populate the path properties for multiple entities.
 *
 * @param array $entities
 *   An array of entities (nodes/users/terms/etc.) keyed by the entity ID, for
 *   which each path should be loaded.
 */
function path_load_multiple_by_entities(array $entities) {
  $sources = array();
  $map = array();

  // Each entity may have a different language, so group them by langcode.
  foreach ($entities as $entity) {
    $uri = $entity->uri();
    $langcode = isset($entity->langcode) ? $entity->langcode : LANGUAGE_NONE;
    $sources[$langcode][] = $uri['path'];
    $map[$langcode][$uri['path']] = $entity->id();

    // Provide a default path in the event no path is found.
    $entity->path = array(
      'pid' => NULL,
      'source' => $uri['path'],
      'alias' => NULL,
      'langcode' => $langcode,
      'auto' => FALSE,
    );
  }

  // Load each set of paths by langcode, and update each entity's path property.
  foreach ($sources as $langcode => $entity_ids) {
    $paths = path_load_multiple($entity_ids, 'source', $langcode);
    foreach ($paths as $source => $path) {
      $entity_id = $map[$langcode][$source];
      $entities[$entity_id]->path = $path;
    }
  }
}

/**
 * Delete multiple URL aliases.
 *
 * Intent of this is to abstract a potential path_delete_multiple() function
 * for Backdrop.
 *
 * @param $pids
 *   An array of path IDs to delete.
 */
function path_delete_multiple($pids) {
  foreach ($pids as $pid) {
    path_delete(array('pid' => $pid));
  }
}

/**
 * Delete an URL alias and any of its sub-paths.
 *
 * Given a source like 'node/1' this function will delete any alias that have
 * that specific source or any sources that match 'node/1/%'.
 *
 * @param $source
 *   An string with a source URL path.
 */
function path_delete_all_by_source($source) {
  $sql = "SELECT pid FROM {url_alias} WHERE source = :source OR source LIKE :source_wildcard";
  $pids = db_query($sql, array(':source' => $source, ':source_wildcard' => $source . '/%'))->fetchCol();
  if ($pids) {
    path_delete_multiple($pids);
  }
}

/**
 * Delete an entity URL alias and any of its sub-paths.
 *
 * This function also checks to see if the default entity URI is different from
 * the current entity URI and will delete any of the default aliases.
 *
 * @param Entity $entity
 *   An entity object.
 * @param $default_uri
 *   The optional default uri path for the entity.
 */
function path_delete_all_by_entity(Entity $entity, $default_uri = NULL) {
  $uri = $entity->uri();
  path_delete_all_by_source($uri['path']);
  if (isset($default_uri) && $uri['path'] != $default_uri) {
    path_delete_all_by_source($default_uri);
  }
}

/**
 * Return a portion of a form for setting an alias on an entity.
 */
function path_form_element(Entity $entity) {
  $langcode = isset($entity->langcode) ? $entity->langcode : LANGUAGE_NONE;
  $entity_type = $entity->entityType();
  $bundle = $entity->bundle();

  $path = array();
  if (!$entity->isNew()) {
    $uri = $entity->uri();
    $conditions = array(
      'source' => $uri['path'],
      'langcode' => $langcode,
    );
    $path = path_load($conditions);
    if ($path === FALSE) {
      $path = array(
        'source' => $uri['path'],
        'langcode' => $langcode,
      );
    }
  }
  $path += array(
    'pid' => NULL,
    'source' => NULL,
    'alias' => '',
    'langcode' => $langcode,
    'auto' => NULL,
  );

  $fieldset = array(
    '#type' => 'fieldset',
    '#title' => t('URL settings'),
    '#collapsible' => TRUE,
    '#collapsed' => empty($path['alias']),
    '#group' => 'additional_settings',
    '#attributes' => array(
      'class' => array('path-form'),
    ),
    '#attached' => array(
      'js' => array(backdrop_get_path('module', 'path') . '/js/path.js'),
    ),
    '#access' => user_access('create url aliases') || user_access('administer url aliases'),
    '#weight' => 30,
    '#tree' => TRUE,
    '#element_validate' => array('path_form_element_validate'),
  );

  $pattern = path_get_pattern_by_entity_type($entity_type, $bundle, $langcode);
  if ($pattern) {
    if (!isset($entity->path['auto'])) {
      if (!$entity->isNew()) {
        module_load_include('inc', 'path');
        $uri = $entity->uri();
        $automatic_alias = path_generate_entity_alias($entity, $uri['path'], $langcode);
        if ($automatic_alias !== FALSE) {
          $existing_alias = backdrop_get_path_alias($uri['path'], $langcode);
          $entity->path['auto'] = ($existing_alias != $uri['path'] && $existing_alias == $automatic_alias);
        }
      }
      else {
        $entity->path['auto'] = TRUE;
      }
    }

    $fieldset['auto'] = array(
      '#type' => 'checkbox',
      '#title' => t('Generate automatic URL alias'),
      '#default_value' => $entity->path['auto'],
      '#description' => t('Uncheck this to create a custom alias below.'),
      '#weight' => -1,
      '#attributes' => array('class' => array('automatic-alias')),
    );

    // Add a shortcut link to configure URL alias patterns.
    if (backdrop_valid_path('admin/config/search/path/patterns')) {
      $fieldset['auto']['#description'] .= ' ' . l(t('Configure URL alias patterns.'), 'admin/config/search/path/patterns');
    }
  }

  $fieldset['alias'] = array(
    '#type' => 'textfield',
    '#title' => t('URL alias'),
    '#default_value' => $path['alias'],
    '#maxlength' => 255,
  );

  if (isset($fieldset['auto'])) {
    $fieldset['alias']['#states'] = array(
      'disabled' => array(
        'input.automatic-alias' => array('checked' => TRUE),
      ),
    );
  }

  $fieldset['pid'] = array(
    '#type' => 'value',
    '#value' => $path['pid'],
  );
  $fieldset['source'] = array(
    '#type' => 'value',
    '#value' => $path['source'],
  );
  $fieldset['langcode'] = array(
    '#type' => 'value',
    '#value' => $path['langcode'],
  );

  // Provide an element to remember the current alias if a new one is created.
  if (!empty($entity->path['alias'])) {
    $fieldset['old_alias'] = array(
      '#type' => 'value',
      '#value' => $entity->path['alias'],
    );
  }

  return $fieldset;
}

/**
 * Form element validation handler for URL alias form element.
 *
 * @see path_form_element()
 */
function path_form_element_validate($element, &$form_state, $complete_form) {
  if (!empty($form_state['values']['path']['alias'])) {
    // Trim the submitted value.
    $alias = trim($form_state['values']['path']['alias']);
    form_set_value($element['alias'], $alias, $form_state);
    // Node language needs special care. Since the language of the URL alias
    // depends on the node language, and the node language can be switched
    // right within the same form, we need to conditionally overload the
    // originally assigned URL alias language.
    if (isset($form_state['values']['langcode'])) {
      form_set_value($element['langcode'], $form_state['values']['langcode'], $form_state);
    }

    $path = $form_state['values']['path'];

    // Ensure that the submitted alias does not exist yet.
    $query = db_select('url_alias')
      ->condition('alias', $path['alias'])
      ->condition('langcode', $path['langcode']);
    if (!empty($path['source'])) {
      $query->condition('source', $path['source'], '<>');
    }
    $query->addExpression('1');
    $query->range(0, 1);
    if ($query->execute()->fetchField()) {
      form_error($element, t('The alias is already in use.'));
    }
  }
}

/**
 * Determine if a possible URL alias would conflict with any existing paths.
 *
 * Returning TRUE from this function will trigger path_alias_uniquify() to
 * generate a similar URL alias with a suffix to avoid conflicts.
 *
 * @param string $alias
 *   The potential URL alias.
 * @param string $source
 *   The source path for the alias (e.g. 'node/1').
 * @param string $langcode
 *   The language code for the alias (e.g. 'en').
 *
 * @return bool
 *   TRUE if $alias conflicts with an existing, reserved path, or FALSE if
 *   it does not match any reserved paths.
 */
function path_is_alias_reserved($alias, $source, $langcode = LANGUAGE_NONE) {
  $is_existing_alias = (bool) db_query_range("SELECT pid FROM {url_alias} WHERE source <> :source AND alias = :alias AND langcode IN (:language, :language_none) ORDER BY langcode DESC, pid DESC", 0, 1, array(
    ':source' => $source,
    ':alias' => $alias,
    ':language' => $langcode,
    ':language_none' => LANGUAGE_NONE,
  ))->fetchField();

  if ($is_existing_alias) {
    return TRUE;
  }

  module_load_include('inc', 'path');
  if (_path_is_callback($alias)) {
    return TRUE;
  }

  foreach (module_implements('path_is_alias_reserved') as $module) {
    $result = module_invoke($module, 'path_is_alias_reserved', $alias, $source, $langcode);
    if (!empty($result)) {
      // As soon as the first module says that an alias is in fact reserved,
      // then there is no point in checking the rest of the modules.
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Output a helpful message if verbose output is enabled.
 *
 * Verbose message output is only enabled when:
 *
 * - The Path 'verbose' setting is enabled.
 * - The current user has the 'notify of path changes' permission.
 * - It has not been specifically disabled by setting $messages_enabled to
 *   FALSE (as before a bulk operation).
 *
 * @param string $message
 *   An optional string of the verbose message to display. This string should
 *   already be run through t().
 * @param bool $messages_enabled
 *   Disable all messages temporarily for this request by setting to FALSE, or
 *   re-enable messages by setting to TRUE.
 * @return
 *   TRUE if verbose output is enabled, or FALSE otherwise.
 */
function path_verbose_message($message = NULL, $messages_enabled = NULL) {
  static $verbose;

  if (isset($messages_enabled) && $messages_enabled === FALSE) {
    $verbose = FALSE;
  }

  if (!isset($verbose) || $messages_enabled === TRUE) {
    $verbose = config_get('path.settings', 'verbose') && user_access('notify of path changes');
  }

  if (!$verbose || (isset($op) && in_array($op, array('bulkupdate', 'return')))) {
    return FALSE;
  }

  if ($message) {
    backdrop_set_message($message);
  }

  return $verbose;
}

/**
 * Temporarily disable verbose output of messages by Path module.
 *
 * This only affects the current request.
 */
function path_verbose_suspend() {
  path_verbose_message(NULL, FALSE);
}

/**
 * Re-enable verbose output of messages by Path module.
 *
 * This does not guarantee messages will be output. If the verbose config option
 * in path.settings.json is disable or the user does not have the
 * "notify of path changes" permission, messages still will not be shown. This
 * function only re-enables the possibility of displaying messages after it
 * has been disabled by path_verbose_disable().
 */
function path_verbose_resume() {
  path_verbose_message(NULL, FALSE);
}

/**
 * Implements hook_autoload_info().
 */
function path_autoload_info() {
  return array(
    'Redirect' => 'redirect.entity.inc',
    'RedirectController' => 'redirect.entity.inc',
  );
}
