<?php
/**
 * @file
 * Tests for system.module.
 */

// Include class WatchdogTestCase from Simpletest.
require_once BACKDROP_ROOT . '/core/modules/simpletest/tests/bootstrap.test';

/**
 * Helper class for module test cases.
 */
class ModuleTestCase extends WatchdogTestCase {
  protected $admin_user;
  protected $profile = 'testing';

  function setUp() {
    parent::setUp('system_test');

    $this->admin_user = $this->backdropCreateUser(array('access administration pages', 'administer modules'));
    $this->backdropLogin($this->admin_user);
  }

  /**
   * Assert there are tables that begin with the specified base table name.
   *
   * @param $base_table
   *   Beginning of table name to look for.
   * @param $count
   *   (optional) Whether or not to assert that there are tables that match the
   *   specified base table. Defaults to TRUE.
   */
  function assertTableCount($base_table, $count = TRUE) {
    $tables = db_find_tables(Database::getConnection()->prefixTables('{' . $base_table . '}') . '%');

    if ($count) {
      return $this->assertTrue($tables, format_string('Tables matching "@base_table" found.', array('@base_table' => $base_table)));
    }
    return $this->assertFalse($tables, format_string('Tables matching "@base_table" not found.', array('@base_table' => $base_table)));
  }

  /**
   * Assert that all tables defined in a module's hook_schema() exist.
   *
   * @param $module
   *   The name of the module.
   */
  function assertModuleTablesExist($module) {
    $tables = array_keys(backdrop_get_schema_unprocessed($module));
    $tables_exist = TRUE;
    foreach ($tables as $table) {
      if (!db_table_exists($table)) {
        $tables_exist = FALSE;
      }
    }
    return $this->assertTrue($tables_exist, format_string('All database tables defined by the @module module exist.', array('@module' => $module)));
  }

  /**
   * Assert that none of the tables defined in a module's hook_schema() exist.
   *
   * @param $module
   *   The name of the module.
   */
  function assertModuleTablesDoNotExist($module) {
    $tables = array_keys(backdrop_get_schema_unprocessed($module));
    $tables_exist = FALSE;
    foreach ($tables as $table) {
      if (db_table_exists($table)) {
        $tables_exist = TRUE;
      }
    }
    return $this->assertFalse($tables_exist, format_string('None of the database tables defined by the @module module exist.', array('@module' => $module)));
  }

  /**
   * Assert the list of modules are enabled or disabled.
   *
   * @param $modules
   *   Module list to check.
   * @param $enabled
   *   Expected module state.
   */
  function assertModules(array $modules, $enabled) {
    module_list(TRUE);
    foreach ($modules as $module) {
      if ($enabled) {
        $message = 'Module "@module" is enabled.';
      }
      else {
        $message = 'Module "@module" is not enabled.';
      }
      $this->assertEqual(module_exists($module), $enabled, format_string($message, array('@module' => $module)));
    }
  }
}

/**
 * Test module enabling/disabling functionality.
 */
class EnableDisableTestCase extends ModuleTestCase {
  protected $profile = 'testing';

  /**
   * Test that all core modules can be enabled, disabled and uninstalled.
   */
  function testEnableDisable() {
    // Try to enable, disable and uninstall all core modules, unless they are
    // hidden or required, or testing-only modules.
    $modules = system_rebuild_module_data();
    foreach ($modules as $name => $module) {
      if ($module->info['package'] == 'Testing' || !empty($module->info['hidden']) || !empty($module->info['required'])) {
        unset($modules[$name]);
      }
    }
    $this->assertTrue(count($modules), format_string('Found @count core modules that we can try to enable in this test.', array('@count' => count($modules))));

    // Enable the dblog module first, since we will be asserting the presence
    // of log messages throughout the test.
    if (isset($modules['dblog'])) {
      $modules = array('dblog' => $modules['dblog']) + $modules;
    }

    // Set a variable so that the hook implementations in system_test.module
    // will display messages via backdrop_set_message().
    state_set('test_verbose_module_hooks', TRUE);

    // Throughout this test, some modules may be automatically enabled (due to
    // dependencies). We'll keep track of them in an array, so we can handle
    // them separately.
    $automatically_enabled = array();

    // Go through each module in the list and try to enable it (unless it was
    // already enabled automatically due to a dependency).
    foreach ($modules as $name => $module) {
      if (empty($automatically_enabled[$name])) {
        // Start a list of modules that we expect to be enabled this time.
        $modules_to_enable = array($name);

        // Find out if the module has any dependencies that aren't enabled yet;
        // if so, add them to the list of modules we expect to be automatically
        // enabled.
        foreach (array_keys($module->requires) as $dependency) {
          if (isset($modules[$dependency]) && empty($automatically_enabled[$dependency])) {
            $modules_to_enable[] = $dependency;
            $automatically_enabled[$dependency] = TRUE;
          }
        }

        // Check that each module is not yet enabled and does not have any
        // database tables yet.
        foreach ($modules_to_enable as $module_to_enable) {
          $this->assertModules(array($module_to_enable), FALSE);
          $this->assertModuleTablesDoNotExist($module_to_enable);
        }

        // Install and enable the module.
        $edit = array();
        $edit['modules[' . $module->info['package'] . '][' . $name . '][enable]'] = $name;
        $this->backdropPost('admin/modules', $edit, t('Save configuration'));
        // Handle the case where modules were installed along with this one and
        // where we therefore hit a confirmation screen.
        if (count($modules_to_enable) > 1) {
          $this->backdropPost(NULL, array(), t('Continue'));
        }
        $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');

        // Check that hook_modules_installed() and hook_modules_enabled() were
        // invoked with the expected list of modules, that each module's
        // database tables now exist, and that appropriate messages appear in
        // the logs.
        foreach ($modules_to_enable as $module_to_enable) {
          $this->assertText(t('hook_modules_installed fired for @module', array('@module' => $module_to_enable)));
          $this->assertText(t('hook_modules_enabled fired for @module', array('@module' => $module_to_enable)));
          $this->assertModules(array($module_to_enable), TRUE);
          $this->assertModuleTablesExist($module_to_enable);
          $this->assertLogMessage('system', "%module module installed.", array('%module' => $module_to_enable), WATCHDOG_INFO);
          $this->assertLogMessage('system', "%module module enabled.", array('%module' => $module_to_enable), WATCHDOG_INFO);
        }

        // Disable and uninstall the original module, and check appropriate
        // hooks, tables, and log messages. (Later, we'll go back and do the
        // same thing for modules that were enabled automatically.) Skip this
        // for the dblog module, because that is needed for the test; we'll go
        // back and do that one at the end also.
        if ($name != 'dblog') {
          $this->assertSuccessfulDisableAndUninstall($module);
        }
      }
    }

    // Go through all modules that were automatically enabled, and try to
    // disable and uninstall them one by one.
    while (!empty($automatically_enabled)) {
      $initial_count = count($automatically_enabled);
      foreach (array_keys($automatically_enabled) as $name) {
        // If the module can't be disabled due to dependencies, skip it and try
        // again the next time. Otherwise, try to disable it.
        $this->backdropGet('admin/modules');
        $disabled_checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="modules[' . $modules[$name]->info['package'] . '][' . $name . '][enable]"]');
        if (empty($disabled_checkbox) && $name != 'dblog') {
          unset($automatically_enabled[$name]);
          $this->assertSuccessfulDisableAndUninstall($modules[$name]);
        }
      }
      $final_count = count($automatically_enabled);
      // If all checkboxes were disabled, something is really wrong with the
      // test. Throw a failure and avoid an infinite loop.
      if ($initial_count == $final_count) {
        $this->fail(t('Remaining modules could not be disabled.'));
        break;
      }
    }

    // Disable and uninstall the dblog module last, since we needed it for
    // assertions in all the above tests.
    if (isset($modules['dblog'])) {
      $this->assertSuccessfulDisableAndUninstall($modules['dblog']);
    }

    // Now that all modules have been tested, go back and try to enable them
    // all again at once. This tests two things:
    // - That each module can be successfully enabled again after being
    //   uninstalled.
    // - That enabling more than one module at the same time does not lead to
    //   any errors.
    $edit = array();
    foreach (array_keys($modules) as $name) {
      $edit['modules[' . $modules[$name]->info['package'] . '][' . $name . '][enable]'] = $name;
    }
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
  }

  /**
   * Disables and uninstalls a module and asserts that it was done correctly.
   *
   * @param $module
   *   The complete object representing the module to disable and uninstall, as
   *   retrieved with system_rebuild_module_data().
   */
  function assertSuccessfulDisableAndUninstall($module) {
    // Disable the module.
    $edit = array();
    $edit['modules[' . $module->info['package'] . '][' . $module->name . '][enable]'] = FALSE;
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');
    $this->assertModules(array($module->name), FALSE);

    // Check that the appropriate hook was fired and the appropriate log
    // message appears.
    $this->assertText(t('hook_modules_disabled fired for @module', array('@module' => $module->name)));
    $this->assertLogMessage('system', "%module module disabled.", array('%module' => $module->name), WATCHDOG_INFO);

    //  Check that the module's database tables still exist.
    $this->assertModuleTablesExist($module->name);

    // Uninstall the module.
    $edit = array();
    $edit['uninstall[' . $module->name . ']'] = $module->name;
    $this->backdropPost('admin/modules/uninstall', $edit, t('Uninstall'));
    $this->backdropPost(NULL, NULL, t('Uninstall'));
    $this->assertText(t('The selected modules have been uninstalled.'), 'Modules status has been updated.');
    $this->assertModules(array($module->name), FALSE);

    // Check that the appropriate hook was fired and the appropriate log
    // message appears. (But don't check for the log message if the dblog
    // module was just uninstalled, since the {watchdog} table won't be there
    // anymore.)
    $this->assertText(t('hook_modules_uninstalled fired for @module', array('@module' => $module->name)));
    if ($module->name != 'dblog') {
      $this->assertLogMessage('system', "%module module uninstalled.", array('%module' => $module->name), WATCHDOG_INFO);
    }

    // Check that the module's database tables no longer exist.
    $this->assertModuleTablesDoNotExist($module->name);
  }
}

/**
 * Tests failure of hook_requirements('install').
 */
class HookRequirementsTestCase extends ModuleTestCase {
  /**
   * Assert that a module cannot be installed if it fails hook_requirements().
   */
  function testHookRequirementsFailure() {
    $this->assertModules(array('requirements1_test'), FALSE);

    // Attempt to install the requirements1_test module.
    $edit = array();
    $edit['modules[Testing][requirements1_test][enable]'] = 'requirements1_test';
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));

    // Makes sure the module was NOT installed.
    $this->assertText(t('Requirements 1 Test failed requirements'), 'Modules status has been updated.');
    $this->assertModules(array('requirements1_test'), FALSE);
  }
}

/**
 * Test module dependency functionality.
 */
class ModuleDependencyTestCase extends ModuleTestCase {
  /**
   * Checks functionality of project namespaces for dependencies.
   */
  function testProjectNamespaceForDependencies() {
    // Enable module with project namespace to ensure nothing breaks.
    $edit = array(
      'modules[Testing][system_project_namespace_test][enable]' => TRUE,
    );
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertModules(array('system_project_namespace_test'), TRUE);
  }

  /**
   * Attempt to enable translation module without locale enabled.
   */
  function testEnableWithoutDependency() {
    // Attempt to enable content translation without locale enabled.
    $edit = array();
    $edit['modules[Translation][translation][enable]'] = 'translation';
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertText(t('Some required modules must be enabled'), 'Dependency required.');

    $this->assertModules(array('translation', 'locale', 'language'), FALSE);

    // Assert that the locale tables weren't enabled.
    $this->assertTableCount('language', FALSE);
    $this->assertTableCount('locale', FALSE);

    $this->backdropPost(NULL, NULL, t('Continue'));
    $this->assertText(t('The configuration options have been saved.'), 'Modules status has been updated.');

    $this->assertModules(array('translation', 'locale'), TRUE);

    // Assert that the locale tables were enabled.
    $this->assertTableCount('language', TRUE);
    $this->assertTableCount('locale', TRUE);
  }

  /**
   * Attempt to enable a module with a missing dependency.
   */
  function testMissingModules() {
    // Test that the system_dependencies_test module is marked
    // as missing a dependency.
    $this->backdropGet('admin/modules');
    $this->assertRaw(t('@module (<span class="admin-missing">missing</span>)', array('@module' => backdrop_ucfirst('_missing_dependency'))), 'A module with missing dependencies is marked as such.');
    $checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="modules[Testing][system_dependencies_test][enable]"]');
    $this->assert(count($checkbox) == 1, 'Checkbox for the module is disabled.');

    // Force enable the system_dependencies_test module.
    module_enable(array('system_dependencies_test'), FALSE);

    // Verify that the module is forced to be disabled when submitting
    // the module page.
    $this->backdropPost('admin/modules', array(), t('Save configuration'));
    $this->assertText(t('The @module module is missing, so the following module will be disabled: @depends.', array('@module' => '_missing_dependency', '@depends' => 'system_dependencies_test')), 'The module missing dependencies will be disabled.');

    // Confirm.
    $this->backdropPost(NULL, NULL, t('Continue'));

    // Verify that the module has been disabled.
    $this->assertModules(array('system_dependencies_test'), FALSE);
  }

  /**
   * Tests enabling a module that depends on an incompatible version of a module.
   */
  function testIncompatibleModuleVersionDependency() {
    // Test that the system_incompatible_module_version_dependencies_test is
    // marked as having an incompatible dependency.
    $this->backdropGet('admin/modules');
    $this->assertRaw(t('@module (<span class="admin-missing">incompatible with</span> version @version)', array(
      '@module' => 'System incompatible module version test (>2.0)',
      '@version' => '1.0',
    )), 'A module that depends on an incompatible version of a module is marked as such.');
    $checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="modules[Testing][system_incompatible_module_version_dependencies_test][enable]"]');
    $this->assert(count($checkbox) == 1, 'Checkbox for the module is disabled.');
  }

  /**
   * Tests enabling a module that depends on a module with an incompatible core version.
   */
  function testIncompatibleCoreVersionDependency() {
    // Test that the system_incompatible_core_version_dependencies_test is
    // marked as having an incompatible dependency.
    $this->backdropGet('admin/modules');
    $this->assertRaw(t('@module (<span class="admin-missing">incompatible with</span> this version of Backdrop core)', array(
      '@module' => 'System incompatible core version test',
    )), 'A module that depends on a module with an incompatible core version is marked as such.');
    $checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="modules[Testing][system_incompatible_core_version_dependencies_test][enable]"]');
    $this->assert(count($checkbox) == 1, 'Checkbox for the module is disabled.');
  }

  /**
   * Tests enabling a module that depends on a module which fails hook_requirements().
   */
  function testEnableRequirementsFailureDependency() {
    // Enable comment module before testing the dependencies.
    $edit = array();
    $edit['modules[Comments][comment][enable]'] = TRUE;
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));

    $this->assertModules(array('requirements1_test'), FALSE);
    $this->assertModules(array('requirements2_test'), FALSE);

    // Attempt to install both modules at the same time.
    $edit = array();
    $edit['modules[Testing][requirements1_test][enable]'] = 'requirements1_test';
    $edit['modules[Testing][requirements2_test][enable]'] = 'requirements2_test';
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));

    // Makes sure the modules were NOT installed.
    $this->assertText(t('Requirements 1 Test failed requirements'), 'Modules status has been updated.');
    $this->assertModules(array('requirements1_test'), FALSE);
    $this->assertModules(array('requirements2_test'), FALSE);

    // Makes sure that already enabled modules the failing modules depend on
    // were not disabled.
    $this->assertModules(array('comment'), TRUE);

  }

  /**
   * Tests that module dependencies are enabled in the correct order via the
   * UI. Dependencies should be enabled before their dependents.
   */
  function testModuleEnableOrder() {
    module_enable(array('module_test'), FALSE);
    $this->resetAll();
    $this->assertModules(array('module_test'), TRUE);
    state_set('dependency_test', 'dependency');
    // module_test creates a dependency chain: test3 depends on test2, which
    // depends on test1. The correct enable order is, test1, test2, test3.
    $expected_order = array('dependency_test1', 'dependency_test2', 'dependency_test3');

    // Enable the modules through the UI, verifying that the dependency chain
    // is correct.
    $edit = array();
    $edit['modules[Testing][dependency_test3][enable]'] = 'dependency_test3';
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertModules(array('dependency_test3'), FALSE);
    $this->assertText(t('You must enable the Dependency test 2, Dependency test 1 modules to install Dependency test 3.'), 'Dependency chain created.');
    $edit['modules[Testing][dependency_test2][enable]'] = 'dependency_test2';
    $edit['modules[Testing][dependency_test1][enable]'] = 'dependency_test1';
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertModules(array('dependency_test3', 'dependency_test2', 'dependency_test1'), TRUE);

    // Check the actual order which is saved by module_test_modules_enabled().
    $this->assertIdentical(state_get('test_module_enable_order', FALSE), $expected_order, 'Modules enabled in the correct order.');
  }

  /**
   * Tests attempting to uninstall a module that has installed dependents.
   */
  function testUninstallDependents() {
    // Enable both language and locale modules.
    $edit = array('modules[Translation][language][enable]' => 'language');
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertModules(array('language'), TRUE);
    $edit = array('modules[Translation][locale][enable]' => 'locale');
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertModules(array('locale'), TRUE);

    // Disable locale and language. Both should now be installed but disabled.
    $edit = array('modules[Translation][locale][enable]' => FALSE);
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertModules(array('locale'), FALSE);
    $edit = array('modules[Translation][language][enable]' => FALSE);
    $this->backdropPost('admin/modules', $edit, t('Save configuration'));
    $this->assertModules(array('language'), FALSE);

    // Check that the language module cannot be uninstalled.
    $this->backdropGet('admin/modules/uninstall');
    $checkbox = $this->xpath('//input[@type="checkbox" and @disabled="disabled" and @name="uninstall[language]"]');
    $this->assert(count($checkbox) == 1, 'Checkbox for uninstalling the language module is disabled.');

    // Uninstall the locale module, check that language then can be uninstalled.
    $edit = array('uninstall[locale]' => 'locale');
    $this->backdropPost('admin/modules/uninstall', $edit, t('Uninstall'));
    $this->backdropPost(NULL, NULL, t('Uninstall'));
    $this->assertText(t('The selected modules have been uninstalled.'), 'Modules status has been updated.');
    $edit = array('uninstall[language]' => 'language');
    $this->backdropPost('admin/modules/uninstall', $edit, t('Uninstall'));
    $this->backdropPost(NULL, NULL, t('Uninstall'));
    $this->assertText(t('The selected modules have been uninstalled.'), 'Modules status has been updated.');
  }

  /**
   * Tests whether the correct module metadata is returned.
   */
  function testModuleMetaData() {
    // Generate the list of available modules.
    $modules = system_rebuild_module_data();
    // Check that the mtime field exists for the system module.
    $this->assertTrue(!empty($modules['system']->info['mtime']), 'The system.info file modification time field is present.');
    // Use 0 if mtime isn't present, to avoid an array index notice.
    $test_mtime = !empty($modules['system']->info['mtime']) ? $modules['system']->info['mtime'] : 0;
    // Ensure the mtime field contains a number that is greater than zero.
    $this->assertTrue(is_numeric($test_mtime) && ($test_mtime > 0), 'The system.info file modification time field contains a timestamp.');
  }

  /**
   * Tests whether the correct theme metadata is returned.
   */
  function testThemeMetaData() {
    // Generate the list of available themes.
    $themes = system_rebuild_theme_data();
    // Check that the mtime field exists for the bartik theme.
    $this->assertTrue(!empty($themes['bartik']->info['mtime']), 'The bartik.info file modification time field is present.');
    // Use 0 if mtime isn't present, to avoid an array index notice.
    $test_mtime = !empty($themes['bartik']->info['mtime']) ? $themes['bartik']->info['mtime'] : 0;
    // Ensure the mtime field contains a number that is greater than zero.
    $this->assertTrue(is_numeric($test_mtime) && ($test_mtime > 0), 'The bartik.info file modification time field contains a timestamp.');
  }
}

/**
 * Test module dependency on specific versions.
 */
class ModuleVersionTestCase extends ModuleTestCase {
  function setUp() {
    parent::setUp('module_test');
  }

  /**
   * Test version dependencies.
   */
  function testModuleVersions() {
    $dependencies = array(
      // All comparisons are done against 1.x-2.4-beta3.
      'common_test' => TRUE,
      // Branch incompatibility.
      'common_test (1.x)' => FALSE,
      // Branch compatibility.
      'common_test (2.x)' => TRUE,
      // Another branch incompatibility.
      'common_test (>2.x)' => FALSE,
      // Another branch compatibility.
      'common_test (<=2.x)' => TRUE,
      // Another branch incompatibility.
      'common_test (<2.x)' => FALSE,
      // Another branch compatibility.
      'common_test (>=2.x)' => TRUE,
      // Higher rc version. Incompatible.
      'common_test (>=1.x-2.4-rc1)' => FALSE,
      // Higher beta version. Incompatible.
      'common_test (>=1.x-2.4-beta4)' => FALSE,
      // Lower beta version. Compatible.
      'common_test (>=1.x-2.4-beta2)' => TRUE,
      // Lower alpha version. Compatible.
      'common_test (>=1.x-2.4-alpha8)' => TRUE,
      // Nonsense, misses a dash. Incompatible with everything.
      'common_test (=1.x2.x, >=2.4)' => FALSE,
      // Core version is optional. Compatible.
      'common_test (=1.x-2.x, >=2.4-alpha2)' => TRUE,
      // Test !=, explicitly incompatible.
      'common_test (=2.x, !=2.4-beta3)' => FALSE,
      // Three operations. Compatible.
      'common_test (=2.x, !=2.3, <2.5)' => TRUE,
      // Testing extra version. Incompatible.
      'common_test (<=2.4-beta2)' => FALSE,
      // Testing extra version. Compatible.
      'common_test (>2.4-beta2)' => TRUE,
      // Testing extra version. Incompatible.
      'common_test (>2.4-rc0)' => FALSE,
    );
    foreach ($dependencies as $version_string => $compatible) {
      // Each request, one dependency is shifted off the front and added to
      // module_test's dependencies. See system_test_system_info_alter().
      state_set('system_test_dependency', $version_string);
      $this->backdropGet('admin/modules');
      $checkbox = $this->xpath('//input[@id="edit-modules-testing-module-test-enable"]');
      $this->assertEqual(empty($checkbox[0]['disabled']), $compatible, $version_string);
    }

    $dev_dependencies = array(
      // Compare again against a the dev version 1.x-2.x-dev.
      'common_test' => TRUE,
      // Branch incompatibility.
      'common_test (1.x)' => FALSE,
      // Branch compatibility.
      'common_test (2.x)' => TRUE,
      // Another branch incompatibility.
      'common_test (>2.x)' => FALSE,
      // Any alpha version
      'common_test (>=1.x-2.x-alpha4)' => TRUE,
      // Any beta version
      'common_test (>=1.x-2.x-beta4)' => TRUE,
      // Any rc version
      'common_test (>=1.x-2.x-rc4)' => TRUE,
      // Any preview version
      'common_test (>=1.x-2.x-preview)' => TRUE,
      // Complex version string.
      'common_test (>=1.x-2.4-beta2)' => TRUE,
      // Dev versions are later than any minor number.
      'common_test (>=2.4.0)' => TRUE,
      // Next version is not compatible.
      'common_test (>=3.0.0)' => FALSE,
    );

    // Same testing approach as above, only against a different version number.
    foreach ($dev_dependencies as $version_string => $compatible) {
      // Each request, one dependency is shifted off the front and added to
      // module_test's dependencies. See system_test_system_info_alter().
      state_set('system_test_dev_dependency', $version_string);
      $this->backdropGet('admin/modules');

      $checkbox = $this->xpath('//input[@id="edit-modules-testing-module-test-enable"]');
      $this->assertEqual(empty($checkbox[0]['disabled']), $compatible, 'Dev dependency: ' . $version_string);
    }
  }
}

class CronRunTestCase extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    parent::setUp(array('common_test', 'common_test_cron_helper'));
  }

  /**
   * Test cron runs.
   */
  function testCronRun() {
    global $base_url;

    // Run cron anonymously without any cron key.
    $this->backdropGet($base_url . '/core/cron.php', array('external' => TRUE));
    $this->assertResponse(403);

    // Run cron anonymously with a random cron key.
    $key = $this->randomName(16);
    $this->backdropGet($base_url . '/core/cron.php', array('external' => TRUE, 'query' => array('cron_key' => $key)));
    $this->assertResponse(403);

    // Run cron anonymously with the valid cron key.
    $key = state_get('cron_key');
    $this->backdropGet($base_url . '/core/cron.php', array('external' => TRUE, 'query' => array('cron_key' => $key)));
    $this->assertResponse(200);
  }

  /**
   * Ensure that the automatic cron run feature is working.
   *
   * In these tests we do not use REQUEST_TIME to track start time, because we
   * need the exact time when cron is triggered.
   */
  function testAutomaticCron() {
    // Ensure cron does not run when the cron threshold is enabled and was
    // not passed.
    $cron_last = time();
    $cron_safe_threshold = 100;
    state_set('cron_last', $cron_last);
    config('system.core')
      ->set('cron_safe_threshold', $cron_safe_threshold)
      ->save();
    $this->backdropGet('');
    $this->assertTrue($cron_last == state_get('cron_last'), 'Cron does not run when the cron threshold is not passed.');

    // Test if cron runs when the cron threshold was passed.
    $cron_last = time() - 200;
    state_set('cron_last', $cron_last);
    $this->backdropGet('');
    sleep(1);
    $this->assertTrue($cron_last < state_get('cron_last'), 'Cron runs when the cron threshold is passed.');

    // Disable the cron threshold through the interface.
    $admin_user = $this->backdropCreateUser(array('administer site configuration'));
    $this->backdropLogin($admin_user);
    $this->backdropPost('admin/config/system/cron', array('cron_safe_threshold' => 0), t('Save configuration'));
    $this->assertText(t('The configuration options have been saved.'));
    $this->backdropLogout();

    // Test if cron does not run when the cron threshold is disabled.
    $cron_last = time() - 200;
    state_set('cron_last', $cron_last);
    $this->backdropGet('');
    $this->assertTrue($cron_last == state_get('cron_last'), 'Cron does not run when the cron threshold is disabled.');
  }

  /**
   * Ensure that temporary files are removed.
   *
   * Create files for all the possible combinations of age and status. We are
   * using UPDATE statements because using the API would set the timestamp.
   */
  function testTempFileCleanup() {
    // Temporary file that is older than BACKDROP_MAXIMUM_TEMP_FILE_AGE.
    $temp_old = file_save_data('');
    db_update('file_managed')
      ->fields(array(
        'status' => 0,
        'timestamp' => 1,
      ))
      ->condition('fid', $temp_old->fid)
      ->execute();
    $this->assertTrue(file_exists($temp_old->uri), 'Old temp file was created correctly.');

    // Temporary file that is less than BACKDROP_MAXIMUM_TEMP_FILE_AGE.
    $temp_new = file_save_data('');
    db_update('file_managed')
      ->fields(array('status' => 0))
      ->condition('fid', $temp_new->fid)
      ->execute();
    $this->assertTrue(file_exists($temp_new->uri), 'New temp file was created correctly.');

    // Permanent file that is older than BACKDROP_MAXIMUM_TEMP_FILE_AGE.
    $perm_old = file_save_data('');
    db_update('file_managed')
      ->fields(array('timestamp' => 1))
      ->condition('fid', $temp_old->fid)
      ->execute();
    $this->assertTrue(file_exists($perm_old->uri), 'Old permanent file was created correctly.');

    // Permanent file that is newer than BACKDROP_MAXIMUM_TEMP_FILE_AGE.
    $perm_new = file_save_data('');
    $this->assertTrue(file_exists($perm_new->uri), 'New permanent file was created correctly.');

    // Run cron and then ensure that only the old, temp file was deleted.
    $this->cronRun();
    $this->assertFalse(file_exists($temp_old->uri), 'Old temp file was correctly removed.');
    $this->assertTrue(file_exists($temp_new->uri), 'New temp file was correctly ignored.');
    $this->assertTrue(file_exists($perm_old->uri), 'Old permanent file was correctly ignored.');
    $this->assertTrue(file_exists($perm_new->uri), 'New permanent file was correctly ignored.');
  }

  /**
   * Make sure exceptions thrown on hook_cron() don't affect other modules.
   */
  function testCronExceptions() {
    state_del('common_test_cron');
    // The common_test module throws an exception. If it isn't caught, the tests
    // won't finish successfully.
    // The common_test_cron_helper module sets the 'common_test_cron' variable.
    $this->cronRun();
    $result = state_get('common_test_cron');
    $this->assertEqual($result, 'success', 'Cron correctly handles exceptions thrown during hook_cron() invocations.');
  }

  /**
   * Tests that hook_flush_caches() is not invoked on every single cron run.
   *
   * @see system_cron()
   */
  public function testCronCacheExpiration() {
    module_enable(array('system_cron_test'));
    state_del('system_cron_test_flush_caches');
    cache()->flush();

    // Invoke cron the first time: hook_flush_caches() should be called and then
    // get cached.
    backdrop_cron_run();
    $this->assertEqual(state_get('system_cron_test_flush_caches'), 1, 'hook_flush_caches() was invoked the first time.');
    $cache = cache_get('system_cache_tables');
    $this->assertEqual(empty($cache), FALSE, 'Cache is filled with cache table data.');

    // Run cron again and ensure that hook_flush_caches() is not called.
    state_del('system_cron_test_flush_caches');
    backdrop_cron_run();
    $this->assertNull(state_get('system_cron_test_flush_caches'), 'hook_flush_caches() was not invoked the second time.');
  }

}

/**
 * Test execution of the cron queue.
 */
class CronQueueTestCase extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    parent::setUp(array('common_test', 'common_test_cron_helper', 'cron_queue_test'));
  }

  /**
   * Tests that exceptions thrown by workers are handled properly.
   */
  function testExceptions() {
    $queue = BackdropQueue::get('cron_queue_test_exception');

    // Enqueue an item for processing.
    $queue->createItem(array($this->randomName() => $this->randomName()));

    // Run cron; the worker for this queue should throw an exception and handle
    // it.
    $this->cronRun();

    // The item should be left in the queue.
    $this->assertEqual($queue->numberOfItems(), 1, 'Failing item still in the queue after throwing an exception.');
  }

  /**
   * Tests worker defined as a class method callable.
   */
  function testCallable() {
    $queue = BackdropQueue::get('cron_queue_test_callback');

    // Enqueue an item for processing.
    $queue->createItem(array($this->randomName() => $this->randomName()));

    // Run cron; the worker should perform the task and delete the item from the
    // queue.
    $this->cronRun();

    // The queue should be empty.
    $this->assertEqual($queue->numberOfItems(), 0);
  }
}

class MetaTagsTestCase extends BackdropWebTestCase {
  /**
   * Verify that the meta tag HTML is generated correctly.
   */
  public function testMetaTag() {
    list($version, ) = explode('.', BACKDROP_VERSION);
    $meta_tags = array(
      'generator' => '<meta name="Generator" content="Backdrop CMS ' . $version . ' (https://backdropcms.org)" />',
      'viewport' => '<meta name="viewport" content="width=device-width, initial-scale=1" />',
    );

    $this->backdropGet('');
    foreach ($meta_tags as $name => $metatag) {
      $this->assertRaw($metatag, 'Default meta tag "' . $name . '" displayed properly.', 'System');
    }
  }
}

/**
 * Tests custom access denied functionality.
 */
class AccessDeniedTestCase extends BackdropWebTestCase {
  protected $admin_user;

  function setUp() {
    parent::setUp();

    // Create an administrative user.
    $this->admin_user = $this->backdropCreateUser(array('access administration pages', 'administer site configuration', 'administer blocks'));

    // Disable caching.
    config_set('system.core', 'cache', '0');
  }

  function testAccessDenied() {
    $this->backdropLogout();
    $this->backdropGet('admin');
    $this->assertText(t('Access denied'), 'Found the default 403 page');
    $this->assertResponse(403);

    $this->backdropLogin($this->admin_user);
    $edit = array(
      'title' => $this->randomName(10),
      'body' => array(LANGUAGE_NONE => array(array('value' => $this->randomName(100)))),
    );
    $node = $this->backdropCreateNode($edit);

    // Use a custom 403 page.
    $this->backdropPost('admin/config/system/site-information', array('site_403' => 'node/' . $node->nid), t('Save configuration'));

    $this->backdropLogout();
    $this->backdropGet('admin');
    $this->assertText($node->title, 'Found the custom 403 page');

    // Logout and check that the user login block is shown on custom 403 pages.
    $this->backdropLogout();

    $this->backdropGet('admin');
    $this->assertText($node->title, 'Found the custom 403 page');
    $this->assertText('Powered by Backdrop CMS', 'Blocks are shown on the custom 403 page');

    // Log back in and remove the custom 403 page.
    $this->backdropLogin($this->admin_user);
    $this->backdropPost('admin/config/system/site-information', array('site_403' => ''), t('Save configuration'));

    // Logout and check that the user login block is shown on default 403 pages.
    $this->backdropLogout();

    $this->backdropGet('admin');
    $this->assertText(t('Access denied'), 'Found the default 403 page');
    $this->assertResponse(403);
    $this->assertText('Powered by Backdrop CMS', 'Blocks are shown on the default 403 page');

    // Log back in, set the custom 403 page to /user and remove the block
    $this->backdropLogin($this->admin_user);
    config_set('system.core', 'site_403', 'user/login');

    // Check that we can log in from the 403 page.
    $this->backdropLogout();
    $edit = array(
      'name' => $this->admin_user->name,
      'pass' => $this->admin_user->pass_raw,
    );
    $this->backdropPost('admin/config/system/site-information', $edit, t('Log in'));

    // Check that we're still on the same page.
    $this->assertText(t('Site information'));
  }

  function test403PathOnSystemForm() {
    $this->backdropLogin($this->admin_user);
    $edit = array(
      'title' => $this->randomName(10),
      'body' => array(LANGUAGE_NONE => array(array('value' => $this->randomName(100)))),
      'path' => array(
        'alias' => $this->randomName(8),
      ),
    );
    $node = $this->backdropCreateNode($edit);
    // Use a custom 403 page.
    $this->backdropPost('admin/config/system/site-information', array('site_403' => $node->path['alias']), t('Save configuration'));
    $this->backdropGet('admin/config/system/site-information');
    $this->assertRaw($node->path['alias'], t("Found the alias for the custom 403 page path."));

    // Now set a new alias on the node and make sure the new alias is on the 403 field.
    $node->title = $this->randomName(7);
    node_save($node);
    $this->backdropGet('admin/config/system/site-information');
    $this->assertRaw($node->path['alias'], t("Found the alias for the custom 403 page path after it has been changed."));
  }
}

class PageNotFoundTestCase extends BackdropWebTestCase {
  protected $admin_user;

  /**
   * Implement setUp().
   */
  function setUp() {
    parent::setUp();

    // Create an administrative user.
    $this->admin_user = $this->backdropCreateUser(array('administer site configuration'));
    $this->backdropLogin($this->admin_user);
  }

  function testPageNotFound() {
    $this->backdropGet($this->randomName(10));
    $this->assertText(t('Page not found'), 'Found the default 404 page');

    $edit = array(
      'title' => $this->randomName(10),
      'body' => array(LANGUAGE_NONE => array(array('value' => $this->randomName(100)))),
    );
    $node = $this->backdropCreateNode($edit);

    // Use a custom 404 page.
    $this->backdropPost('admin/config/system/site-information', array('site_404' => 'node/' . $node->nid), t('Save configuration'));

    $this->backdropGet($this->randomName(10));
    $this->assertText($node->title, 'Found the custom 404 page');
  }

  function test404PathOnSystemForm() {
    $this->backdropLogin($this->admin_user);
    $edit = array(
      'title' => $this->randomName(10),
      'body' => array(LANGUAGE_NONE => array(array('value' => $this->randomName(100)))),
      'path' => array(
        'alias' => $this->randomName(8),
      ),
    );
    $node = $this->backdropCreateNode($edit);
    // Use a custom 404 page.
    $this->backdropPost('admin/config/system/site-information', array('site_404' => $node->path['alias']), t('Save configuration'));
    $this->backdropGet('admin/config/system/site-information');
    $this->assertRaw($node->path['alias'], t("Found the alias for the custom 404 page path."));

    // Now set a new alias on the node and make sure the new alias is on the 404 field.
    $node->title = $this->randomName(7);
    node_save($node);
    $this->backdropGet('admin/config/system/site-information');
    $this->assertRaw($node->path['alias'], t("Found the alias for the custom 404 page path after it has been changed."));
  }
}

class CustomLogoTestCase extends BackdropWebTestCase {
  protected $admin_user;

  /**
   * Implement setUp().
   */
  function setUp() {
    parent::setUp();

    // Create an administrative user.
    $this->admin_user = $this->backdropCreateUser(array('administer site configuration'));
    $this->backdropLogin($this->admin_user);

    theme_enable(array('stark'));
    config_set('system.core', 'theme_default', 'stark');
  }

  /**
   * Test the use of a custom logo.
   */
  function testCustomLogo() {
    // Specify a filesystem path to be used for the logo.
    $file = current($this->backdropGetTestFiles('image'));
    $file_relative = strtr($file->uri, array('public://' => config_get('system.core', 'file_public_path') . '/'));
    $default_theme_path = 'core/themes/stark';

    $supported_paths = array(
      // Raw stream wrapper URI.
      $file->uri => array(
        'form' => file_uri_target($file->uri),
        'src' => file_create_url($file->uri),
      ),
      // Relative path within the public filesystem.
      file_uri_target($file->uri) => array(
        'form' => file_uri_target($file->uri),
        'src' => file_create_url($file->uri),
      ),
      // Relative path to a public file.
      $file_relative => array(
        'form' => $file_relative,
        'src' => file_create_url($file->uri),
      ),
      // Relative path to an arbitrary file.
      'core/misc/feed.png' => array(
        'form' => 'core/misc/feed.png',
        'src' => $GLOBALS['base_url'] . '/' . 'core/misc/feed.png',
      ),
      // Relative path to a file in a theme.
      $default_theme_path . '/screenshot.png' => array(
        'form' => $default_theme_path . '/screenshot.png',
        'src' => $GLOBALS['base_url'] . '/' . $default_theme_path . '/screenshot.png',
      ),
    );
    foreach ($supported_paths as $input => $expected) {
      $edit = array(
        'site_logo_theme' => FALSE,
        'site_logo_path' => $input,
      );
      $this->backdropPost('admin/config/system/site-information', $edit, t('Save configuration'));
      $this->assertNoText('The custom logo path is invalid.');
      $this->assertFieldByName('site_logo_path', $expected['form']);

      // Verify logo path examples.
      $elements = $this->xpath('//div[contains(@class, :item)]/div[@class=:description]/code', array(
        ':item' => 'form-item-site-logo-path',
        ':description' => 'description',
      ));
      // Expected default values (if all else fails).
      $implicit_public_file = 'logo.png';
      $explicit_file = 'public://logo.png';
      $local_file = $default_theme_path . '/logo.png';
      // Adjust for fully qualified stream wrapper URI in public filesystem.
      if (file_uri_scheme($input) == 'public') {
        $implicit_public_file = file_uri_target($input);
        $explicit_file = $input;
        $local_file = strtr($input, array('public://' => config_get('system.core', 'file_public_path') . '/'));
      }
      // Adjust for fully qualified stream wrapper URI elsewhere.
      elseif (file_uri_scheme($input) !== FALSE) {
        $explicit_file = $input;
      }
      // Adjust for relative path within public filesystem.
      elseif ($input == file_uri_target($file->uri)) {
        $implicit_public_file = $input;
        $explicit_file = 'public://' . $input;
        $local_file = config_get('system.core', 'file_public_path') . '/' . $input;
      }
      $this->assertEqual((string) $elements[0], $implicit_public_file);
      $this->assertEqual((string) $elements[1], $explicit_file);
      $this->assertEqual((string) $elements[2], $local_file);

      // Verify the actual 'src' attribute of the logo being output.
      $this->backdropGet('');
      $elements = $this->xpath('//header//a[@rel=:rel]/img', array(
          ':rel' => 'home',
        )
      );
      $this->assertEqual((string) $elements[0]['src'], $expected['src']);
    }

    $unsupported_paths = array(
      // Stream wrapper URI to non-existing file.
      'public://whatever.png',
      'private://whatever.png',
      'temporary://whatever.png',
      // Bogus stream wrapper URIs.
      'public:/whatever.png',
      '://whatever.png',
      ':whatever.png',
      'public://',
      // Relative path within the public filesystem to non-existing file.
      'whatever.png',
      // Relative path to non-existing file in public filesystem.
      config_get('system.core', 'file_public_path') . '/whatever.png',
      // Semi-absolute path to non-existing file in public filesystem.
      '/' . config_get('system.core', 'file_public_path') . '/whatever.png',
      // Relative path to arbitrary non-existing file.
      'core/misc/whatever.png',
      // Semi-absolute path to arbitrary non-existing file.
      '/core/misc/whatever.png',
      // Absolute paths to any local file (even if it exists).
      backdrop_realpath($file->uri),
    );
    $this->backdropGet('admin/config/system/site-information');
    foreach ($unsupported_paths as $path) {
      $edit = array(
        'site_logo_theme' => FALSE,
        'site_logo_path' => $path,
      );
      $this->backdropPost(NULL, $edit, t('Save configuration'));
      $this->assertText('The custom logo path is invalid.');
    }

    // Upload a file to use for the logo.
    $edit = array(
      'site_logo_theme' => FALSE,
      'site_logo_path' => '',
      'files[site_logo_upload]' => backdrop_realpath($file->uri),
    );
    $this->backdropPost('admin/config/system/site-information', $edit, t('Save configuration'));

    $fields = $this->xpath($this->constructFieldXpath('name', 'site_logo_path'));
    $uploaded_filename = 'public://' . $fields[0]['value'];

    $this->backdropGet('');
    $elements = $this->xpath('//header//a[@rel=:rel]/img', array(
        ':rel' => 'home',
      )
    );
    $this->assertEqual($elements[0]['src'], file_create_url($uploaded_filename));
  }

}

/**
 * Tests site maintenance functionality.
 */
class SiteMaintenanceTestCase extends BackdropWebTestCase {
  protected $admin_user;
  protected $profile = 'testing';

  function setUp() {
    parent::setUp();

    // Create a user allowed to access site in maintenance mode.
    $this->user = $this->backdropCreateUser(array('access site in maintenance mode'));
    // Create an administrative user.
    $this->admin_user = $this->backdropCreateUser(array('administer site configuration', 'access site in maintenance mode'));
    $this->backdropLogin($this->admin_user);
  }

  /**
   * Verify site maintenance mode functionality.
   */
  function testSiteMaintenance() {
    // Start with the page cache disabled.
    config_set('system.core', 'page_cache_maximum_age', 0);

    // Turn on maintenance mode.
    $edit = array(
      'maintenance_mode' => TRUE,
    );
    $this->backdropPost('admin/config/development/maintenance', $edit, 'Save configuration');
    $this->assertRaw('The site is now in maintenance mode. Only users with the "Access site in maintenance mode" permission will be able to access the site.', 'Maintenance confirmation message shown.');

    $path = config_get('system.core', 'site_frontpage');
    $admin_message = format_string('The site is currently in maintenance mode. <a href="@url">Go online.</a>', array('@url' => url('admin/config/development/maintenance', array('query' => array('destination' => $path)))));
    $user_message = 'The site is currently in maintenance mode.';
    $offline_message = format_string('@site is currently under maintenance. We should be back shortly. Thank you for your patience.', array('@site' => config_get('system.core', 'site_name')));

    $this->backdropGet($path);
    $this->assertRaw($admin_message, 'Found the site maintenance mode message.');

    // Logout and verify that offline message is displayed.
    $this->backdropLogout();

    $this->backdropGet('token/tree');
    $this->assertResponse(503);
    $this->assertText($offline_message);

    // With caching disabled, the maintenance page is also disabled.
    $this->assertIdentical(strpos($this->backdropGetHeader('Cache-Control'), 'no-cache, must-revalidate'), 0);

    // Enable caching and check that the default maintenance max age is set.
    config_set('system.core', 'page_cache_maximum_age', 300);
    $this->backdropGet('token/tree');
    $this->assertIdentical($this->backdropGetHeader('Cache-Control'), 'public; max-age: 10');

    // Increase the cache lifetime and try a different path.
    config_set('system.core', 'maintenance_page_maximum_age', 60);
    $this->backdropGet('user/register');
    $this->assertResponse(503);
    $this->assertText($offline_message);
    $this->assertIdentical($this->backdropGetHeader('Cache-Control'), 'public; max-age: 60');

    // Verify that user is able to log in.
    $this->backdropGet('user');
    $this->assertResponse(200);
    $this->assertNoText($offline_message);
    // The user should also be able to reset their password.
    $this->backdropGet('user/password');
    $this->assertResponse(200);
    $this->assertNoText($offline_message);
    $this->backdropGet('user/login');
    $this->assertResponse(200);
    $this->assertNoText($offline_message);

    // Log in user and verify that maintenance mode message is displayed
    // directly after login.
    $edit = array(
      'name' => $this->user->name,
      'pass' => $this->user->pass_raw,
    );
    $this->backdropPost(NULL, $edit, 'Log in');
    $this->assertText($user_message);

    // Log in administrative user and configure a custom site offline message.
    $this->backdropLogout();
    $this->backdropLogin($this->admin_user);
    $this->backdropGet('admin/config/development/maintenance');
    $this->assertNoRaw($admin_message, 'Site maintenance mode message not displayed.');

    $offline_message = 'Backdrop is currently under maintenance. We should be back shortly. Thank you for your patience.';
    $edit = array(
      'maintenance_mode_message' => $offline_message,
    );
    $this->backdropPost(NULL, $edit, 'Save configuration');

    // Logout and verify that custom site offline message is displayed.
    $this->backdropLogout();
    $this->backdropGet('');
    $this->assertRaw($offline_message, 'Found the site offline message.');

    // Verify that custom site offline message is not displayed on user/password.
    $this->backdropGet('user/password');
    $this->assertText('Username or e-mail address', 'Anonymous users can access user/password');

    // Submit password reset form.
    $edit = array(
      'name' => $this->user->name,
    );
    $this->backdropPost('user/password', $edit, 'Reset password');
    $mails = $this->backdropGetMails();
    $start = strpos($mails[0]['body'], 'user/reset/'. $this->user->uid);
    $path = substr($mails[0]['body'], $start, 66 + strlen($this->user->uid));

    // Log in with temporary login link.
    $this->backdropPost($path, array(), 'Save password & log in');
    $this->assertText($user_message);
    $this->backdropLogout();

    // Disable maintenance mode.
    $this->backdropLogin($this->admin_user);
    $edit = array(
      'maintenance_mode' => FALSE,
    );
    $this->backdropPost('admin/config/development/maintenance', $edit, 'Save configuration');
    $this->assertRaw('The site is no longer in maintenance mode.');
  }
}

/**
 * Tests generic date and time handling capabilities of Backdrop.
 */
class DateTimeFunctionalTest extends BackdropWebTestCase {
  function setUp() {
    parent::setUp(array('locale'));

    // Create admin user and log in admin user.
    $this->admin_user = $this->backdropCreateUser(array('administer site configuration'));
    $this->backdropLogin($this->admin_user);
  }


  /**
   * Test time zones and DST handling.
   */
  function testTimeZoneHandling() {
    // Setup date/time settings for Honolulu time.
    $config = config('system.date')
      ->set('default_timezone', 'Pacific/Honolulu')
      ->set('user_configurable_timezones', 0)
      ->set('formats.medium.pattern', 'Y-m-d H:i:s O')
      ->save();

    // Create some nodes with different authored-on dates.
    $date1 = '2007-01-31 21:00:00 -1000';
    $date2 = '2007-07-31 21:00:00 -1000';
    $node1 = $this->backdropCreateNode(array('created' => strtotime($date1), 'type' => 'post'));
    $node2 = $this->backdropCreateNode(array('created' => strtotime($date2), 'type' => 'post'));

    // Confirm date format and time zone.
    $this->backdropGet("node/$node1->nid");
    $this->assertText('2007-01-31 21:00:00 -1000', 'Date should be identical, with GMT offset of -10 hours.');
    $this->backdropGet("node/$node2->nid");
    $this->assertText('2007-07-31 21:00:00 -1000', 'Date should be identical, with GMT offset of -10 hours.');

    // Set time zone to Los Angeles time.
    $config->set('default_timezone', 'America/Los_Angeles')->save();

    // Confirm date format and time zone.
    $this->backdropGet("node/$node1->nid");
    $this->assertText('2007-01-31 23:00:00 -0800', 'Date should be two hours ahead, with GMT offset of -8 hours.');
    $this->backdropGet("node/$node2->nid");
    $this->assertText('2007-08-01 00:00:00 -0700', 'Date should be three hours ahead, with GMT offset of -7 hours.');
  }

  /**
   * Test date format configuration.
   */
  function testDateFormatConfiguration() {
    // Confirm 'no custom date formats available' message appears.
    $this->backdropGet('admin/config/regional/date-time/formats');

    // Add custom date format.
    $this->clickLink(t('Add date format'));
    $date_format_name = strtolower($this->randomName(8));
    $label = ucwords($date_format_name);
    $date_format = 'd.m.Y - H:i';
    $edit = array(
      'label' => $label,
      'name' => $date_format_name,
      'pattern' => $date_format,
    );
    $this->backdropPost(NULL, $edit, t('Add format'));
    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), 'Correct page redirection.');

    $this->assertText(t('Date format updated.'), 'Date format added confirmation message appears.');
    $this->assertText($date_format_name, 'Custom date format appears in the date format list.');
    $this->assertText(t('Delete'), 'Delete link for custom date format appears.');

    // Edit custom date format.
    $this->backdropGet('admin/config/regional/date-time/formats');
    $this->clickLink(t('Edit'));
    $edit = array(
      'pattern' => 'Y m',
    );
    $this->backdropPost($this->getUrl(), $edit, t('Save format'));
    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), 'Correct page redirection.');
    $this->assertText(t('Date format updated.'), 'Custom date format successfully updated.');

    // Delete custom date format.
    $this->backdropPost('admin/config/regional/date-time/formats/' . $date_format_name . '/delete', array(), t('Remove'));
    $this->assertEqual($this->getUrl(), url('admin/config/regional/date-time/formats', array('absolute' => TRUE)), 'Correct page redirection.');
    $this->assertRaw(t('Removed date format %format.', array('%format' => $label)), 'Custom date format removed.');

    // Make sure the date does not exist in config.
    $formats = config_get('system.date', 'formats');
    $this->assertFalse(array_key_exists($date_format, $formats), 'Date format has been removed from config.');
  }

  /**
   * Test if the date formats are stored properly.
   */
  function testDateFormatStorage() {
    $date_format_info = array(
      'label' => 'testDateFormatStorage Short Format',
      'name' => 'test_short',
      'pattern' => 'dmYHis',
    );

    system_date_format_save($date_format_info);

    $format = config_get('system.date', 'formats.test_short.pattern');
    $this->assertEqual('dmYHis', $format, 'Date format resides in general config.');
  }
}

class PageTitleFiltering extends BackdropWebTestCase {
  protected $content_user;
  protected $saved_title;

  /**
   * Implement setUp().
   */
  function setUp() {
    parent::setUp();

    $this->content_user = $this->backdropCreateUser(array('create page content', 'access content', 'administer themes', 'administer site configuration'));
    $this->backdropLogin($this->content_user);
    $this->saved_title = backdrop_get_title();
  }

  /**
   * Reset page title.
   */
  function tearDown() {
    // Restore the page title.
    backdrop_set_title($this->saved_title, PASS_THROUGH);

    parent::tearDown();
  }

  /**
   * Tests the handling of HTML by backdrop_set_title() and backdrop_get_title()
   */
  function testTitleTags() {
    $title = "string with <em>HTML</em>";
    // backdrop_set_title's $filter is CHECK_PLAIN by default, so the title should be
    // returned with check_plain().
    backdrop_set_title($title, CHECK_PLAIN);
    $this->assertTrue(strpos(backdrop_get_title(), '<em>') === FALSE, 'Tags in title converted to entities when $output is CHECK_PLAIN.');
    // backdrop_set_title's $filter is passed as PASS_THROUGH, so the title should be
    // returned with HTML.
    backdrop_set_title($title, PASS_THROUGH);
    $this->assertTrue(strpos(backdrop_get_title(), '<em>') !== FALSE, 'Tags in title are not converted to entities when $output is PASS_THROUGH.');
    // Generate node content.
    $langcode = LANGUAGE_NONE;
    $edit = array(
      "title" => '!SimpleTest! ' . $title . $this->randomName(20),
      "body[$langcode][0][value]" => '!SimpleTest! test body' . $this->randomName(200),
    );
    // Create the node with HTML in the title.
    $this->backdropPost('node/add/page', $edit, t('Save'));

    $node = $this->backdropGetNodeByTitle($edit["title"]);
    $this->assertNotNull($node, 'Node created and found in database');
    $this->backdropGet("node/" . $node->nid);
    $this->assertText(check_plain($edit["title"]), 'Check to make sure tags in the node title are converted.');
  }

  /**
   * Test if the title of the site is XSS proof.
   */
  function testTitleXSS() {
    // Set some title with JavaScript and HTML chars to escape.
    $title = '</title><script type="text/javascript">alert("Title XSS!");</script> & < > " \' ';
    $title_filtered = check_plain($title);

    $slogan = '<script type="text/javascript">alert("Slogan XSS!");</script>';
    $slogan_filtered = filter_xss_admin($slogan);

    // Set title and slogan.
    $edit = array(
      'site_name'    => $title,
      'site_slogan'  => $slogan,
    );
    $this->backdropPost('admin/config/system/site-information', $edit, t('Save configuration'));

    // Load frontpage.
    $this->backdropGet('<front>');

    // Test the title.
    $this->assertNoRaw($title, 'Check for the unfiltered version of the title.');
    // Adding </title> so we do not test the escaped version from backdrop_set_title().
    $this->assertRaw($title_filtered . '</title>', 'Check for the filtered version of the title.');

    // Test the slogan.
    $this->assertNoRaw($slogan, 'Check for the unfiltered version of the slogan.');
    $this->assertRaw($slogan_filtered, 'Check for the filtered version of the slogan.');
  }
}

/**
 * Test front page functionality and administration.
 */
class FrontPageTestCase extends BackdropWebTestCase {
  function setUp() {
    parent::setUp('system_test');

    // Create admin user, log in admin user, and create one node.
    $this->admin_user = $this->backdropCreateUser(array('access content', 'administer site configuration'));
    $this->backdropLogin($this->admin_user);
    $this->node_path = "node/" . $this->backdropCreateNode(array('promote' => 1))->nid;

    // Enable front page logging in system_test.module.
    config_set('system.core', 'front_page_output', 1);
  }

  /**
   * Test front page functionality.
   */
  function testBackdropIsFrontPage() {
    $this->backdropGet('');
    $this->assertText(t('On front page.'), 'Path is the front page.');
    config_set('system.core', 'site_frontpage', 'node');
    $this->backdropGet('node');
    $this->assertText(t('On front page.'), 'Path is the front page.');
    $this->backdropGet($this->node_path);
    $this->assertNoText(t('On front page.'), 'Path is not the front page.');

    // Test that the default_nodes_main setting is saved and works from
    // Site information form: /admin/config/system/site-information
    $node1 = $this->backdropCreateNode(array('title' => $this->randomName(20), 'promote' => 1));
    $node2 = $this->backdropCreateNode(array('title' => $this->randomName(20), 'promote' => 1));
    $node3 = $this->backdropCreateNode(array('title' => $this->randomName(20), 'promote' => 1));
    $this->backdropGet('');
    // Check that all three promoted nodes are on the frontpage.
    $this->assertText($node1->title, 'node1 title found on front page.');
    $this->assertText($node2->title, 'node2 title found on front page.');
    $this->assertText($node3->title, 'node3 title found on front page.');
    // Change the number of nodes allowed on frontpage.
    config_set('system.core', 'default_nodes_main', 2);
    backdrop_flush_all_caches();
    // Make sure that the 3rd node is no longer on frontpage.
    $this->backdropGet('');
    $this->assertNoText($node1->title, 'node3 title not on frontpage after setting forntpage listing to 2 nodes.');

    // Change the front page to an invalid path.
    $edit = array('site_frontpage' => 'kittens');
    $this->backdropPost('admin/config/system/site-information', $edit, t('Save configuration'));
    $this->assertText(t("The path '@path' is either invalid or you do not have access to it.", array('@path' => $edit['site_frontpage'])));

    // Change the front page to a valid path.
    $edit['site_frontpage'] = $this->node_path;
    $this->backdropPost('admin/config/system/site-information', $edit, t('Save configuration'));
    $this->assertText(t('The configuration options have been saved.'), 'The front page path has been saved.');

    $this->backdropGet('');
    $this->assertText(t('On front page.'), 'Path is the front page.');
    // Check that the path /node is redirected to the custom frontpage.
    $this->backdropGet('node');
    $node_alias = current_path();
    $this->backdropGet($this->node_path);
    $this_alias = current_path();
    $this->assertEqual($node_alias, $this_alias, 'Path /node is redirected to custom frontpage.');
    $this->backdropGet($this->node_path);
    $this->assertText(t('On front page.'), 'Path is the front page.');
  }
}

class SystemBlockTestCase extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    parent::setUp('block');

    // Create and login user
    $admin_user = $this->backdropCreateUser(array('administer site configuration', 'access administration pages'));
    $this->backdropLogin($admin_user);
  }

  /**
   * Test displaying and hiding the powered-by and help blocks.
   */
  function testSystemBlocks() {
    // The powered-by block is enabled by default. Confirm that the block is
    // being displayed.
    $this->backdropGet('node');
    $this->assertRaw('block-system-powered-by', 'Block successfully being displayed on the page.');

    // Configure the header block in various combinations.
    $layout = layout_load('default');
    // Assume that the header block is the first block in the default layout.
    $header_uuid = reset($layout->positions['header']);
    $header_block = $layout->content[$header_uuid];

    // Set the header menu to use a different menu.
    $header_block->settings['block_settings']['menu'] = 'management';

    // Hide the logo (showing the logo tested by the logo test already).
    $header_block->settings['block_settings']['logo'] = 0;

    // Save the layout containing the block.
    $layout->save();

    // Set a logo.
    $edit = array(
      'site_logo_theme' => FALSE,
      'site_logo_path' => $GLOBALS['base_url'] . '/' . 'core/misc/feed.png',
    );
    $this->backdropPost('admin/config/system/site-information', $edit, t('Save configuration'));

    $this->backdropGet('<front>');

    $elements = $this->xpath('//*[contains(@class, :block)]//*[@class="site-name"]', array(
      ':block' => 'block-system-header',
    ));
    $this->assert(count($elements) === 1, 'Site title found.');

    $elements = $this->xpath('//*[contains(@class, :block)]//a[@class="logo"]', array(
      ':block' => 'block-system-header',
    ));
    $this->assert(count($elements) === 0, 'Site logo hidden in header block.');

    $elements = $this->xpath('//*[contains(@class, :block)]//*[@class="header-menu"]//a[@href=:href]', array(
      ':block' => 'block-system-header',
      ':href' => url('admin'),
    ));
    $this->assert(count($elements) === 1, 'Management menu is set as the header.');
  }
}

/**
 * Test main content rendering fallback provided by system module.
 */
class SystemMainContentFallback extends BackdropWebTestCase {
  protected $admin_user;
  protected $web_user;

  function setUp() {
    parent::setUp('system_test');

    // Create and login admin user.
    $this->admin_user = $this->backdropCreateUser(array(
      'access administration pages',
      'administer site configuration',
      'administer modules',
      'administer layouts',
      'administer nodes',
    ));
    $this->backdropLogin($this->admin_user);

    // Create a web user.
    $this->web_user = $this->backdropCreateUser(array('access user profiles', 'access content'));
  }

  /**
   * Test availability of main content.
   */
  function testMainContentFallback() {
    // Disable the layout module.
    module_disable(array('layout'));
    // Remove the old layout path from the menu.
    menu_rebuild();
    $this->assertFalse(module_exists('layout'), 'Layout module disabled.');

    // At this point, no region is filled and fallback should be triggered.
    $this->backdropGet('admin/config/system/site-information');
    $this->assertField('site_name', 'Admin interface still available.');

    // Fallback should not trigger when another module is handling content.
    $this->backdropGet('system-test/main-content-fallback');
    $this->assertText(t('Content to test main content fallback'), 'Main content still displayed without Layout module enabled.');

    // Request a user* page and see if it is displayed.
    $this->backdropLogin($this->web_user);
    $this->backdropGet('user/' . $this->web_user->uid . '/edit');
    $this->assertField('mail', 'User interface still available.');

    // Enable the layout module again.
    module_enable(array('layout'));
    $this->assertTrue(module_exists('layout'), 'Layout module re-enabled.');
  }
}

/**
 * Tests for the theme interface functionality.
 */
class SystemThemeFunctionalTest extends BackdropWebTestCase {
  protected $profile = 'testing';

  function setUp() {
    parent::setUp(array('node', 'block'));

    $this->backdropCreateContentType(array('type' => 'page', 'name' => 'Page'));

    $this->admin_user = $this->backdropCreateUser(array('access administration pages', 'view the administration theme', 'administer themes', 'bypass node access', 'administer blocks'));
    $this->backdropLogin($this->admin_user);
    $this->node = $this->backdropCreateNode();
  }

  /**
   * Test the individual per-theme settings form.
   */
  function testPerThemeSettings() {
    // Enable the test theme and the module that controls it. Clear caches in
    // between so that the module's hook_system_theme_info() implementation is
    // correctly registered.
    module_enable(array('theme_test'));
    backdrop_flush_all_caches();
    theme_enable(array('test_theme'));

    // Test that the theme-specific settings form can be saved and that the
    // theme-specific checkbox is checked and unchecked as appropriate.
    $this->backdropGet('admin/appearance/settings/test_theme');
    $this->assertNoFieldChecked('edit-test-theme-checkbox', 'The test_theme_checkbox setting is unchecked.');
    $this->backdropPost(NULL, array('test_theme_checkbox' => TRUE), t('Save theme settings'));
    $this->assertText('The configuration options have been saved.');
    $this->assertFieldChecked('edit-test-theme-checkbox', 'The test_theme_checkbox setting is checked.');
    $this->backdropPost(NULL, array('test_theme_checkbox' => FALSE), t('Save theme settings'));
    $this->assertText('The configuration options have been saved.');
    $this->assertNoFieldChecked('edit-test-theme-checkbox', 'The test_theme_checkbox setting is unchecked.');
  }

  /**
   * Test the administration theme functionality.
   */
  function testAdministrationTheme() {
    theme_enable(array('stark'));
    config_set('system.core', 'theme_default', 'stark');
    // Enable an administration theme and show it on the node admin pages.
    $edit = array(
      'admin_theme' => 'seven',
      'node_admin_theme' => TRUE,
    );
    $this->backdropPost('admin/appearance', $edit, t('Save configuration'));

    $this->backdropGet('admin/config');
    $this->assertRaw('core/themes/seven', 'Administration theme used on an administration page.');

    $this->backdropGet('node/' . $this->node->nid);
    $this->assertRaw('core/themes/stark', 'Site default theme used on node page.');

    $this->backdropGet('node/add');
    $this->assertRaw('core/themes/seven', 'Administration theme used on the add content page.');

    $this->backdropGet('node/' . $this->node->nid . '/edit');
    $this->assertRaw('core/themes/seven', 'Administration theme used on the edit content page.');

    // Disable the admin theme on the node admin pages.
    $edit = array(
      'node_admin_theme' => FALSE,
    );
    $this->backdropPost('admin/appearance', $edit, t('Save configuration'));

    $this->backdropGet('admin/config');
    $this->assertRaw('core/themes/seven', 'Administration theme used on an administration page.');

    $this->backdropGet('node/add');
    $this->assertRaw('core/themes/stark', 'Site default theme used on the add content page.');

    // Reset to the default theme settings.
    config_set('system.core', 'theme_default', 'basis');
    $edit = array(
      'admin_theme' => '0',
      'node_admin_theme' => FALSE,
    );
    $this->backdropPost('admin/appearance', $edit, t('Save configuration'));

    $this->backdropGet('admin');
    $this->assertRaw('core/themes/basis', 'Site default theme used on administration page.');

    $this->backdropGet('node/add');
    $this->assertRaw('core/themes/basis', 'Site default theme used on the add content page.');

    // Check that Stark does not show up on the Appearance page.
    $this->backdropGet('admin/appearance');
    $this->assertNoText('Stark', 'Stark theme not shown on appearance page.');

    // Turn on the theme test module, which makes Stark unhidden.
    module_enable(array('theme_test'));
    $this->backdropGet('admin/appearance');
    $this->assertText('Stark', 'Stark theme now shown when hook_system_info_alter() unhides the theme.');
  }

  /**
   * Test switching the default theme.
   */
  function testSwitchDefaultTheme() {
    // Enable Basis and set it as the default theme.
    theme_enable(array('basis'));
    $this->backdropGet('admin/appearance');
    $this->clickLink(t('Set default'));
    $this->assertEqual(config_get('system.core', 'theme_default'), 'basis');

    // Enable the first disabled theme (Bartik) and check again.
    $this->backdropGet('admin/appearance');
    $this->clickLink(t('Enable and set default'), 0);
    $this->assertEqual(config_get('system.core', 'theme_default'), 'bartik');
  }
}


/**
 * Test the basic queue functionality.
 */
class QueueTestCase extends BackdropWebTestCase {
  /**
   * Queues and dequeues a set of items to check the basic queue functionality.
   */
  function testQueue() {
    // Create two queues.
    $queue1 = BackdropQueue::get($this->randomName());
    $queue1->createQueue();
    $queue2 = BackdropQueue::get($this->randomName());
    $queue2->createQueue();

    // Create four items.
    $data = array();
    for ($i = 0; $i < 4; $i++) {
      $data[] = array($this->randomName() => $this->randomName());
    }

    // Queue items 1 and 2 in the queue1.
    $queue1->createItem($data[0]);
    $queue1->createItem($data[1]);

    // Retrieve two items from queue1.
    $items = array();
    $new_items = array();

    $items[] = $item = $queue1->claimItem();
    $new_items[] = $item->data;

    $items[] = $item = $queue1->claimItem();
    $new_items[] = $item->data;

    // First two dequeued items should match the first two items we queued.
    $this->assertEqual($this->queueScore($data, $new_items), 2, 'Two items matched');

    // Add two more items.
    $queue1->createItem($data[2]);
    $queue1->createItem($data[3]);

    $this->assertTrue($queue1->numberOfItems(), 'Queue 1 is not empty after adding items.');
    $this->assertFalse($queue2->numberOfItems(), 'Queue 2 is empty while Queue 1 has items');

    $items[] = $item = $queue1->claimItem();
    $new_items[] = $item->data;

    $items[] = $item = $queue1->claimItem();
    $new_items[] = $item->data;

    // All dequeued items should match the items we queued exactly once,
    // therefore the score must be exactly 4.
    $this->assertEqual($this->queueScore($data, $new_items), 4, 'Four items matched');

    // There should be no duplicate items.
    $this->assertEqual($this->queueScore($new_items, $new_items), 4, 'Four items matched');

    // Delete all items from queue1.
    foreach ($items as $item) {
      $queue1->deleteItem($item);
    }

    // Check that both queues are empty.
    $this->assertFalse($queue1->numberOfItems(), 'Queue 1 is empty');
    $this->assertFalse($queue2->numberOfItems(), 'Queue 2 is empty');
  }

  /**
   * This function returns the number of equal items in two arrays.
   */
  function queueScore($items, $new_items) {
    $score = 0;
    foreach ($items as $item) {
      foreach ($new_items as $new_item) {
        if ($item === $new_item) {
          $score++;
        }
      }
    }
    return $score;
  }
}

class InfoFileParserTestCase extends BackdropUnitTestCase {
  /**
   * Test backdrop_parse_info_format().
   */
  function testBackdropParseInfoFormat() {
    $config = '
simple = Value
quoted = " Value"
multiline = "Value
  Value"
array[] = Value1
array[] = Value2
array_assoc[a] = Value1
array_assoc[b] = Value2
array_deep[][][] = Value
array_deep_assoc[a][b][c] = Value
array_space[a b] = Value';

    $expected = array(
      'simple' => 'Value',
      'quoted' => ' Value',
      'multiline' => "Value\n  Value",
      'array' => array(
        0 => 'Value1',
        1 => 'Value2',
      ),
      'array_assoc' => array(
        'a' => 'Value1',
        'b' => 'Value2',
      ),
      'array_deep' => array(
        0 => array(
          0 => array(
            0 => 'Value',
          ),
        ),
      ),
      'array_deep_assoc' => array(
        'a' => array(
          'b' => array(
            'c' => 'Value',
          ),
        ),
      ),
      'array_space' => array(
        'a b' => 'Value',
      ),
    );

    $parsed = backdrop_parse_info_format($config);

    $this->assertEqual($parsed['simple'], $expected['simple'], 'Set a simple value.');
    $this->assertEqual($parsed['quoted'], $expected['quoted'], 'Set a simple value in quotes.');
    $this->assertEqual($parsed['multiline'], $expected['multiline'], 'Set a multiline value.');
    $this->assertEqual($parsed['array'], $expected['array'], 'Set a simple array.');
    $this->assertEqual($parsed['array_assoc'], $expected['array_assoc'], 'Set an associative array.');
    $this->assertEqual($parsed['array_deep'], $expected['array_deep'], 'Set a nested array.');
    $this->assertEqual($parsed['array_deep_assoc'], $expected['array_deep_assoc'], 'Set a nested associative array.');
    $this->assertEqual($parsed['array_space'], $expected['array_space'], 'Set an array with a whitespace in the key.');
    $this->assertEqual($parsed, $expected, 'Entire parsed .info string and expected array are identical.');
  }
}

/**
 * Ensures that all info files have expected contents.
 */
class InfoFileCoreTest extends BackdropUnitTestCase {
  /**
   * Tests that all core modules' .info files have the project type string set to "module".
   */
  function testModuleInfoFileContents() {
    $modules = backdrop_system_listing('/^' . BACKDROP_PHP_FUNCTION_PATTERN . '\.module$/', 'core/modules', 'name', 0);
    $type_fails = array();
    $version_fails = array();
    foreach($modules as $key => $module) {
      $info = backdrop_parse_info_file(dirname($module->uri) . '/' . $module->name . '.info');
      if (!isset($info['type'])) {
        $type_fails[] = $key;
        $this->fail(format_string('%key does not have project type set to "module".', array('%key' => $key)));
      }
      elseif ($info['type'] != 'module') {
        $type_fails[] = $key;
        $this->fail(format_string('Project type for %key is not set to "module".', array('%key' => $key)));
      }
      if (!isset($info['version'])) {
        $version_fails[] = $key;
        $this->fail(format_string('%key does not have a version string in the .info file.', array('%key' => $key)));
      }
    }
    $this->assertFalse($type_fails, 'Project type string set to "module" for all core modules.');
    $this->assertFalse($version_fails, 'Version set for all core modules.');
  }

  /**
   * Tests that all core themes' .info files have the project type string set to "theme".
   */
  function testThemeInfoFileContents() {
    $themes = backdrop_system_listing('/^' . BACKDROP_PHP_FUNCTION_PATTERN . '\.info$/', 'core/themes');
    $type_fails = array();
    $version_fails = array();
    foreach($themes as $key => $theme) {
      $info = backdrop_parse_info_file(dirname($theme->uri) . '/' . $theme->name . '.info');
      if (!isset($info['type'])) {
        $type_fails[] = $key;
        $this->fail(format_string('%key does not have project type set to "theme".', array('%key' => $key)));
      }
      elseif ($info['type'] != 'theme') {
        $type_fails[] = $key;
        $this->fail(format_string('Project type for %key is not set to "theme".', array('%key' => $key)));
      }
      if (!isset($info['version'])) {
        $version_fails[] = $key;
        $this->fail(format_string('%key does not have a version string in the .info file.', array('%key' => $key)));
      }
    }
    $this->assertFalse($type_fails, 'Project type string set to "theme" for all core themes.');
    $this->assertFalse($version_fails, 'Version set for all core themes.');
  }

  /**
   * Tests that all core layouts' .info files have the project type string set to "layout".
   */
  function testLayoutInfoFileContents() {
    $layouts = backdrop_system_listing('/^' . BACKDROP_PHP_FUNCTION_PATTERN . '\.info$/', 'core/layouts', 'name', 0);
    $type_fails = array();
    $version_fails = array();
    foreach($layouts as $key => $layout) {
      $info = backdrop_parse_info_file(dirname($layout->uri) . '/' . $layout->name . '.info');
      if (!isset($info['type'])) {
        $type_fails[] = $key;
        $this->fail(format_string('%key does not have project type set to "layout".', array('%key' => $key)));
      }
      elseif ($info['type'] != 'layout') {
        $type_fails[] = $key;
        $this->fail(format_string('Project type for %key is not set to "layout".', array('%key' => $key)));
      }
      if (!isset($info['version'])) {
        $version_fails[] = $key;
        $this->fail(format_string('%key does not have a version string in the .info file.', array('%key' => $key)));
      }
    }
    $this->assertFalse($type_fails, 'Project type string set to "layout" for all core layouts.');
    $this->assertFalse($version_fails, 'Version set for all core layouts.');
  }
}

/**
 * Tests the effectiveness of hook_system_info_alter().
 */
class SystemInfoAlterTestCase extends BackdropWebTestCase {
  /**
   * Tests that {system}.info is rebuilt after a module that implements
   * hook_system_info_alter() is enabled. Also tests if core *_list() functions
   * return freshly altered info.
   */
  function testSystemInfoAlter() {
    // Enable our test module. Flush all caches, which we assert is the only
    // thing necessary to use the rebuilt {system}.info.
    module_enable(array('module_test'), FALSE);
    backdrop_flush_all_caches();
    $this->assertTrue(module_exists('module_test'), 'Test module is enabled.');

    $info = $this->getSystemInfo('seven', 'theme');
    $this->assertTrue(isset($info['regions']['test_region']), 'Altered theme info was added to {system}.info.');
    $system_list_themes = system_list('theme');
    $info = $system_list_themes['seven']->info;
    $this->assertTrue(isset($info['regions']['test_region']), 'Altered theme info was returned by system_list().');
    $list_themes = list_themes();
    $this->assertTrue(isset($list_themes['seven']->info['regions']['test_region']), 'Altered theme info was returned by list_themes().');

    // Disable the module and verify that {system}.info is rebuilt without it.
    module_disable(array('module_test'), FALSE);
    backdrop_flush_all_caches();
    $this->assertFalse(module_exists('module_test'), 'Test module is disabled.');

    $info = $this->getSystemInfo('seven', 'theme');
    $this->assertFalse(isset($info['regions']['test_region']), 'Altered theme info was removed from {system}.info.');
    $system_list_themes = system_list('theme');
    $info = $system_list_themes['seven']->info;
    $this->assertFalse(isset($info['regions']['test_region']), 'Altered theme info was not returned by system_list().');
    $list_themes = list_themes();
    $this->assertFalse(isset($list_themes['seven']->info['regions']['test_region']), 'Altered theme info was not returned by list_themes().');
  }

  /**
   * Returns the info array as it is stored in {system}.
   *
   * @param $name
   *   The name of the record in {system}.
   * @param $type
   *   The type of record in {system}.
   *
   * @return
   *   Array of info, or FALSE if the record is not found.
   */
  function getSystemInfo($name, $type) {
    $raw_info = db_query("SELECT info FROM {system} WHERE name = :name AND type = :type", array(':name' => $name, ':type' => $type))->fetchField();
    return $raw_info ? unserialize($raw_info) : FALSE;
  }
}

/**
 * Tests for the update system functionality.
 */
class UpdateScriptFunctionalTest extends BackdropWebTestCase {
  private $update_url;
  private $update_user;

  function setUp() {
    parent::setUp(array('update_script_test', 'dblog'));
    $this->update_url = $GLOBALS['base_url'] . '/core/update.php';
    $this->update_user = $this->backdropCreateUser(array('administer software updates'));
  }

  /**
   * Tests that there are no pending updates for the first test method.
   */
  function testNoPendingUpdates() {
    // Ensure that for the first test method in a class, there are no pending
    // updates. This tests a backdrop_get_schema_versions() bug that previously
    // led to the wrong schema version being recorded for the initial install
    // of a child site during automated testing.
    $this->backdropLogin($this->update_user);
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->backdropPost(NULL, array(), t('Continue'));
    $this->assertText(t('No pending updates.'), 'End of update process was reached.');
  }

  /**
   * Tests access to the update script.
   */
  function testUpdateAccess() {
    // Try accessing update.php without the proper permission.
    $regular_user = $this->backdropCreateUser();
    $this->backdropLogin($regular_user);
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->assertResponse(403);

    // Try accessing update.php as an anonymous user.
    $this->backdropLogout();
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->assertResponse(403);

    // Access the update page with the proper permission.
    $this->backdropLogin($this->update_user);
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->assertResponse(200);

    // Access the update page as user 1.
    $user1 = user_load(1);
    $user1->pass_raw = user_password();
    require_once BACKDROP_ROOT . '/' . settings_get('password_inc', 'core/includes/password.inc');
    $user1->pass = user_hash_password(trim($user1->pass_raw));
    db_query("UPDATE {users} SET pass = :pass WHERE uid = :uid", array(':pass' => $user1->pass, ':uid' => $user1->uid));
    $this->backdropLogin($user1);
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->assertResponse(200);
  }

  /**
   * Tests that requirements warnings and errors are correctly displayed.
   */
  function testRequirements() {
    $config = config('update.settings');
    $this->backdropLogin($this->update_user);

    // If there are no requirements warnings or errors, we expect to be able to
    // go through the update process uninterrupted.
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->backdropPost(NULL, array(), t('Continue'));
    $this->assertText(t('No pending updates.'), 'End of update process was reached.');
    // Confirm that all caches were cleared.
    $this->assertText(t('hook_flush_caches() invoked for update_script_test.module.'), 'Caches were cleared when there were no requirements warnings or errors.');

    // If there is a requirements warning, we expect it to be initially
    // displayed, but clicking the link to proceed should allow us to go
    // through the rest of the update process uninterrupted.

    // First, run this test with pending updates to make sure they can be run
    // successfully.
    $config->set('update_requirement_type', REQUIREMENT_WARNING)->save();
    backdrop_set_installed_schema_version('update_script_test', backdrop_get_installed_schema_version('update_script_test') - 1);
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->assertText('This is a requirements warning provided by the update_script_test module.');
    $this->clickLink('try again');
    $this->assertNoText('This is a requirements warning provided by the update_script_test module.');
    $this->backdropPost(NULL, array(), t('Continue'));
    $this->backdropPost(NULL, array(), t('Apply pending updates'));
    $this->assertText(t('The update_script_test_update_1000() update was executed successfully.'), t('End of update process was reached.'));
    // Confirm that all caches were cleared.
    $this->assertText(t('hook_flush_caches() invoked for update_script_test.module.'), 'Caches were cleared after resolving a requirements warning and applying updates.');

    // Now try again without pending updates to make sure that works too.
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->assertText('This is a requirements warning provided by the update_script_test module.');
    $this->clickLink('try again');
    $this->assertNoText('This is a requirements warning provided by the update_script_test module.');
    $this->backdropPost(NULL, array(), t('Continue'));
    $this->assertText(t('No pending updates.'), 'End of update process was reached.');
    // Confirm that all caches were cleared.
    $this->assertText(t('hook_flush_caches() invoked for update_script_test.module.'), 'Caches were cleared after applying updates and re-running the script.');

    // If there is a requirements error, it should be displayed even after
    // clicking the link to proceed (since the problem that triggered the error
    // has not been fixed).
    $config->set('update_requirement_type', REQUIREMENT_ERROR)->save();
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->assertText('This is a requirements error provided by the update_script_test module.');
    $this->clickLink('try again');
    $this->assertText('This is a requirements error provided by the update_script_test module.');

    // Check if the optional 'value' key displays without a notice.
    $config->set('update_requirement_type', REQUIREMENT_INFO)->save();
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $this->assertText('This is a requirements info provided by the update_script_test module.');
    $this->assertNoText('Notice: Undefined index: value in theme_status_report()');
  }

  /**
   * Tests the effect of using the update script on the theme system.
   */
  function testThemeSystem() {
    // Since visiting update.php triggers a rebuild of the theme system from an
    // unusual maintenance mode environment, we check that this rebuild did not
    // put any incorrect information about the themes into the database.
    $original_theme_data = db_query("SELECT * FROM {system} WHERE type = 'theme' ORDER BY name")->fetchAll();
    $this->backdropLogin($this->update_user);
    $this->backdropGet($this->update_url, array('external' => TRUE));
    $final_theme_data = db_query("SELECT * FROM {system} WHERE type = 'theme' ORDER BY name")->fetchAll();
    $this->assertEqual($original_theme_data, $final_theme_data, 'Visiting update.php does not alter the information about themes stored in the database.');
  }

  /**
   * Tests update.php when there are no updates to apply.
   */
  function testNoUpdateFunctionality() {
    // Click through update.php with 'administer software updates' permission.
    $this->backdropLogin($this->update_user);
    $this->backdropPost($this->update_url, array(), t('Continue'), array('external' => TRUE));
    $this->assertText(t('No pending updates.'));
    $this->assertNoLink('Administration pages');
    $this->clickLink('Front page');
    $this->assertResponse(200);

    // Click through update.php with 'access administration pages' permission.
    $admin_user = $this->backdropCreateUser(array('administer software updates', 'access administration pages'));
    $this->backdropLogin($admin_user);
    $this->backdropPost($this->update_url, array(), t('Continue'), array('external' => TRUE));
    $this->assertText(t('No pending updates.'));
    $this->clickLink('Administration pages');
    $this->assertResponse(200);
  }

  /**
   * Tests update.php after performing a successful update.
   */
  function testSuccessfulUpdateFunctionality() {
    backdrop_set_installed_schema_version('update_script_test', backdrop_get_installed_schema_version('update_script_test') - 1);
    // Click through update.php with 'administer software updates' permission.
    $this->backdropLogin($this->update_user);
    $this->backdropPost($this->update_url, array(), t('Continue'), array('external' => TRUE));
    $this->backdropPost(NULL, array(), t('Apply pending updates'));
    $this->assertText('Updates were attempted.');
    $this->assertLink('site');
    $this->assertNoLink('Administration pages');
    $this->assertNoLink('logged');
    $this->clickLink('Front page');
    $this->assertResponse(200);

    backdrop_set_installed_schema_version('update_script_test', backdrop_get_installed_schema_version('update_script_test') - 1);
    // Click through update.php with 'access administration pages' and
    // 'access site reports' permissions.
    $admin_user = $this->backdropCreateUser(array('administer software updates', 'access administration pages', 'access site reports'));
    $this->backdropLogin($admin_user);
    $this->backdropPost($this->update_url, array(), t('Continue'), array('external' => TRUE));
    $this->backdropPost(NULL, array(), t('Apply pending updates'));
    $this->assertText('Updates were attempted.');
    $this->assertLink('logged');
    $this->clickLink('Administration pages');
    $this->assertResponse(200);
  }
}

/**
 * Functional tests for the flood control mechanism.
 */
class FloodFunctionalTest extends BackdropWebTestCase {
  /**
   * Test flood control mechanism clean-up.
   */
  function testCleanUp() {
    $threshold = 1;
    $window_expired = -1;
    $name = 'flood_test_cleanup';

    // Register expired event.
    flood_register_event($name, $window_expired);
    // Verify event is not allowed.
    $this->assertFalse(flood_is_allowed($name, $threshold));
    // Run cron and verify event is now allowed.
    $this->cronRun();
    $this->assertTrue(flood_is_allowed($name, $threshold));

    // Register unexpired event.
    flood_register_event($name);
    // Verify event is not allowed.
    $this->assertFalse(flood_is_allowed($name, $threshold));
    // Run cron and verify event is still not allowed.
    $this->cronRun();
    $this->assertFalse(flood_is_allowed($name, $threshold));
  }
}

/**
 * Test HTTP file downloading capability.
 */
class RetrieveFileTestCase extends BackdropWebTestCase {
  /**
   * Invokes system_retrieve_file() in several scenarios.
   */
  function testFileRetrieving() {
    // Test 404 handling by trying to fetch a randomly named file.
    backdrop_mkdir($sourcedir = 'public://' . $this->randomName());
    $filename = 'Файл для тестирования ' . $this->randomName();
    $url = file_create_url($sourcedir . '/' . $filename);
    $retrieved_file = system_retrieve_file($url);
    $this->assertFalse($retrieved_file, 'Non-existent file not fetched.');

    // Actually create that file, download it via HTTP and test the returned path.
    file_put_contents($sourcedir . '/' . $filename, 'testing');
    $retrieved_file = system_retrieve_file($url);

    // URLs could not contains characters outside the ASCII set so $filename
    // has to be encoded.
    $encoded_filename = rawurlencode($filename);

    $this->assertEqual($retrieved_file, 'public://' . $encoded_filename, 'Sane path for downloaded file returned (public:// scheme).');
    $this->assertTrue(is_file($retrieved_file), 'Downloaded file does exist (public:// scheme).');
    $this->assertEqual(filesize($retrieved_file), 7, 'File size of downloaded file is correct (public:// scheme).');
    file_unmanaged_delete($retrieved_file);

    // Test downloading file to a different location.
    backdrop_mkdir($targetdir = 'temporary://' . $this->randomName());
    $retrieved_file = system_retrieve_file($url, $targetdir);
    $this->assertEqual($retrieved_file, "$targetdir/$encoded_filename", 'Sane path for downloaded file returned (temporary:// scheme).');
    $this->assertTrue(is_file($retrieved_file), 'Downloaded file does exist (temporary:// scheme).');
    $this->assertEqual(filesize($retrieved_file), 7, 'File size of downloaded file is correct (temporary:// scheme).');
    file_unmanaged_delete($retrieved_file);

    file_unmanaged_delete_recursive($sourcedir);
    file_unmanaged_delete_recursive($targetdir);
  }
}

/**
 * Functional tests shutdown functions.
 */
class ShutdownFunctionsTest extends BackdropWebTestCase {
  function setUp() {
    parent::setUp('system_test');
  }

  /**
   * Test shutdown functions.
   */
  function testShutdownFunctions() {
    $arg1 = $this->randomName();
    $arg2 = $this->randomName();
    $this->backdropGet('system-test/shutdown-functions/' . $arg1 . '/' . $arg2);

    // Now wait a few seconds to ensure that the watchdog entries are written
    // before we check for them.
    sleep(2);

    $shutdown1 = format_string('First shutdown function, arg1 : @arg1, arg2: @arg2', array('@arg1' => $arg1, '@arg2' => $arg2));
    $shutdown2 = format_string('Second shutdown function, arg1 : @arg1, arg2: @arg2', array('@arg1' => $arg1, '@arg2' => $arg2));

    // Text doesn't show up because the page returns before shutdown functions.
    $this->assertNoText($shutdown1);
    $this->assertNoText($shutdown2);

    // However, the messages should show up in watchdog.
    $shutdown1_log = db_query("SELECT COUNT(*) FROM {watchdog} WHERE message = :string", array(':string' => $shutdown1))->fetchField();
    $shutdown2_log = db_query("SELECT COUNT(*) FROM {watchdog} WHERE message = :string", array(':string' => $shutdown2))->fetchField();
    $this->assertEqual($shutdown1_log, 1, 'Shutdown message 1 logged.');
    $this->assertEqual($shutdown2_log, 1, 'Shutdown message 2 logged.');

    // Make sure exceptions displayed through _backdrop_render_exception_safe()
    // are correctly escaped.
    $message = 'Exception: Backdrop is &amp;lt;blink&amp;gt;awesome&amp;lt;/blink&amp;gt;';
    $exception_log = db_query("SELECT COUNT(*) FROM {watchdog} WHERE message LIKE :string", array(':string' => db_like($message) . '%'))->fetchField();
    $this->assertRaw($exception_log, 1, 'Uncaught exception logged.');
  }
}

/**
 * Tests administrative overview pages.
 */
class SystemAdminTestCase extends BackdropWebTestCase {
  function setUp() {
    // testAdminPages() requires Locale module.
    parent::setUp(array('locale'));

    // Create an administrator with all permissions, as well as a regular user
    // who can only access administration pages and perform some Locale module
    // administrative tasks, but not all of them.
    $this->admin_user = $this->backdropCreateUser(array_keys(module_invoke_all('permission')));
    $this->web_user = $this->backdropCreateUser(array(
      'access administration pages',
      'translate interface',
    ));
    $this->backdropLogin($this->admin_user);
  }

  /**
   * Tests output on administrative listing pages.
   */
  function testAdminPages() {
    // Go to Administration.
    $this->backdropGet('admin');

    // Verify that all visible, top-level administration links are listed on
    // the main administration page.
    foreach (menu_get_router() as $path => $item) {
      if (strpos($path, 'admin/') === 0 && ($item['type'] & MENU_VISIBLE_IN_TREE) && $item['_number_parts'] == 2) {
        $this->assertLink($item['title']);
        $this->assertLinkByHref($path);
        $this->assertText($item['description']);
      }
    }

    // For each administrative listing page on which the Locale module appears,
    // verify that there are links to the module's primary configuration pages,
    // but no links to its individual sub-configuration pages. Also verify that
    // a user with access to only some Locale module administration pages only
    // sees links to the pages they have access to.
    $admin_list_pages = array(
      'admin/index',
      'admin/config',
      'admin/config/regional',
    );

    foreach ($admin_list_pages as $page) {
      // For the administrator, verify that there are links to Locale's primary
      // configuration pages, but no links to individual sub-configuration
      // pages.
      $this->backdropLogin($this->admin_user);
      $this->backdropGet($page);
      $this->assertLinkByHref('admin/config');
      $this->assertLinkByHref('admin/config/regional/settings');
      $this->assertLinkByHref('admin/config/regional/date-time');
      $this->assertLinkByHref('admin/config/regional/language');
      $this->assertNoLinkByHref('admin/config/regional/language/detection/session');
      $this->assertNoLinkByHref('admin/config/regional/language/detection/url');
      $this->assertLinkByHref('admin/config/regional/translate');
      // On admin/index only, the administrator should also see a "Configure
      // permissions" link for the Locale module.
      if ($page == 'admin/index') {
        $this->assertLinkByHref("admin/config/people/permissions#module-locale");
      }

      // For a less privileged user, verify that there are no links to Locale's
      // primary configuration pages, but a link to the translate page exists.
      $this->backdropLogin($this->web_user);
      $this->backdropGet($page);
      $this->assertLinkByHref('admin/config');
      $this->assertNoLinkByHref('admin/config/regional/settings');
      $this->assertNoLinkByHref('admin/config/regional/date-time');
      $this->assertNoLinkByHref('admin/config/regional/language');
      $this->assertNoLinkByHref('admin/config/regional/language/detection/session');
      $this->assertNoLinkByHref('admin/config/regional/language/detection/url');
      $this->assertLinkByHref('admin/config/regional/translate');
      // This user cannot configure permissions, so even on admin/index should
      // not see a "Configure permissions" link for the Locale module.
      if ($page == 'admin/index') {
        $this->assertNoLinkByHref("admin/config/people/permissions#module-locale");
      }
    }
  }
}

/**
 * Tests authorize.php and related hooks.
 */
class SystemAuthorizeCase extends BackdropWebTestCase {
  function setUp() {
    parent::setUp(array('system_test'));

    $GLOBALS['settings']['allow_authorize_operations'] = TRUE;

    // Create an administrator user.
    $this->admin_user = $this->backdropCreateUser(array('administer software updates'));
    $this->backdropLogin($this->admin_user);
  }

  /**
   * Helper function to initialize authorize.php and load it via backdropGet().
   *
   * Initializing authorize.php needs to happen in the child Backdrop
   * installation, not the parent. So, we visit a menu callback provided by
   * system_test.module which calls system_authorized_init() to initialize the
   * $_SESSION inside the test site, not the framework site. This callback
   * redirects to authorize.php when it's done initializing.
   *
   * @see system_authorized_init().
   */
  function backdropGetAuthorizePHP($page_title = 'system-test-auth') {
    $this->backdropGet('system-test/authorize-init/' . $page_title);
  }

  /**
   * Tests the FileTransfer hooks
   */
  function testFileTransferHooks() {
    $page_title = $this->randomName(16);
    $this->backdropGetAuthorizePHP($page_title);
    $this->assertTitle(strtr('@title | Backdrop CMS', array('@title' => $page_title)), 'authorize.php page title is correct.');
    $this->assertNoText('It appears you have reached this page in error.');
    $this->assertText('To continue, provide your server connection details');
    // Make sure we see the new connection method added by system_test.
    $this->assertRaw('System Test FileTransfer');
    // Make sure the settings form callback works.
    $this->assertText('System Test Username');
  }
}

/**
 * Test the handling of requests containing 'index.php'.
 */
class SystemIndexPhpTest extends BackdropWebTestCase {

  /**
   * Test index.php handling.
   */
  function testIndexPhpHandling() {
    $this->backdropGet('<front>');
    $this->assertResponse(200, 'Make sure the front page returns a valid page.');

    $index_php = $GLOBALS['base_url'] . '/index.php';

    $this->backdropGet($index_php, array('external' => TRUE));
    $this->assertResponse(200, 'Make sure index.php returns a valid page.');

    $this->backdropGet($index_php, array('external' => TRUE, 'query' => array('q' => 'user')));
    $this->assertResponse(200, 'Make sure index.php?q=user returns a valid page.');

    $this->backdropGet($index_php .'/user', array('external' => TRUE));
    $this->assertResponse(404, "Make sure index.php/user returns a 'page not found'.");
  }
}

/**
 * Test case for backdrop_valid_token().
 */
class SystemValidTokenTest extends BackdropWebTestCase {
  protected $profile = 'testing';
  private $assertErrors = FALSE;

  /**
   * Tests invalid invocations of backdrop_valid_token() that must return FALSE.
   */
  public function testTokenValidation() {
    // The following checks will throw PHP notices, so we disable error
    // assertions.
    $this->assertErrors = FALSE;
    $this->assertFalse(backdrop_valid_token(NULL, new stdClass()), 'Token NULL, value object returns FALSE.');
    $this->assertFalse(backdrop_valid_token(0, array()), 'Token 0, value array returns FALSE.');
    $this->assertFalse(backdrop_valid_token('', array()), "Token '', value array returns FALSE.");
    $this->assertFalse('' === backdrop_get_token(array()), 'Token generation does not return an empty string on invalid parameters.');
    $this->assertErrors = TRUE;

    $this->assertFalse(backdrop_valid_token(TRUE, 'foo'), 'Token TRUE, value foo returns FALSE.');
    $this->assertFalse(backdrop_valid_token(0, 'foo'), 'Token 0, value foo returns FALSE.');
  }

  /**
   * Overrides BackdropTestCase::errorHandler().
   */
  public function errorHandler($severity, $message, $file = NULL, $line = NULL) {
    if ($this->assertErrors) {
      return parent::errorHandler($severity, $message, $file, $line);
    }
    return TRUE;
  }
}

/**
 * Tests backdrop_set_message() and related functions.
 */
class BackdropSetMessageTest extends BackdropWebTestCase {
  protected $profile = 'testing';
  function setUp() {
    parent::setUp('system_test');
  }

  /**
   * Tests setting messages and removing one before it is displayed.
   */
  function testSetRemoveMessages() {
    // The page at system-test/backdrop-set-message sets two messages and then
    // removes the first before it is displayed.
    $this->backdropGet('system-test/backdrop-set-message');
    $this->assertNoText('First message (removed).');
    $this->assertText('Second message (not removed).');
  }
}

/**
 * Tests confirm form destinations.
 */
class ConfirmFormTest extends BackdropWebTestCase {
  protected $admin_user;

  function setUp() {
    parent::setUp();

    $this->admin_user = $this->backdropCreateUser(array('administer users'));
    $this->backdropLogin($this->admin_user);
  }

  /**
   * Tests that the confirm form does not use external destinations.
   */
  function testConfirmForm() {
    $this->backdropGet('user/1/cancel');
    $this->assertCancelLinkUrl(url('user/1'));
    $this->backdropGet('user/1/cancel', array('query' => array('destination' => 'node')));
    $this->assertCancelLinkUrl(url('node'));
    $this->backdropGet('user/1/cancel', array('query' => array('destination' => 'http://example.com')));
    $this->assertCancelLinkUrl(url('user/1'));
  }

  /**
   * Asserts that a cancel link is present pointing to the provided URL.
   */
  function assertCancelLinkUrl($url, $message = '', $group = 'Other') {
    $links = $this->xpath('//a[normalize-space(text())=:label and @href=:url]', array(':label' => t('Cancel'), ':url' => $url));
    $message = ($message ? $message : format_string('Cancel link with url %url found.', array('%url' => $url)));
    return $this->assertTrue(isset($links[0]), $message, $group);
  }
}

/**
 * Tests request sanitation used in early bootstrap.
 */
class BackdropRequestSanitizerUnitTestCase extends BackdropUnitTestCase {
  protected $testCases = array();

  function setUp() {
    // Set up an array of test cases.
    $this->testCases = array(
      'invalid_param_get' => array(
        'setup' => array('_GET' => array('#q' => 'blah', 'destination' => 'whatever?foo=bar'), '_POST' => array('foo' => 'bar')),
        'expected' => array('_GET' => array('destination' => 'whatever?foo=bar'), '_POST' => array('foo' => 'bar')),
      ),
      'invalid_param_post' => array(
        'setup' => array('_POST' => array('#q' => 'blah')),
        'expected' => array('_POST' => array()),
      ),
      'invalid_param_cookie' => array(
        'setup' => array('_COOKIE' => array('#q' => 'blah')),
        'expected' => array('_COOKIE' => array()),
      ),
      'invalid_param_request' => array(
        'setup' => array('_REQUEST' => array('#q' => 'blah')),
        'expected' => array('_REQUEST' => array()),
      ),
      'invalid_destination_get' => array(
        'setup' => array('_GET' => array('destination' => 'whatever?%23test=value')),
        'expected' => array('_GET' => array()),
      ),
      'invalid_destination_get_subkey' => array(
        'setup' => array('_GET' => array('destination' => 'whatever?blah[%23test]=value')),
        'expected' => array('_GET' => array()),
      ),
      'invalid_destination_get_q' => array(
        'setup' => array('_GET' => array('destination' => 'whatever?q[%23test]=value&foo=bar')),
        'expected' => array('_GET' => array()),
      ),
      'invalid_destination_zero_bytes_get' => array(
        'setup' => array('_GET' => array('destination' => "whatever?[\x00bar]=base&%23test=value")),
        'expected' => array('_GET' => array()),
      ),
      'valid_destination' => array(
        'setup' => array('_GET' => array('destination' => 'whatever')),
        'expected' => array('_GET' => array('destination' => 'whatever')),
      ),
    );
    parent::setUp();
  }

  /**
   * Tests request sanitation used in early bootstrap.
   */
  function testBackdropRequestSanitizer() {
    foreach ($this->testCases as $provider_name => $arguments) {
      foreach ($arguments['setup'] as $global_name => $value) {
        $GLOBALS[$global_name] = $value;
      }
      // Suppress errors so the resulting globals can be checked.
      @_backdrop_bootstrap_sanitize_request();
      foreach ($arguments['expected'] as $global_name => $value) {
        $this->assertEqual($GLOBALS[$global_name], $value);
      }
    }
  }
}

/**
 * Tests uuid.inc and related functions.
 */
class UuidUnitTestCase extends BackdropUnitTestCase {

  /**
   * The UUID object to be used for generating UUIDs.
   *
   * @var Uuid
   */
  protected $uuid;

  public function setUp() {
    // Initiate the generator. This will lazy-load uuid.inc.
    $this->uuid = new Uuid();
    parent::setUp();
  }

  /**
   * Test generating a UUID.
   */
  public function testGenerateUuid() {
    $uuid = $this->uuid->generate();
    $this->assertTrue($this->uuid->isValid($uuid), 'UUID generation works.');
  }

  /**
   * Test that generated UUIDs are unique.
   */
  public function testUuidIsUnique() {
    $uuid1 = $this->uuid->generate();
    $uuid2 = $this->uuid->generate();
    $this->assertNotEqual($uuid1, $uuid2, 'Same UUID was not generated twice.');
  }

  /**
   * Test UUID validation.
   */
  function testUuidValidation() {
    // These valid UUIDs.
    $uuid_fqdn = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    $uuid_min = '00000000-0000-0000-0000-000000000000';
    $uuid_max = 'ffffffff-ffff-ffff-ffff-ffffffffffff';

    $this->assertTrue($this->uuid->isValid($uuid_fqdn), t('FQDN namespace UUID (@uuid) is valid', array('@uuid' => $uuid_fqdn)));
    $this->assertTrue($this->uuid->isValid($uuid_min), t('Minimum UUID value (@uuid) is valid', array('@uuid' => $uuid_min)));
    $this->assertTrue($this->uuid->isValid($uuid_max), t('Maximum UUID value (@uuid) is valid', array('@uuid' => $uuid_max)));

    // These are invalid UUIDs.
    $invalid_format = '0ab26e6b-f074-4e44-9da-601205fa0e976';
    $invalid_length = '0ab26e6b-f074-4e44-9daf-1205fa0e9761f';

    $this->assertFalse($this->uuid->isValid($invalid_format), t('@uuid is not a valid UUID', array('@uuid' => $invalid_format)));
    $this->assertFalse($this->uuid->isValid($invalid_length), t('@uuid is not a valid UUID', array('@uuid' => $invalid_length)));

  }
}

/**
 * Test menu block settings.
 */
class MenuBlockTestCase extends BackdropWebTestCase {
  function setUp() {
    parent::setUp('menu');

    $this->admin_user = $this->backdropCreateUser(array(
      'access administration pages',
      'administer content types',
      'administer menu',
      'administer layouts',
      'create page content',
    ));
    $this->backdropLogin($this->admin_user);
  }

  /**
   * Test Menu Block functionality with a system menu.
   */
  function testMainMenuBlocks() {
    $this->doMenuBlockTests('main-menu', 'Primary navigation');
  }

  /**
   * Test Menu Block functionality with custom menu.
   */
  function testCustomMenuBlocks() {
    // Add a new custom menu.
    $menu_name = substr(hash('sha256', $this->randomName(16)), 0, MENU_MAX_MENU_NAME_LENGTH_UI);
    $title = $this->randomName(16);

    $menu = array(
      'menu_name' => $menu_name,
      'title' => $title,
      'description' => 'Description text',
    );
    menu_save($menu);
    $this->doMenuBlockTests($menu_name, $title);
  }

  /**
   * Test Menu Block functionality.
   */
  function doMenuBlockTests($menu_name, $menu_title) {

    // Add nodes to use as links for menu links.
    $node1 = $this->backdropCreateNode(array('type' => 'post'));
    $node2 = $this->backdropCreateNode(array('type' => 'post'));
    $node3 = $this->backdropCreateNode(array('type' => 'post'));
    $node4 = $this->backdropCreateNode(array('type' => 'post'));
    $node5 = $this->backdropCreateNode(array('type' => 'post'));

    // Add menu links.
    $item1 = $this->addMenuLink($menu_name, 0);
    $item2 = $this->addMenuLink($menu_name, $item1['mlid'], 'node/' . $node1->nid);
    $item3 = $this->addMenuLink($menu_name, $item2['mlid'], 'node/' . $node2->nid);
    $item4 = $this->addMenuLink($menu_name, $item3['mlid'], 'node/' . $node3->nid);
    $item5 = $this->addMenuLink($menu_name, $item4['mlid'], 'node/' . $node4->nid);
    $item6 = $this->addMenuLink($menu_name, 0, 'node/' . $node5->nid);

    $this->backdropGet('admin/structure/layouts/manage/default');
    // Remove the default main-menu block to prevent mixed up checks.
    $this->clickLink(t('Remove'), 1);
    // Remove the breadcrumb prevent mixed up checks.
    $this->clickLink(t('Remove'), 1);
    // Add a block to the sidebar (the fourth region).
    $this->clickLink(t('Add block'), 3);
    $this->clickLink($menu_title);
    $edit = array();
    $this->backdropPost(NULL, $edit, t('Add block'));

    // Record the UUID for the newly added block.
    $last_block = $this->xpath('(//*[contains(@class,:region)]//*[@data-block-id])[last()]', array(
      ':region' => 'l-sidebar',
    ));
    $block_uuid = (string) $last_block[0]['data-block-id'];
    $block_edit_url = 'admin/structure/layouts/manage/default/configure-block/editor/' . $block_uuid;

    // Save the layout and return to the front page.
    $this->backdropPost(NULL, array(), t('Save layout'));
    $this->backdropGet('user');

    // Verify menu links. By default the main menu should only show first-level
    // links.
    $this->assertLink($item1['link_title']);
    $this->assertLink($item6['link_title']);
    if ($menu_name == 'main-menu') {
      $this->assertNoLink($item2['link_title']);
    }
    else {
      $this->assertLink($item2['link_title']);
    }

    // Go to the configure page and change the depth to 3.
    $this->backdropGet($block_edit_url);
    $edit = array(
      'block_settings[depth]' => 3,
    );
    $this->backdropPost(NULL, $edit, t('Update block'));

    // Save the layout and return to the front page.
    $this->backdropPost(NULL, array(), t('Save layout'));
    $this->backdropGet('user');

    // Verify level 3 links are shown, but not level 4.
    $this->assertLink($item1['link_title']);
    $this->assertLink($item2['link_title']);
    $this->assertLink($item3['link_title']);
    $this->assertLink($item6['link_title']);
    $this->assertNoLink($item4['link_title']);

    // Go to the configure page and change the depth to unlimited.
    $this->backdropGet($block_edit_url);
    $edit = array(
      'block_settings[depth]' => 0,
    );
    $this->backdropPost(NULL, $edit, t('Update block'));

    // Save the layout and return to the front page.
    $this->backdropPost(NULL, array(), t('Save layout'));
    $this->backdropGet('user');

    // Verify level 5 links are shown.
    $this->assertLink($item5['link_title']);

    // Go to the configure page and change the starting level to 2.
    $this->backdropGet($block_edit_url);
    $edit = array(
      'block_settings[level]' => 2,
    );
    $this->backdropPost(NULL, $edit, t('Update block'));

    // Save the layout and return to the front page.
    $this->backdropPost(NULL, array(), t('Save layout'));
    $this->backdropGet('user');
    $this->assertNoLink($item1['link_title']);

    // Go to the level 2 node and verify the menu links are shown.
    $this->backdropGet('node/' . $node1->nid);

    // Verify level 2 links are shown, but not level 1.
    // We use item 6 here since item 1, although not in the menu, is in the
    // breadcrumb.
    $this->assertNoLink($item6['link_title']);
    $this->assertLink($item2['link_title']);
    $this->assertLink($item3['link_title']);

    // All above tests have been done using the default "hierarchical" style.
    // Switch to the "top-only" style and check available links.
    $edit = array(
      'block_settings[style]' => 'top_only',
    );
    $this->backdropPost($block_edit_url, $edit, t('Update block'));
    $this->backdropPost(NULL, array(), t('Save layout'));

    // Verify only top level links are shown even when on a 3rd-level link.
    $this->backdropGet($item3['link_path']);
    $this->assertLink($item1['link_title']);
    $this->assertLink($item6['link_title']);
    $this->assertNoLink($item2['link_title']);
    $this->assertNoLink($item3['link_title']);
    $this->assertNoLink($item4['link_title']);
    $this->assertNoLink($item5['link_title']);

    // Switch to the "dropdown" style and check that all links are expanded, even
    // though each individual link is not expanded.
    $edit = array(
      'block_settings[style]' => 'dropdown',
    );
    $this->backdropPost($block_edit_url, $edit, t('Update block'));
    $this->backdropPost(NULL, array(), t('Save layout'));

    $this->backdropGet($item2['link_path']);
    $this->assertLink($item1['link_title']);
    $this->assertLink($item2['link_title']);
    $this->assertLink($item3['link_title']);
    $this->assertLink($item4['link_title']);
    $this->assertLink($item5['link_title']);
    $this->assertLink($item6['link_title']);
  }

  /**
   * Add a menu link using the menu module UI.
   *
   * @param integer $plid Parent menu link id.
   * @param string $link Link path.
   * @param string $menu_name Menu name.
   * @return array Menu link created.
   */
  function addMenuLink($menu_name, $plid = 0, $link = 'user') {
    // View add menu link page.
    $this->backdropGet("admin/structure/menu/manage/$menu_name/add");
    $this->assertResponse(200);

    $title = '!link_' . $this->randomName(16);
    $edit = array(
      'link_path' => $link,
      'link_title' => $title,
      'description' => '',
      'enabled' => TRUE,
      'expanded' => TRUE,
      'parent' =>  $menu_name . ':' . $plid,
      'weight' => '0',
    );

    // Add menu link.
    $this->backdropPost(NULL, $edit, t('Save'));
    $this->assertResponse(200);
    // Unlike most other modules, there is no confirmation message displayed.
    $this->assertText($title, 'Menu link was added');

    $item = db_query('SELECT * FROM {menu_links} WHERE link_title = :title', array(':title' => $title))->fetchAssoc();
    $this->assertTrue(t('Menu link was found in database.'));

    return $item;
  }
}
