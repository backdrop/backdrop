<?php
// $Id $

/**
 * @file
 * Fieldgroup module.
 *
 * Hooks
 *   hook_field_group_formats
 *     Creates a format entry for a fieldgroup.
 *     @see field_group_field_group_formats()
 */

define('FIELD_GROUP_TABS_SEPARATE', 1);
define('FIELD_GROUP_TABS_MERGED', 2);

/**
 * Implements hook_menu().
 */
function field_group_menu() {
  $items = array();

  // Ensure the following is not executed until field_bundles is working and
  // tables are updated. Needed to avoid errors on initial installation.
  if (defined('MAINTENANCE_MODE')) {
    return $items;
  }

  // Create tabs for all possible bundles.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if ($entity_info['fieldable']) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract path information from the bundle.
          $path = $bundle_info['admin']['path'];
          // Different bundles can appear on the same path (e.g. %node_type and
          // %comment_node_type). To allow field_ui_menu_load() to extract the
          // actual bundle object from the translated menu router path
          // arguments, we need to identify the argument position of the bundle
          // name string ('bundle argument') and pass that position to the menu
          // loader. The position needs to be casted into a string; otherwise it
          // would be replaced with the bundle name string.
          if (isset($bundle_info['admin']['bundle argument'])) {
            $bundle_arg = $bundle_info['admin']['bundle argument'];
            $bundle_pos = (string) $bundle_arg;
          }
          else {
            $bundle_arg = $bundle_name;
            $bundle_pos = '0';
          }

          // This is the position of the %group_ui_menu placeholder in the
          // items below.
          $group_position = count(explode('/', $path)) + 1;

          // Extract access information, providing defaults.
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $access += array(
            'access callback' => 'user_access',
            'access arguments' => array('administer site configuration'),
          );

          $items["$path/groups/%field_group_menu/edit"] = array(
            'load arguments' => array($entity_type, $bundle_arg, $bundle_pos, '%map'),
            'title' => 'Edit',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('field_group_edit_form', $group_position),
            'type' => MENU_CALLBACK,
            'file' => 'field_group.admin.inc',
          ) + $access;

          $items["$path/groups/%field_group_menu/delete"] = array(
            'load arguments' => array($entity_type, $bundle_arg, $bundle_pos, '%map'),
            'title' => 'Delete',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('field_group_delete_form', $group_position),
            'type' => MENU_CALLBACK,
            'file' => 'field_group.admin.inc',
          ) + $access;
        }
      }
    }
  }

  return $items;
}

/**
 * Implements hook_field_attach_form().
 */
function field_group_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  field_group_attach_groups($form, 'form');
}

/**
 * Implements hook_field_attach_view_alter().
 */
function field_group_field_attach_view_alter(&$element, $context) {
  // Check whether the view mode uses custom display settings or the 'default' mode.
  $view_mode_settings = field_view_mode_settings($element['#entity_type'], $element['#entity_type']);
  $view_mode = $context['view_mode'];
  $actual_mode = (!empty($view_mode_settings[$view_mode]['custom_settings']) ? $view_mode : 'default');
  field_group_attach_groups($element, $actual_mode);
}

/**
 * Implements hook_field_info_max_weight().
 */
function field_group_field_info_max_weight($entity_type, $bundle, $context) {
  $weights = array();

  foreach (field_group_info_groups($entity_type, $bundle, $context) as $group) {
    $weights[] = $group->weight;
  }

  return $weights ? max($weights) : NULL;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function field_group_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  field_group_field_ui_overview_form_alter($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function field_group_form_field_ui_display_overview_form_alter(&$form, &$form_state) {
  field_group_field_ui_overview_form_alter($form, $form_state, TRUE);
}

/**
 * Function to alter the fields overview and display overview screen.
 */
function field_group_field_ui_overview_form_alter(&$form, &$form_state, $display_overview = FALSE) {
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $admin_path = _field_ui_bundle_admin_path($entity_type, $bundle);
  $formatters = field_group_formats();

  if ($display_overview) {
    $region_callback = 'field_group_display_overview_row_region';
    $mode = $form['#view_mode'];
    $format_options = $formatters['display'];
  }
  else {
    $region_callback = 'field_group_field_overview_row_region';
    $mode = 'form';
    $format_options = $formatters['form'];
    // Overview form does not have this key by default.
    $form_state += array(
      'formatter_settings_edit' => NULL,
    );
    // Add AJAX wrapper.
    $form['fields']['#prefix'] = '<div id="field-display-overview-wrapper">';
    $form['fields']['#suffix'] = '</div>';
  }

  $groups = field_group_info_groups($entity_type, $bundle, $mode);
  $form['#groups'] = array_keys($groups);

  $table = &$form['fields'];

  // Add a region for 'add_new' rows.
  $table['#regions'] += array(
    'add_new' => array('title' => '&nbsp;'),
  );

  // Extend available parenting options.
  foreach ($groups as $name => $group) {
    $table['#parent_options'][$name] = $group->label;
  }
  $table['#parent_options']['_add_new_group'] = t('Add new group');

  // Gather parenting data, and update existing rows accordingly.
  $parents = array();
  foreach ($groups as $name => $group) {
    foreach ($group->children as $child) {
      $parents[$child] = $name;
    }
  }
  foreach (element_children($table) as $name) {
    $row = &$table[$name];
    $row['parent_wrapper']['parent']['#options'] = $table['#parent_options'];
    $row['parent_wrapper']['parent']['#default_value'] = isset($parents[$name]) ? $parents[$name] : '';
  }

  // Group rows.
  foreach (array_keys($groups) as $name) {

    $group = & $groups[$name];
    if (!empty($form_state['values']['fields'][$name]['format']['type'])) {
      $group->visible = $form_state['values']['fields'][$name]['format']['type'];
    }
    elseif (!empty($form_state['input']['fields'][$name]['format']['type'])) {
      $group->visible = $form_state['input']['fields'][$name]['format']['type'];
    }

    $id = strtr($name, '_', '-');
    $js_rows_data[$id] = array('type' => 'group', 'name' => $name);
    // A group cannot be selected as its own parent.
    $parent_options = $table['#parent_options'];
    unset($parent_options[$name]);
    $table[$name] = array(
      '#attributes' => array('class' => array('draggable', 'field-group'), 'id' => $id),
      '#row_type' => 'group',
      '#region_callback' => $region_callback,
      '#js_settings' => array('rowHandler' => 'group'),
      'human_name' => array(
        '#markup' => check_plain($group->label),
        '#prefix' => '<span class="group-label">',
        '#suffix' => '</span>',
      ),
      'weight' => array(
        '#type' => 'textfield',
        '#default_value' => $group->weight,
        '#size' => 3,
        '#attributes' => array('class' => array('field-weight')),
      ),
      'parent_wrapper' => array(
        'parent' => array(
          '#type' => 'select',
          '#options' =>  $parent_options,
          '#empty_value' => '',
          '#default_value' => isset($parents[$name]) ? $parents[$name] : '',
          '#attributes' => array('class' => array('field-parent')),
          '#parents' => array('fields', $name, 'parent'),
        ),
        'hidden_name' => array(
          '#type' => 'hidden',
          '#default_value' => $name,
          '#attributes' => array('class' => array('field-name')),
        ),
      ),
    );

    $table[$name] += array(
      'label' => array(),
      'format' => array(
        'type' => array(
          '#type' => 'select',
          '#options' => $format_options,
          '#default_value' => $group->visible,
          '#attributes' => array('class' => array('field-group-type')),
        ),
      ),
    );

    $base_button = array(
      '#submit' => array('field_ui_display_overview_multistep_submit'),
      '#ajax' => array(
        'callback' => 'field_ui_display_overview_multistep_js',
        'wrapper' => 'field-display-overview-wrapper',
        'effect' => 'fade',
      ),
      '#field_name' => $name,
    );

    if ($form_state['formatter_settings_edit'] == $name) {
      $table[$name]['format']['#cell_attributes'] = array('colspan' => 3);
      $table[$name]['format']['format_settings'] = array(
        '#type' => 'container',
        '#attributes' => array('class' => array('field-formatter-settings-edit-form')),
        '#parents' => array('fields', $name, 'format_settings'),
        'label' => array(
          '#markup' => ' <span class="formatter-name">' . $formatter['label'] . '</span>',
        ),
        // Create a settings form where hooks can pick in.
        'settings' => field_group_format_settings_form($group),
        'actions' => array(
          '#type' => 'actions',
          'save_settings' => $base_button + array(
            '#type' => 'submit',
            '#name' => $name . '_formatter_settings_update',
            '#value' => t('Update'),
            '#op' => 'update',
          ),
          'cancel_settings' => $base_button + array(
            '#type' => 'submit',
            '#name' => $name . '_formatter_settings_cancel',
            '#value' => t('Cancel'),
            '#op' => 'cancel',
            // Do not check errors for the 'Cancel' button.
            '#limit_validation_errors' => array(),
          ),
        ),
      );
      $table[$name]['#attributes']['class'][] = 'field-formatter-settings-editing';
    }
    else {
      // Save the (re)configured formatter on the fieldgroup.
      if (isset($form_state['values']['fields'][$name]) && !empty($form_state['values'][$name .'_formatter_settings_update'])) {
        field_group_format_settings_submit($group, $form_state['values']['fields'][$name]);
      }
      // After saving, the settings are updated here aswell.
      if (!empty($group->format_settings)) {
        $table[$name]['settings_summary'] = field_group_format_settings_summary($name, $group);
      }
      $table[$name]['settings_edit'] = $base_button + array(
        '#type' => 'image_button',
        '#name' => $name . '_group_settings_edit',
        '#src' => 'misc/configure.png',
        '#attributes' => array('class' => array('field-formatter-settings-edit'), 'alt' => t('Edit')),
        '#op' => 'edit',
        // Do not check errors for the 'Edit' button.
        '#limit_validation_errors' => array(),
        '#prefix' => '<div class="field-formatter-settings-edit-wrapper">',
        '#suffix' => '</div>',
      );
    }

    // @todo if we use the settings, we might as well remove edit
    // and move delete to the settings ?
//    $table[$name] += array(
//      'edit' => array(
//        '#markup' => l(t('edit'), $admin_path . '/groups/' . $name . '/edit'),
//      ),
//      'delete' => array(
//        '#markup' => l(t('delete'), $admin_path . '/groups/' . $name . '/delete'),
//      ),
//    );
  }

  // Additional row: add new group.
  $name = '_add_new_group';
  // A group cannot be selected as its own parent.
  $parent_options = $table['#parent_options'];
  unset($parent_options[$name]);
  $table[$name] = array(
    '#attributes' => array('class' => array('draggable', 'field-group', 'add-new')),
    '#row_type' => 'add_new_group',
    '#js_settings' => array('rowHandler' => 'group'),
    '#region_callback' => $region_callback,
    'label' => array(
      '#type' => 'textfield',
      '#size' => 15,
      '#description' => t('Label'),
      '#prefix' => '<div class="label-input"><div class="add-new-placeholder">' . t('Add new group') .'</div>',
      '#suffix' => '</div>',
    ),
    'weight' => array(
      '#type' => 'textfield',
      '#default_value' => field_info_max_weight($entity_type, $bundle, $mode) + 3,
      '#size' => 3,
      '#title_display' => 'invisible',
      '#title' => t('Weight for new group'),
      '#attributes' => array('class' => array('field-weight')),
      '#prefix' => '<div class="add-new-placeholder">&nbsp;</div>',
    ),
    'parent_wrapper' => array(
      'parent' => array(
        '#type' => 'select',
        '#options' => $parent_options,
        '#empty_value' => '',
        '#attributes' => array('class' => array('field-parent')),
        '#prefix' => '<div class="add-new-placeholder">&nbsp;</div>',
        '#parents' => array('fields', $name, 'parent'),
      ),
      'hidden_name' => array(
        '#type' => 'hidden',
        '#default_value' => $name,
        '#attributes' => array('class' => array('field-name')),
      ),
    ),
    'group_name' => array(
      '#type' => 'textfield',
      // This field should stay LTR even for RTL languages.
      '#field_prefix' => '<span dir="ltr">group_',
      '#field_suffix' => '</span>&lrm;',
      '#attributes' => array('dir'=>'ltr'),
      '#size' => 15,
      '#description' => t('Group name (a-z, 0-9, _)'),
      '#prefix' => '<div class="add-new-placeholder">&nbsp;</div>',
      '#cell_attributes' => array('colspan' => $display_overview ? 1 : 2),
    ),
  );
  $table[$name] += array(
    'format' => array(
      'type' => array(
        '#type' => 'select',
        '#options' => $format_options,
        '#default_value' => 'fieldset',
      ),
    ),
    'settings_summary' => array(),
    'settings_edit' => array(),
  );

  $form['#attached']['css'][] = drupal_get_path('module', 'field_group') . '/field_group.css';
  $form['#attached']['js'][] = drupal_get_path('module', 'field_group') . '/field_group_admin.js';

  $form['#validate'][] = 'field_group_field_overview_validate';
  $form['#submit'][] = 'field_group_field_overview_submit';
}

/**
 * Implements hook_field_group_formats().
 * @return array of available formatting html controls
 * for form and display overview type.
 */
function field_group_field_group_formats() {
  return array(
    'form' => array(
      'fieldset' => t('Fieldset'),
      'tabs' => t('Tabs')
    ),
    'display' => array(
      'div' => t('Div'),
      'fieldset' => t('Fieldset'),
    ),
  );
}

/**
 * Implements hook_field_group_pre_render().
 * @param Array $elements by address.
 * @param Object $group The Field group info.
 */
function field_group_field_group_pre_render(& $element, $group, & $form) {
  $collapsible = $group->format_settings['fieldgroup_settings'] != 'open';
  $collapsed = $group->format_settings['fieldgroup_settings'] == 'collapsed';
  $classes = array($group->visible);
  if ($collapsible) {
    $classes[] = 'collapsible';
    if ($collapsed) {
      $classes[] = 'collapsed';
    }
  }

  switch ($group->visible) {
    case 'tabs':
      $tab_container = $group->format_settings['tab_settings'] == FIELD_GROUP_TABS_SEPARATE ? 'form-layout' : 'additional_settings';
      $element += array(
        '#type' => 'fieldset',
        '#title' => $group->label,
        '#weight' => $group->weight,
        '#collapsible' => $collapsible,
        '#collapsed' => $collapsed,
        '#attributes' => array('class' => array($group->visible)),
        '#group' => $tab_container,
      );
      $form[$tab_container] = array('#type' => 'vertical_tabs');
    break;
    case 'fieldset':
      $element += array(
        '#type' => 'fieldset',
        '#title' => $group->label,
        '#weight' => $group->weight,
        '#collapsible' => $collapsible,
        '#collapsed' => $collapsed,
        '#pre_render' => array(),
        '#attributes' => array('class' => $classes),
      );
      $element['#attached']['js'][] = 'misc/form.js';
      $element['#attached']['js'][] = 'misc/collapse.js';
      break;
    case 'div':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '<div class="field-group-format '. implode(' ', $classes) . '">
        <span class="field-group-format-toggler">'. $group->label .'</span>
        <div class="field-group-format-wrapper" style="display: '. ($collapsed ? 'none' : 'block') .';">',
        '#suffix' => '</div></div>',
        '#weight' => $group->weight,
        '#attached' => array(
          'js' => array(
            'misc/collapse.js',
            drupal_get_path('module', 'field_group') .'/field_group.js'
          ),
        ),
      );
      break;
  }
}

/**
 * Implements hook_field_group_format_settings().
 * @var unknown_type
 */
function field_group_field_group_format_settings(& $group) {
  $form = array();
  switch ($group->visible) {
    case 'tabs':
      $form['tab_settings'] = array(
        '#title' => t('Tab settings'),
        '#type' => 'select',
        '#default_value' => $group->format_settings['tab_settings'],
        '#options' => array(
          FIELD_GROUP_TABS_SEPARATE => t('Seperate from core fieldsets'),
          FIELD_GROUP_TABS_MERGED => t('Merged with core fieldsets')),
        '#weight' => 2,
      //'#description' => t('Vivamus nec magna vel lectus congue eleifend. Mauris dapibus erat eu tortor gravida ut suscipit dui tincidunt.'),
      );
    // Fall through to add extra tabs configuration.
    case 'fieldset':
    case 'div':
      $form['fieldgroup_settings'] = array(
        '#title' => t('Fieldgroup settings'),
        '#type' => 'select',
        '#options' => array(
          'open' => t('Open'),
          'collapsible' => t('Collapsible'),
          'collapsed' => t('Collapsed'),
        ),
        '#default_value' => $group->format_settings['fieldgroup_settings'],
        '#weight' => 1,
        //'#element_validate' => array('_element_validate_integer_positive'),
        //'#description' => t('Some longish description. Lorem ipsum dolor sit amet, consectetur adipiscing elit'),
        //'#required' => TRUE,
      );
      break;
  }
  return $form;
}

/**
 * Implements hook_field_group_format_summary().
 */
function field_group_field_group_format_summary(& $group) {
  $output = '<strong>'. $group->visible .'</strong> '. $group->format_settings['fieldgroup_settings'] .'';
  if ($group->visible == 'tabs') {
    $options = array(
      FIELD_GROUP_TABS_SEPARATE => t('Seperate from core fieldsets'),
      FIELD_GROUP_TABS_MERGED => t('Merged with core fieldsets'));
    $output .= '<br />'. t('Tabs') .': ' . (isset($options[$group->format_settings['tab_settings']]) ? $options[$group->format_settings['tab_settings']] : t('No option selected'));
  }
  return $output;
}

/**
 * Menu loader; Load a group instance based on group and bundle name.
 *
 * @param $group_name
 *   The name of the group, as contained in the path.
 * @param $entity_type
 *   The name of the entity.
 * @param $bundle_name
 *   The name of the bundle, as contained in the path.
 * @param $bundle_pos
 *   The position of $bundle_name in $map.
 * @param $map
 *   The translated menu router path argument map.
 */
function field_group_menu_load($group_name, $entity_type, $bundle_name, $bundle_pos, $map) {
  // @todo : this is broken - loads (and thus edits / deletes) a group only by group name,
  // which is not unique.
  // A unique group is identified by a [entity_type, bundle, group_name, view_mode] tuple.
  // But sticking that much info in the menu path might be a bit long...
  // Tricky stuff, I'll try to look into this - yched.
  $query = db_select('field_group', 'fg');
  $query->fields('fg');
  $query->condition('group_name', $group_name);
  $group = $query->execute()->fetchObject();
  if ($group->id) {
    // @todo should happen in a proper CRUD API function
    $data = unserialize($group->data);
    unset($group->data);
    $group->label = $data['label'];
    $group->weight = $data['weight'];
    $group->children = $data['children'];
    $group->visible = $data['visible'];

    return $group;
  }
  return FALSE;
}

/**
 * Read all groups.
 */
function field_group_read_groups($params = array()) {
  $groups = array();

  $query = db_select('field_group', 'fg');
  $query->fields('fg');

  // Turn the conditions into a query.
  foreach ($params as $key => $value) {
    $query->condition($key, $value);
  }

  $results = $query->execute();
  foreach ($results as $group) {
    // Extract unserialized data.
    $data = unserialize($group->data);
    unset($group->data);
    $group->label = $data['label'];
    $group->weight = $data['weight'];
    $group->children = $data['children'];
    $group->visible = $data['visible'];
    if (isset($data['format_settings'])) {
      $group->format_settings = $data['format_settings'];
    }

    $groups[$group->entity_type][$group->bundle][$group->mode][$group->group_name] = $group;
  }

  return $groups;
}

/**
 * Get all groups.
 *
 * @param $entity_type
 *   The name of the entity.
 * @param $bundle
 *   The name of the bundle.
 * @param $view_mode
 *   The view mode.
 * @param $reset.
 *   Whether to reset the cache or not.
 */
function field_group_info_groups($entity_type = NULL, $bundle = NULL, $view_mode = NULL, $reset = FALSE) {
  static $groups = FALSE;

  if (!$groups || $reset) {
    if ($cached = cache_get('field_groups', 'cache_field')) {
      $groups = $cached->data;
    }
    else {
      $groups = field_group_read_groups();
      cache_set('field_groups', $groups, 'cache_field');
    }
  }

  if (!isset($entity_type)) {
    return $groups;
  }
  else {
    if (isset($groups[$entity_type][$bundle][$view_mode])) {
      return $groups[$entity_type][$bundle][$view_mode];
    }
    else {
      return array();
    }
  }
}

/**
 * Saves a group definition.
 *
 * @param $group
 *   A group definition.
 */
function field_group_save(&$group) {
  // Prepare the record.
  $record = clone $group;
  $record->data = array(
    'label' => $record->label,
    'weight' => $record->weight,
    'children' => $record->children,
    // @todo rename to format ? And how to select format/theming on manage fields screen?
    // Depends on what we will do with Display Suite. If we take on this challenge,
    // maybe fieldgroups are a very explicable and extendable replacement for object-regions.
    // - Stalski
    'visible' => $record->visible,
  );
  if (isset($record->format_settings)) {
    $record->data['format_settings'] = $record->format_settings;
  }

  if (isset($record->id)) {
    drupal_write_record('field_group', $record, array('id'));
  }
  else {
    drupal_write_record('field_group', $record);
    $group->id = $record->id;
  }
}

/**
 * Function to retrieve all format possibilities for the fieldgroups.
 */
function field_group_formats($display_overview = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array());
  if (empty($cache)) {
    if ($cached = cache_get('field_group_formats', 'cache_field')) {
      $format_options = $cached->data;
    }
    else {
      $format_options = array('hidden' => t('<Hidden>'));
      $format_options += module_invoke_all('field_group_formats');
      cache_set('field_group_formats', $format_options, 'cache_field');
    }
    $cache = $format_options;
  }
  return $cache;
}

/**
 * Process/ Pre-render callback.
 * Depending on whether it is a form build or content build.
 * Form api go through more than a regular build. #process is
 * needed here, where #pre_render is ideal for the regular array.
 * @see called by field_group_attach_groups().
 * @see calls field_group_nest_fields().
 * @param $element Form element
 * @return $element Array with re-arranged fields in forms.
 */
function field_group_fields_process($element) {
  // Nest the fields in the corresponding field groups.
  field_group_nest_fields($element, $element);
  if (isset($element['#node_edit_form'])) {
    $element['menu']['#weight'] = 40;
    $element['revision_information']['#weight'] = 40;
    $element['path']['#weight'] = 40;
  }

  return $element;
}

/**
 * Function to pre render the field group element.
 * @see called by field_group_nest_fields().
 * @param $element Array of group element that needs to be created!
 * @param $group Object with the group information.
 * @param $form The form object itself.
 */
function field_group_pre_render(& $element, $group, & $form) {
  foreach (module_implements('field_group_pre_render') as $module) {
    $function = $module . '_field_group_pre_render';
    if (function_exists($function)) {
      // The intention here is to have the opportunity to alter the
      // elements, as defined in hook_field_group_formats.
      // Note, implement $element by reference!
      $function($element, $group, $form);
    }
  }
}

/**
 * Creates a form for field_group formatters.
 * @param Object $group The FieldGroup object.
 */
function field_group_format_settings_form(&$group) {
  $form = array();
  $form += module_invoke_all('field_group_format_settings', $group);
  return $form;
}

/**
 * Submit handler to save the configuration of a fieldgroup.
 * @param Ojbect $group The group object
 * @param Array $settins Configuration settings
 */
function field_group_format_settings_submit(& $group, $settings) {
  $group->visible = $settings['format']['type'];
  $group->format_settings = $settings['format_settings']['settings'];
  field_group_save($group);
  cache_clear_all('field_groups', 'cache_field');
}

/**
 * Creates a summary for the field format configuration summary.
 * @param String $group_name The name of the group
 * @param Object $group The group object
 * @return Array ready to be rendered.
 */
function field_group_format_settings_summary($group_name, $group) {
  $summary = implode('', module_invoke_all('field_group_format_summary', $group));
  return array(
    '#markup' => '<div class="field-formatter-summary">'. $summary .'</div>',
    '#cell_attributes' => array('class' => array('field-formatter-summary-cell')),
  );
}

/**
 * Validate handler for the overview screens.
 * @param Array $form The complete form.
 * @param Array $form_state The state of the form.
 */
function field_group_field_overview_validate($form, &$form_state) {
  $form_values = $form_state['values']['fields'];
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $mode = (isset($form['#view_mode']) ? $form['#view_mode'] : 'form');

  $group = $form_values['_add_new_group'];

  // Validate if any information was provided in the 'add new group' row.
  if (array_filter(array($group['label'], $group['group_name']))) {
    // Missing label.
    if (!$group['label']) {
      form_set_error('fields][_add_new_group][label', t('Add new group: you need to provide a label.'));
    }

    // Missing group name.
    if (!$group['group_name']) {
      form_set_error('fields][_add_new_group][group_name', t('Add new group: you need to provide a group name.'));
    }
    // Group name validation.
    else {
      $group_name = $group['group_name'];

      // Add the 'group_' prefix.
      if (substr($group_name, 0, 6) != 'group_') {
        $group_name = 'group_' . $group_name;
        form_set_value($form['fields']['_add_new_group']['group_name'], $group_name, $form_state);
      }

      // Invalid group name.
      if (!preg_match('!^group_[a-z0-9_]+$!', $group_name)) {
        form_set_error('fields][_add_new_group][group_name', t('Add new group: the group name %group_name is invalid. The name must include only lowercase unaccentuated letters, numbers, and underscores.', array('%group_name' => $group_name)));
      }
      if (strlen($group_name) > 32) {
        form_set_error('fields][_add_new_group][group_name', t("Add new group: the group name %group_name is too long. The name is limited to 32 characters, including the 'group_' prefix.", array('%group_name' => $group_name)));
      }

      // Group name already exists.
      $groups = field_group_read_groups();
      if (!empty($groups[$entity_type][$bundle][$mode][$group_name])) {
        form_set_error('fields][_add_new_group][group_name', t('Add new group: the group name %group_name already exists.', array('%group_name' => $group_name)));
      }
    }
  }
}

/**
 * Submit handler for the overview screens.
 * @param Array $form The complete form.
 * @param Array $form_state The state of the form.
 */
function field_group_field_overview_submit($form, &$form_state) {
  $form_values = $form_state['values']['fields'];
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $mode = (isset($form['#view_mode']) ? $form['#view_mode'] : 'form');

  // Collect children.
  $children = array_fill_keys($form['#groups'], array());
  foreach ($form_values as $name => $value) {
    if (!empty($value['parent'])) {
      // Substitute newly added fields, in case they were dragged directly in a
      // group.
      if ($name == '_add_new_field' && isset($form_state['fields_added']['_add_new_field'])) {
        $name = $form_state['fields_added']['_add_new_field'];
      }
      elseif ($name == '_add_existing_field' && isset($form_state['fields_added']['_add_existing_field'])) {
        $name = $form_state['fields_added']['_add_existing_field'];
      }
      $children[$value['parent']][$name] = $name;
    }
  }

  // Create new group.
  if (!empty($form_values['_add_new_group']['group_name'])) {
    $values = $form_values['_add_new_group'];
    $new_group = (object) array(
      'group_name' => $values['group_name'],
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'mode' => $mode,
      'children' => isset($children['_add_new_group']) ? array_keys($children['_add_new_group']) : array(),
      'parent_name' => $values['parent'],
      'weight' => $values['weight'],
      'label' => $values['label'],
      // @todo currently not present in 'Manage Fields' screen.
      'visible' => isset($values['format']['type']) ? $values['format']['type'] : 'visible',
    );
    field_group_save($new_group);

    // Store new group information for any additional submit handlers.
    $form_state['groups_added']['_add_new_group'] = $new_group->group_name;

    drupal_set_message(t('New group %label succesfully created.', array('%label' => $new_group->label)));

    // Replace the newly created group in the $children array, in case it was
    // dragged directly in an existing field.
    foreach (array_keys($children) as $parent) {
      if (isset($children[$parent]['_add_new_group'])) {
        unset($children[$parent]['_add_new_group']);
        $children[$parent][$new_group->group_name] = $new_group->group_name;
      }
    }
  }

  $groups = field_group_info_groups($entity_type, $bundle, $mode, TRUE);

  // Update existing groups.
  foreach ($form['#groups'] as $group_name) {
    $group = $groups[$group_name];
    $group->children = array_keys($children[$group_name]);
    $group->parent_name = $form_values[$group_name]['parent'];
    $group->weight = $form_values[$group_name]['weight'];
    $group->visible = isset($form_values[$group_name]['format']['type']) ? $form_values[$group_name]['format']['type'] : 'visible';
    field_group_save($group);
  }

  cache_clear_all('field_groups', 'cache_field');
}

/**
 * Returns the region to which a row in the 'Manage fields' screen belongs.
 * @param Array $row A field or field_group row
 * @return String the current region.
 */
function field_group_field_overview_row_region($row) {
  switch ($row['#row_type']) {
    case 'group':
      return 'main';
    case 'add_new_group':
      // If no input in 'label', assume the row has not been dragged out of the
      // 'add new' section.
      if (empty($row['label']['#value'])) {
        return 'add_new';
      }
      return 'main';
  }
}

/**
 * Returns the region to which a row in the 'Manage display' screen belongs.
 * @param Array $row A field or field_group row
 * @return String the current region.
 */
function field_group_display_overview_row_region($row) {
  switch ($row['#row_type']) {
    case 'group':
      return ($row['format']['type']['#value'] == 'hidden' ? 'hidden' : 'visible');
    case 'add_new_group':
      // If no input in 'label', assume the row has not been dragged out of the
      // 'add new' section.
      if (empty($row['label']['#value'])) {
        return 'add_new';
      }
      return ($row['format']['type']['#value'] == 'hidden' ? 'hidden' : 'visible');
  }
}

/**
 * Attach groups to the (form) build.
 * @param Array $element The part of the form.
 * @param String $view_mode The mode for the build.
 */
function field_group_attach_groups(&$element, $view_mode) {
  $entity_type = $element['#entity_type'];
  $bundle = $element['#bundle'];

  $element['#groups'] = field_group_info_groups($entity_type,$bundle, $view_mode);

  // Create a lookup array.
  $group_children = array();
  foreach ($element['#groups'] as $group_name => $group) {
    foreach ($group->children as $child) {
      $group_children[$child] = $group_name;
    }
  }
  $element['#group_children'] = $group_children;

  // Add a pre render or process callback.
  $element[$view_mode == 'form' ? '#process': '#pre_render'][] = 'field_group_fields_process';
}

/**
 * Recursive function to nest fields in the field groups.
 * @param Array $element
 *   The current element to analyse for grouping.
 * @param Array $root_element
 *   The root element to control.
 * @param String $parent
 *   the parent name to look for in each level.
 */
function field_group_nest_fields(&$element, &$root_element, $parent = NULL) {
  $groups = $root_element['#groups'];
  $group_fields = $root_element['#group_children'];

  foreach ($groups as $group_name => $group) {

    // Add fieldgroups to the current element.
    if ((empty($group->parent_name) && !isset($parent)) || $parent == $group->parent_name) {
      // Bring extra element wrappers to achieve a grouping of fields.
      // This will mainly be prefix and suffix altering.
      // We need some kind of processor, callback or prerender thing,
      // to be able to alter the form structure (E.g. in case of tabs)
      $element[$group_name] = array();

      field_group_pre_render($element[$group_name], $group, $root_element);

      foreach ($group_fields as $groupfield => $groupname) {
        // Stash the field in the group.
        if ($groupname == $group_name && isset($root_element[$groupfield])) {
          $element[$group_name][$groupname][$groupfield] = $root_element[$groupfield];
          unset($root_element[$groupfield]);
          unset($root_element['#group_children'][$groupfield]);
        }
      }

      //unset($root_element['#groups'][$group_name]);
      field_group_nest_fields($element[$group_name], $root_element, $group_name);
    }
  }
}


// @todo experiments with setting & summary.

// This does work partially (trying to find out how to save the settings)
// since we check on the form_state just like field_ui.admin.inc does. Not sure if
// we should do that like this, seems like much overhead (although I can't see
// any other way to do that). Should be documented to developers.
//
// The irony of all this is that if we treat fieldgroups as fields
// all this stuff would work out of the box and we could use
// formatters_info & all those hooks (but there should be  a way to tell
// field api that this field will not store any data)

// (YC) Groups are not fields, I don't think we can or should treat them that way.
// You cannot add fields from the 'Manage display' screens - but you can add groups.

// Also, are those settings and summary forms extendable or not from
// other modules. Just thinking how for example I'd like to add
// a Styles select box to every field/fieldgroup from the Display Suite
// module. (I guess form alter should, but will it save also - need to investigate myself)
//
// Maybe this isn't necessary at all and all settings
// should be moved to the edit screen of a field group
// I think it depends whether we want to make it possible to let
// other module developers extend on this field group module to
// add different kinds of fieldgroups or not ...
// Moving it to the edit screen however makes the flow of
// managing your display/form a bit slower.

// (YC) We do want to let other modules add other group 'flavors'. Those then become
// a lot like field formatters. Declared through hook_fieldgroup_formatter_info(),
// with settings and a default value for each setting.
// Field_group.module defines the basic ones :
// - regular group (settings: 'fieldset open', 'collapsible', 'collapsed'),
// - tabs container (settings: 'default tab' ?),
// - VT container ?
// - accordion container ?
// Then each module declaring its group formatters is responsible for providing
// the corresponding settings form and settings summary.
// The 'format' dropdown select lets users pick a group formatter amongst all available formats.

// Or, every possible configuration (like fieldset collapsible, collapsed, open
// must be an option in the formatters $options above.
//
// So as some sort conclusion, these settings stuff should have
// some helper functions to make it easier for other devs I think,
// because you need a duplicate a lot of code and is pretty dangerous
// when Drupal core gets updates

// (YC) Tricky :-/

// (YC) We should probably move the discussion to http://drupal.org/node/824812 :-)
