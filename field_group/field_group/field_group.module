<?php
// $Id$

/**
 * @file
 * Fieldgroup module.
 *
 *   PHP HOOKS
 *
 *   hook_field_group_formats()
 *     Creates a format entry for a fieldgroup.
 *     @see field_group_field_group_formats()
 *
 *   hook_field_group_format_settings
 *     Creates a form for the fieldgroup settings of the current group.
 *
 *   hook_field_group_format_summary
 *     Creates a summary for the current group.
 *
 *   hook_field_group_pre_render()
 *     Create an element for the field group
 *
 *   hook_field_group_pre_render_alter()
 *     Gives the opportunity to do extra things for
 *     some format cases.
 *
 *   JAVASCRIPT HOOKS
 *
 *   Drupal.FieldGroup.Effects.processHook.execute()
 *
 *
 */

/**
 * Implements hook_menu().
 */
function field_group_menu() {
  $items = array();

  // Ensure the following is not executed until field_bundles is working and
  // tables are updated. Needed to avoid errors on initial installation.
  if (defined('MAINTENANCE_MODE')) {
    return $items;
  }

  // Create tabs for all possible bundles.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if ($entity_info['fieldable']) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract path information from the bundle.
          $path = $bundle_info['admin']['path'];
          // Different bundles can appear on the same path (e.g. %node_type and
          // %comment_node_type). To allow field_ui_menu_load() to extract the
          // actual bundle object from the translated menu router path
          // arguments, we need to identify the argument position of the bundle
          // name string ('bundle argument') and pass that position to the menu
          // loader. The position needs to be casted into a string; otherwise it
          // would be replaced with the bundle name string.
          if (isset($bundle_info['admin']['bundle argument'])) {
            $bundle_arg = $bundle_info['admin']['bundle argument'];
            $bundle_pos = (string) $bundle_arg;
          }
          else {
            $bundle_arg = $bundle_name;
            $bundle_pos = '0';
          }

          // This is the position of the %group_ui_menu placeholder in the
          // items below.
          $group_position = count(explode('/', $path)) + 1;

          // Extract access information, providing defaults.
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $access += array(
            'access callback' => 'user_access',
            'access arguments' => array('administer site configuration'),
          );

          $items["$path/groups/%field_group_menu/delete"] = array(
            'load arguments' => array($entity_type, $bundle_arg, $bundle_pos, '%map'),
            'title' => 'Delete',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('field_group_delete_form', $group_position),
            'type' => MENU_CALLBACK,
            'file' => 'field_group.admin.inc',
          ) + $access;
        }
      }
    }
  }

  return $items;
}

/**
 * Implements hook_features_api().
 */
function field_group_features_api() {
  module_load_include('inc', 'field_group', 'field_group.features');
  return _field_group_features_api();
}

/**
 * Implements hook_field_attach_form().
 */
function field_group_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  field_group_attach_groups($form, 'form');
}

/**
 * Implements hook_field_attach_view_alter().
 */
function field_group_field_attach_view_alter(&$element, $context) {
  // Check whether the view mode uses custom display settings or the 'default' mode.
  $view_mode_settings = field_view_mode_settings($element['#entity_type'], $element['#entity_type']);
  $view_mode = $context['view_mode'];
  $actual_mode = (!empty($view_mode_settings[$view_mode]['custom_settings']) ? $view_mode : 'default');
  field_group_attach_groups($element, $actual_mode);
}

/**
 * Implements hook_field_info_max_weight().
 */
function field_group_field_info_max_weight($entity_type, $bundle, $context) {
  $weights = array();

  foreach (field_group_info_groups($entity_type, $bundle, $context) as $group) {
    $weights[] = $group->weight;
  }

  return $weights ? max($weights) : NULL;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function field_group_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  field_group_field_ui_overview_form_alter($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function field_group_form_field_ui_display_overview_form_alter(&$form, &$form_state) {
  field_group_field_ui_overview_form_alter($form, $form_state, TRUE);
}

/**
 * Helper function to get the form parameters to use while
 * building the fields and display overview form.
 */
function field_group_field_ui_form_params($form, $display_overview) {

  $params = new stdClass();
  $params->entity_type = $form['#entity_type'];
  $params->bundle = $form['#bundle'];
  $params->admin_path = _field_ui_bundle_admin_path($params->entity_type, $params->bundle);
  $params->display_overview = $display_overview;

  $formatters = field_group_formats();

  if ($display_overview) {
    $params->region_callback = 'field_group_display_overview_row_region';
    $params->mode = $form['#view_mode'];
    $params->format_options = $formatters['display'];
  }
  else {
    $params->region_callback = 'field_group_field_overview_row_region';
    $params->mode = 'form';
    $params->format_options = $formatters['form'];
  }

  $params->groups = field_group_info_groups($params->entity_type, $params->bundle, $params->mode, TRUE);

  // Gather parenting data.
  $params->parents = array();
  foreach ($params->groups as $name => $group) {
    foreach ($group->children as $child) {
      $params->parents[$child] = $name;
    }
  }

  return $params;
}

/**
 * Function to alter the fields overview and display overview screen.
 */
function field_group_field_ui_overview_form_alter(&$form, &$form_state, $display_overview = FALSE) {

  $params = field_group_field_ui_form_params($form, $display_overview);

  if (!$display_overview) {
    // Overview form does not have this key by default.
    $form_state += array(
      'formatter_settings_edit' => NULL,
    );
    // Add AJAX wrapper.
    $form['fields']['#prefix'] = '<div id="field-display-overview-wrapper">';
    $form['fields']['#suffix'] = '</div>';
  }
  $form['#groups'] = array_keys($params->groups);

  $table = &$form['fields'];

  // Add a region for 'add_new' rows.
  $table['#regions'] += array(
    'add_new' => array('title' => '&nbsp;'),
  );

  // Extend available parenting options.
  foreach ($params->groups as $name => $group) {
    $table['#parent_options'][$name] = $group->label;
  }
  $table['#parent_options']['_add_new_group'] = t('Add new group');

  // Update existing rows accordingly to the parents.
  foreach (element_children($table) as $name) {
    $table[$name]['parent_wrapper']['parent']['#options'] = $table['#parent_options'];
    $table[$name]['parent_wrapper']['parent']['#default_value'] = isset($params->parents[$name]) ? $params->parents[$name] : '';
  }
  // Update rows that are made visible (dragged/selected out of hidden).
  //if (isset($_POST['refresh_rows']) && $_POST['refresh_rows'] == $name && isset($_POST['fields'][$_POST['refresh_rows']]['type'])) {
  //  $params->parents[$name] = '';
  //  // override the #value because at this point in this context, #default_value is too late.
  //  $table[$name]['parent_wrapper']['parent']['#value'] = $params->parents[$name];
  //}

  // Create the group rows and check actions.
  foreach (array_keys($params->groups) as $name) {

    $group = & $params->groups[$name];

    // Formatter settings.

    // Check the currently selected formatter, and merge persisted values for
    // formatter settings for the group.
    // This needs to be done first, so all fields are updated before creating elements.
    if (isset($form_state['values']['fields'][$name])) {
      if (!empty($form_state['values']['fields'][$name]['format']['type'])) {
        $formatter_type = $form_state['values']['fields'][$name]['format']['type'];
      }
      elseif (!empty($form_state['input']['fields'][$name]['format']['type'])) {
        $formatter_type = $form_state['input']['fields'][$name]['format']['type'];
      }
      else {
        $formatter_type = $group->visible;
      }
      // If the region has been updated because of a format selection,
      // load the format defaults.
      if ($formatter_type != $group->visible) {
        $group->visible = $formatter_type;
        field_group_format_settings_submit($group, $form_state['values']['fields'][$name], TRUE);
      }
      // Save the group when the configuration is submitted.
      if (!empty($form_state['values'][$name .'_formatter_settings_update'])) {
        field_group_format_settings_submit($group, $form_state['values']['fields'][$name]);
      }
    }

    $settings = field_group_format_settings_form($group);

    $id = strtr($name, '_', '-');
    $js_rows_data[$id] = array('type' => 'group', 'name' => $name);
    // A group cannot be selected as its own parent.
    $parent_options = $table['#parent_options'];
    unset($parent_options[$name]);
    $table[$name] = array(
      '#attributes' => array('class' => array('draggable', 'field-group'), 'id' => $id),
      '#row_type' => 'group',
      '#region_callback' => $params->region_callback,
      '#js_settings' => array('rowHandler' => 'group'),
      'human_name' => array(
        '#markup' => check_plain($group->label),
        '#prefix' => '<span class="group-label">',
        '#suffix' => '</span>',
      ),
      'weight' => array(
        '#type' => 'textfield',
        '#default_value' => $group->weight,
        '#size' => 3,
        '#attributes' => array('class' => array('field-weight')),
      ),
      'parent_wrapper' => array(
        'parent' => array(
          '#type' => 'select',
          '#options' =>  $parent_options,
          '#empty_value' => '',
          '#default_value' => isset($params->parents[$name]) ? $params->parents[$name] : '',
          '#attributes' => array('class' => array('field-parent')),
          '#parents' => array('fields', $name, 'parent'),
        ),
        'hidden_name' => array(
          '#type' => 'hidden',
          '#default_value' => $name,
          '#attributes' => array('class' => array('field-name')),
        ),
      ),
    );

    $table[$name] += array(
      'label' => array(),
      'format' => array(
        'type' => array(
          '#type' => 'select',
          '#options' => $params->format_options,
          '#default_value' => $group->visible,
          '#attributes' => array('class' => array('field-group-type')),
        ),
      ),
    );

    $base_button = array(
      '#submit' => array('field_ui_display_overview_multistep_submit'),
      '#ajax' => array(
        'callback' => 'field_ui_display_overview_multistep_js',
        'wrapper' => 'field-display-overview-wrapper',
        'effect' => 'fade',
      ),
      '#field_name' => $name,
    );

    if ($form_state['formatter_settings_edit'] == $name) {
      $table[$name]['format']['#cell_attributes'] = array('colspan' => $display_overview ? 3 : 3);
      $table[$name]['format']['format_settings'] = array(
        '#type' => 'container',
        '#attributes' => array('class' => array('field-formatter-settings-edit-form')),
        '#parents' => array('fields', $name, 'format_settings'),
        '#weight' => -5,
        'label' => array(
          '#markup' => t('Field group format:') .' <span class="formatter-name">'. $group->visible . '</span>',
        ),
        // Create a settings form where hooks can pick in.
        'settings' => $settings,
        'actions' => array(
          '#type' => 'actions',
          'save_settings' => $base_button + array(
            '#type' => 'submit',
            '#name' => $name . '_formatter_settings_update',
            '#value' => t('Update'),
            '#op' => 'update',
          ),
          'cancel_settings' => $base_button + array(
            '#type' => 'submit',
            '#name' => $name . '_formatter_settings_cancel',
            '#value' => t('Cancel'),
            '#op' => 'cancel',
            // Do not check errors for the 'Cancel' button.
            '#limit_validation_errors' => array(),
          ),
        ),
      );
      $table[$name]['#attributes']['class'][] = 'field-formatter-settings-editing';
      $table[$name]['format']['type']['#attributes']['class'] = array('element-invisible');
    }
    else {
      // After saving, the settings are updated here aswell.
      if (!empty($group->format_settings)) {
        $table[$name]['settings_summary'] = field_group_format_settings_summary($name, $group);
      }
      // Add the configure button.
      $table[$name]['settings_edit'] = $base_button + array(
        '#type' => 'image_button',
        '#name' => $name . '_group_settings_edit',
        '#src' => 'misc/configure.png',
        '#attributes' => array('class' => array('field-formatter-settings-edit'), 'alt' => t('Edit')),
        '#op' => 'edit',
        // Do not check errors for the 'Edit' button.
        '#limit_validation_errors' => array(),
        '#prefix' => '<div class="field-formatter-settings-edit-wrapper">',
        '#suffix' => '</div>',
      );
      if ($display_overview) {
        $table[$name]['settings_edit']['#suffix'] .= l(t('delete'), $params->admin_path . '/groups/' . $name . '/delete/' . $params->mode);
      }
    }

    if (!$display_overview) {
      $table[$name] += array(
        'delete' => array(
          '#markup' => l(t('delete'), $params->admin_path . '/groups/' . $name . '/delete/form'),
        ),
      );
    }
  }

  // Additional row: add new group.
  $parent_options = $table['#parent_options'];
  unset($parent_options['_add_new_group']);
  $table['_add_new_group'] = field_group_add_row('_add_new_group', $parent_options, $params);

  $table['_add_new_group'] += array(
    'format' => array(
      'type' => array(
        '#type' => 'select',
        '#options' => $params->format_options,
        '#default_value' => 'fieldset',
      ),
    ),
    'settings_summary' => array(),
    'settings_edit' => array(),
  );

  $form['#attached']['css'][] = drupal_get_path('module', 'field_group') . '/field_group.css';
  $form['#attached']['js'][] = drupal_get_path('module', 'field_group') . '/field_group.admin.js';

  $form['#validate'][] = 'field_group_field_overview_validate';
  $form['#submit'][] = 'field_group_field_overview_submit';
}

/**
 * Helper function to add a row in the overview forms.
 */
function field_group_add_row($name, $parent_options, $params) {
  return array(
    '#attributes' => array('class' => array('draggable', 'field-group', 'add-new')),
    '#row_type' => 'add_new_group',
    '#js_settings' => array('rowHandler' => 'group'),
    '#region_callback' => $params->region_callback,
    'label' => array(
      '#type' => 'textfield',
      '#size' => 15,
      '#description' => t('Label'),
      '#prefix' => '<div class="label-input"><div class="add-new-placeholder">' . t('Add new group') .'</div>',
      '#suffix' => '</div>',
    ),
    'weight' => array(
      '#type' => 'textfield',
      '#default_value' => field_info_max_weight($params->entity_type, $params->bundle, $params->mode) + 3,
      '#size' => 3,
      '#title_display' => 'invisible',
      '#title' => t('Weight for new group'),
      '#attributes' => array('class' => array('field-weight')),
      '#prefix' => '<div class="add-new-placeholder">&nbsp;</div>',
    ),
    'parent_wrapper' => array(
      'parent' => array(
        '#type' => 'select',
        '#options' => $parent_options,
        '#empty_value' => '',
        '#attributes' => array('class' => array('field-parent')),
        '#prefix' => '<div class="add-new-placeholder">&nbsp;</div>',
        '#parents' => array('fields', $name, 'parent'),
      ),
      'hidden_name' => array(
        '#type' => 'hidden',
        '#default_value' => $name,
        '#attributes' => array('class' => array('field-name')),
      ),
    ),
    'group_name' => array(
      '#type' => 'textfield',
      // This field should stay LTR even for RTL languages.
      '#field_prefix' => '<span dir="ltr">group_',
      '#field_suffix' => '</span>&lrm;',
      '#attributes' => array('dir'=>'ltr'),
      '#size' => 15,
      '#description' => t('Group name (a-z, 0-9, _)'),
      '#prefix' => '<div class="add-new-placeholder">&nbsp;</div>',
      '#cell_attributes' => array('colspan' => $params->display_overview ? 1 : 2),
    ),
  );
}

/**
 * Implements hook_field_group_formats().
 * @return array of available formatting html controls
 * for form and display overview type.
 */
function field_group_field_group_formats() {
  return array(
    'form' => array(
      'hidden' => t('Hidden'),
      'fieldset' => t('Fieldset'),
      'tabs' => t('Vertical tabs group'),
      'tab' => t('Vertical tab'),
      'htabs' => t('Horizontal tabs group'),
      'htab' => t('Horizontal tab item'),
      'accordion' => t('Accordion group'),
      'accordion-item' => t('Accordion item')
    ),
    'display' => array(
      'hidden' => t('Hidden'),
      'div' => t('Div'),
      'fieldset' => t('Fieldset'),
      'tabs' => t('Vertical tabs group'),
      'tab' => t('Vertical tab'),
      'htabs' => t('Horizontal tabs group'),
      'htab' => t('Horizontal tab item'),
      'accordion' => t('Accordion group'),
      'accordion-item' => t('Accordion item')
    ),
  );
}

/**
 * Implements hook_field_group_pre_render().
 * This function (only) gives you the oppertunity to 'create' the given
 * wrapper field.
 * @param Array $elements by address.
 * @param Object $group The Field group info.
 */
function field_group_field_group_pre_render(& $element, $group, & $form) {

  $classes = array($group->visible);
  if (isset($group->format_settings['fieldgroup_settings'])) {
    $collapsible = in_array($group->format_settings['fieldgroup_settings'], array('collapsible', 'open', 'collapsed', 'closed'));
    $collapsed = in_array($group->format_settings['fieldgroup_settings'], array('collapsed', 'closed'));
    if ($collapsible) {
      $classes[] = 'collapsible';
      if ($collapsed) {
        $classes[] = 'collapsed';
      }
    }
  }
  else {
    $collapsible = TRUE;
    $collapsed = FALSE;
    $classes[] = 'collapsible';
  }
  // Javascript has to be able to play along.
  $form['#attached']['js'][] = array(
    'data' => array('field_group' => array($group->visible => TRUE)),
    'type' => 'setting'
  );

  switch ($group->visible) {
    // Fieldset.
    case 'fieldset':
      $element += array(
        '#type' => 'fieldset',
        '#title' => $group->label,
        '#weight' => $group->weight,
        '#collapsible' => $collapsible,
        '#collapsed' => $collapsed,
        '#pre_render' => array(),
        '#attributes' => array('class' => $classes),
      );
      $element['#attached']['js'][] = 'misc/form.js';
      $element['#attached']['js'][] = 'misc/collapse.js';
      break;
    // Normal or collapsible div.
    case 'div':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '<div class="field-group-format '. implode(' ', $classes) . '">
        <span class="field-group-format-toggler">'. $group->label .'</span>
        <div class="field-group-format-wrapper" style="display: '. ($collapsed ? 'none' : 'block') .';">',
        '#suffix' => '</div></div>',
        '#weight' => $group->weight,
      );
      drupal_add_library('system', 'effects.blind');
      break;
    // Horizontal tabs group and accordion group.
    case 'htabs':
    case 'accordion':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '<div class="field-group-'. $group->visible .'-wrapper">',
        '#suffix' => '</div>',
        '#weight' => $group->weight,
      );
      break;
    // Accordion item.
    case 'accordion-item':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '
        <h3 class="field-group-format-toggler '. $group->visible .'">'. $group->label .'</h3>
        <div class="field-group-format-wrapper" style="display: '. ($collapsed ? 'none' : 'block') .';">',
        '#suffix' => '</div>',
        '#weight' => $group->weight,
        //'#attributes' => array('class' => array($group->visible)),
      );
      drupal_add_library('system', 'ui.accordion');
      break;
    // Horizontal tab.
    case 'htab':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '
        <span class="field-group-format-toggler '. $group->visible .'">'. $group->label .'</span>
        <div class="field-group-format-wrapper" style="display: '. ($collapsed ? 'none' : 'block') .';">',
        '#suffix' => '</div>',
        '#weight' => $group->weight,
        '#attributes' => array('class' => $classes),
      );
      drupal_add_library('system', 'effects.blind');
      break;
    // Vertical tabs group.
    case 'tabs':
      $element += array(
        '#type' => 'vertical_tabs',
        '#weight' => $group->weight,
        '#theme_wrappers' => array('vertical_tabs'),
        '#prefix' => '<div class="field-group-'. $group->visible .'-wrapper">',
        '#suffix' => '</div>',
      );
      $form['#attached']['js'][] = 'misc/form.js';
      $form['#attached']['js'][] = 'misc/collapse.js';
      $form['#attached']['js'][] = 'misc/vertical-tabs.js';
      $form['#attached']['css'][] = 'misc/vertical-tabs.css';
      break;
    // Vertical tab.
    case 'tab':
      // For the form, we will keep it in the root.
      if (!isset($form['#view_mode'])) {
        $form['additional_settings'][$group->group_name] = array(
          '#type' => 'fieldset',
          '#title' => $group->label,
          '#weight' => $group->weight,
          '#collapsible' => $collapsible,
          '#collapsed' => $collapsed,
          '#attributes' => array('class' => array($group->visible)),
          '#group' => 'additional_settings',
        );
        foreach (element_children($element) as $fieldname) {
          $form['additional_settings'][$group->group_name][$fieldname] = $element[$fieldname];
          unset($element[$fieldname]);
        }
      }
      else {
        $element += array(
          '#type' => 'fieldset',
          '#title' => $group->label,
          '#weight' => $group->weight,
          '#collapsible' => $collapsible,
          '#collapsed' => $collapsed,
          '#attributes' => array('class' => array($group->visible)),
          '#group' => $group->parent_name,
          // very important. Cannot be added on the form!
          '#parents' => array($group->parent_name),
        );
      }

    break;
  }
}

/**
 * Implements hook_field_group_pre_render_alter().
 * @param Array $elements by address.
 */
function field_group_field_group_pre_render_alter(& $element) {

  // Dish the fieldgroups with no fields.
  if (isset($element['#view_mode'])) {
    $groups = array_keys($element['#groups']);
    foreach (element_children($element) as $name) {
      if (in_array($name, $groups)) {
        if (field_group_field_group_is_empty($element[$name], $groups)) {
          unset($element[$name]);
        }
      }
    }
  }

  // Place a wrapper around the complete build.
  // TODO check if there is no other way to target only a wrapper where the
  //      fieldgroups are located. Currently javascript use this.
  $element['#attached']['js'][] = drupal_get_path('module', 'field_group') .'/field_group.js';
  $element['#prefix'] = (isset($element['#prefix']) ? $element['#prefix'] : '') . '<div class="field-group-content-wrapper">';
  $element['#suffix'] = '</div>' . (isset($element['#suffix']) ? $element['#suffix'] : '');
}

/**
 * Helper function to recursively tell if the group contains
 * an element.
 * @param array $element Build array structure
 * @param array $groups Array of group names
 * @return Boolean Is field group empty
 */
function field_group_field_group_is_empty($element, $groups) {
  foreach (element_children($element) as $name) {
    if (in_array($name, $groups)) {
      return field_group_field_group_is_empty($element[$name], $groups);
    }
    else {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Implements hook_field_group_format_settings().
 * If the group has no format settings, default ones will be added.
 * @params Object $group The group object.
 * @return Array $form The form element for the format settings.
 */
function field_group_field_group_format_settings(& $group) {
  $form = array();
  switch ($group->visible) {
    case 'fieldset':
    case 'div':
      if (!isset($group->format_settings['fieldgroup_settings'])) {
        $group->format_settings['fieldgroup_settings'] = 'collapsed';
      }
      $form['fieldgroup_settings'] = array(
        '#title' => t('Fieldgroup settings'),
        '#type' => 'select',
        '#options' => array(
          'open' => t('Open'),
          'collapsible' => t('Collapsible'),
          'collapsed' => t('Collapsed'),
        ),
        '#default_value' => $group->format_settings['fieldgroup_settings'],
        '#weight' => 1,
        //'#element_validate' => array('_element_validate_integer_positive'),
        //'#required' => TRUE,
      );
      break;
    case 'tab':
    case 'accordion-item':
    case 'htab':
      if (!isset($group->format_settings['fieldgroup_settings'])) {
        $group->format_settings['fieldgroup_settings'] = 'closed';
      }
      $form['fieldgroup_settings'] = array(
        '#title' => t('Fieldgroup settings'),
        '#type' => 'select',
        '#options' => array(
          'open' => t('Open'),
          'closed' => t('Closed'),
        ),
        '#default_value' => $group->format_settings['fieldgroup_settings'],
        '#weight' => 1,
      );
      break;
  }
  return $form;
}

/**
 * Implements hook_field_group_format_summary().
 */
function field_group_field_group_format_summary(& $group) {
  $output = '';
  if (isset($group->format_settings['fieldgroup_settings'])) {
    $output = '<strong>'. $group->visible .'</strong> '. $group->format_settings['fieldgroup_settings'] .'';
  }
  return $output;
}

/**
 * Menu loader; Load a group instance based on group and bundle name.
 *
 * @param $group_name
 *   The name of the group, as contained in the path.
 * @param $entity_type
 *   The name of the entity.
 * @param $bundle_name
 *   The name of the bundle, as contained in the path.
 * @param $bundle_pos
 *   The position of $bundle_name in $map.
 * @param $map
 *   The translated menu router path argument map.
 */
function field_group_menu_load($group_name, $entity_type, $bundle_name, $bundle_pos, $map) {
  // @todo : this is broken - loads (and thus edits / deletes) a group only by group name,
  // which is not unique.
  // A unique group is identified by a [entity_type, bundle, group_name, view_mode] tuple.
  // But sticking that much info in the menu path might be a bit long...
  // Tricky stuff, I'll try to look into this - yched.
  $query = db_select('field_group', 'fg');
  $query->fields('fg');
  $query->condition('group_name', $group_name);
  $query->condition('entity_type', $entity_type);
  $query->condition('bundle', $bundle_name);
  $group = $query->execute()->fetchObject();
  if ($group->id) {
    // @todo should happen in a proper CRUD API function
    $data = unserialize($group->data);
    unset($group->data);
    $group->label = $data['label'];
    $group->weight = $data['weight'];
    $group->children = $data['children'];
    $group->visible = $data['visible'];

    return $group;
  }
  return FALSE;
}

/**
 * Read all groups.
 */
function field_group_read_groups($params = array()) {
  $groups = array();

  $query = db_select('field_group', 'fg');
  $query->fields('fg');

  // Turn the conditions into a query.
  foreach ($params as $key => $value) {
    $query->condition($key, $value);
  }

  $results = $query->execute();
  foreach ($results as $group) {
    // Extract unserialized data.
    $data = unserialize($group->data);
    unset($group->data);
    $group->label = $data['label'];
    $group->weight = $data['weight'];
    $group->children = $data['children'];
    $group->visible = $data['visible'];
    if (isset($data['format_settings'])) {
      $group->format_settings = $data['format_settings'];
    }

    $groups[$group->entity_type][$group->bundle][$group->mode][$group->group_name] = $group;
  }

  return $groups;
}

/**
 * Get all groups.
 *
 * @param $entity_type
 *   The name of the entity.
 * @param $bundle
 *   The name of the bundle.
 * @param $view_mode
 *   The view mode.
 * @param $reset.
 *   Whether to reset the cache or not.
 */
function field_group_info_groups($entity_type = NULL, $bundle = NULL, $view_mode = NULL, $reset = FALSE) {
  static $groups = FALSE;

  if (!$groups || $reset) {
    if ($cached = cache_get('field_groups', 'cache_field')) {
      $groups = $cached->data;
    }
    else {
      $groups = field_group_read_groups();
      cache_set('field_groups', $groups, 'cache_field');
    }
  }

  if (!isset($entity_type)) {
    return $groups;
  }
  else {
    if (isset($groups[$entity_type][$bundle][$view_mode])) {
      return $groups[$entity_type][$bundle][$view_mode];
    }
    else {
      return array();
    }
  }
}

/**
 * Saves a group definition.
 *
 * @param $group
 *   A group definition.
 */
function field_group_save(&$group) {
  // Prepare the record.
  $record = clone $group;
  $record->data = array(
    'label' => $record->label,
    'weight' => $record->weight,
    'children' => $record->children,
    // @todo rename to format ? And how to select format/theming on manage fields screen?
    // Depends on what we will do with Display Suite. If we take on this challenge,
    // maybe fieldgroups are a very explicable and extendable replacement for object-regions.
    // - Stalski
    'visible' => $record->visible,
  );
  if (isset($record->format_settings)) {
    $record->data['format_settings'] = $record->format_settings;
  }

  if (isset($record->id)) {
    drupal_write_record('field_group', $record, array('id'));
  }
  else {
    drupal_write_record('field_group', $record);
    $group->id = $record->id;
  }
}

/**
 * Function to retrieve all format possibilities for the fieldgroups.
 */
function field_group_formats($display_overview = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array());
  if (empty($cache)) {
    if ($cached = cache_get('field_group_formats', 'cache_field')) {
      $format_options = $cached->data;
    }
    else {
      $format_options = array();
      $format_options += module_invoke_all('field_group_formats');
      cache_set('field_group_formats', $format_options, 'cache_field');
    }
    $cache = $format_options;
  }
  return $cache;
}

/**
 * Process/ Pre-render callback.
 * Depending on whether it is a form build or content build.
 * Form api go through more than a regular build. #process is
 * needed here, where #pre_render is ideal for the regular array.
 * @see called by field_group_attach_groups().
 * @see calls field_group_fields_nest().
 * @param $element Form element
 * @return $element Array with re-arranged fields in forms.
 */
function field_group_fields_process($element) {
  // Nest the fields in the corresponding field groups.
  field_group_fields_nest($element, $element);

  // Dirty fix to 'deny' the default ones.
  if (isset($element['#node_edit_form'])) {
    $element['menu']['#weight'] = 30;
    $element['revision_information']['#weight'] = 30;
    $element['path']['#weight'] = 30;
  }
  drupal_alter('field_group_pre_render', $element);

  return $element;
}

/**
 * Recursive function to nest fields in the field groups.
 * This function will take out all the elements in the form and
 * place them in the correct container element, a fieldgroup.
 * The current group element in the loop is passed recursively so we can
 * stash fields and groups in it while we go deeper in the array.
 * @param Array $element
 *   The current element to analyse for grouping.
 * @param Array $root_element
 *   The root element to control.
 * @param String $parent
 *   the parent name to look for in each level.
 */
function field_group_fields_nest(&$element, &$root_element, $parent_name = NULL) {
  $groups = $root_element['#groups'];
  $group_fields = $root_element['#group_children'];

  foreach ($groups as $name => $group) {

    // Add fieldgroups to the current element. But only if the parent is the current
    // group parent or if we are starting from the root.
    if ((empty($group->parent_name) && !isset($parent_name)) || $parent_name == $group->parent_name) {

      // We first create a new element wrapper, and loop over the fields
      // to detect children. After this point, the fields are stashed
      // in the group element and removed from the root.
      $element[$name] = array();
      foreach ($group_fields as $groupfield => $groupname) {
        // Stash the field in the group.
        if ($groupname == $name && isset($root_element[$groupfield])) {
          $element[$name][$groupfield] = $root_element[$groupfield];
          // We can not meet this field again!
          unset($root_element[$groupfield]);
          unset($root_element['#group_children'][$groupfield]);
        }
        // Or hey, is the field maybe a group, then prepare the array
        // so the group is not left empty.
        if ($groupname == $name && isset($root_element['#groups'][$groupfield])) {
          $element[$name][$groupfield] = array();
          unset($root_element['#group_children'][$groupfield]);
        }
      }
      // Bring extra element wrappers to achieve a grouping of fields.
      // This will mainly be prefix and suffix altering.
      field_group_pre_render($element[$name], $group, $root_element);
      // Go deeper with the current group element and the parent $name.
      field_group_fields_nest($element[$name], $root_element, $name);
    }
  }
}

/**
 * Function to pre render the field group element.
 * @see called by field_group_fields_nest().
 * @param $element Array of group element that needs to be created!
 * @param $group Object with the group information.
 * @param $form The form object itself.
 */
function field_group_pre_render(& $element, $group, & $form) {
  // Only run the pre_render function if the group has elements.
  // $group->group_name
  if ($element == array()) {
    return;
  }
  // Let modules define their wrapping element.
  // Note that the group element has no properties, only elements.
  foreach (module_implements('field_group_pre_render') as $module) {
    $function = $module . '_field_group_pre_render';
    if (function_exists($function)) {
      // The intention here is to have the opportunity to alter the
      // elements, as defined in hook_field_group_formats.
      // Note, implement $element by reference!
      $function($element, $group, $form);
    }
  }
}

/**
 * Creates a form for field_group formatters.
 * @param Object $group The FieldGroup object.
 */
function field_group_format_settings_form(&$group) {
  $form = array();
  $form['label'] = array('#type' => 'textfield', '#title' => t('Field group label'), '#default_value' => $group->label, '#weight' => -5);
  $form += module_invoke_all('field_group_format_settings', $group);
  return $form;
}

/**
 * Submit handler to save the configuration of a fieldgroup.
 * @param Ojbect $group The group object
 * @param Array $settins Configuration settings
 */
function field_group_format_settings_submit(& $group, $settings, $format_change = FALSE) {
  // for format changes we load the defaults
  if ($format_change) {
    $group->format_settings = NULL;
    // The group will be saved by reference.
    field_group_format_settings_form($group);
  }
  else {
    $group->visible = $settings['format']['type'];
    $group->label = $settings['format_settings']['settings']['label'];
    $group->format_settings = $settings['format_settings']['settings'];
  }
  // Save the group settings.
  field_group_save($group);
  cache_clear_all('field_groups', 'cache_field');
}

/**
 * Creates a summary for the field format configuration summary.
 * @param String $group_name The name of the group
 * @param Object $group The group object
 * @return Array ready to be rendered.
 */
function field_group_format_settings_summary($group_name, $group) {
  $summary = implode('', module_invoke_all('field_group_format_summary', $group));
  return array(
    '#markup' => '<div class="field-formatter-summary">'. $summary .'</div>',
    '#cell_attributes' => array('class' => array('field-formatter-summary-cell')),
  );
}

/**
 * Validate handler for the overview screens.
 * @param Array $form The complete form.
 * @param Array $form_state The state of the form.
 */
function field_group_field_overview_validate($form, &$form_state) {
  $form_values = $form_state['values']['fields'];
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $mode = (isset($form['#view_mode']) ? $form['#view_mode'] : 'form');

  $group = $form_values['_add_new_group'];

  // Validate if any information was provided in the 'add new group' row.
  if (array_filter(array($group['label'], $group['group_name']))) {
    // Missing label.
    if (!$group['label']) {
      form_set_error('fields][_add_new_group][label', t('Add new group: you need to provide a label.'));
    }

    // Missing group name.
    if (!$group['group_name']) {
      form_set_error('fields][_add_new_group][group_name', t('Add new group: you need to provide a group name.'));
    }
    // Group name validation.
    else {
      $group_name = $group['group_name'];

      // Add the 'group_' prefix.
      if (substr($group_name, 0, 6) != 'group_') {
        $group_name = 'group_' . $group_name;
        form_set_value($form['fields']['_add_new_group']['group_name'], $group_name, $form_state);
      }

      // Invalid group name.
      if (!preg_match('!^group_[a-z0-9_]+$!', $group_name)) {
        form_set_error('fields][_add_new_group][group_name', t('Add new group: the group name %group_name is invalid. The name must include only lowercase unaccentuated letters, numbers, and underscores.', array('%group_name' => $group_name)));
      }
      if (strlen($group_name) > 32) {
        form_set_error('fields][_add_new_group][group_name', t("Add new group: the group name %group_name is too long. The name is limited to 32 characters, including the 'group_' prefix.", array('%group_name' => $group_name)));
      }

      // Group name already exists.
      $groups = field_group_read_groups();
      if (!empty($groups[$entity_type][$bundle][$mode][$group_name])) {
        form_set_error('fields][_add_new_group][group_name', t('Add new group: the group name %group_name already exists.', array('%group_name' => $group_name)));
      }
    }
  }
}

/**
 * Submit handler for the overview screens.
 * @param Array $form The complete form.
 * @param Array $form_state The state of the form.
 */
function field_group_field_overview_submit($form, &$form_state) {
  $form_values = $form_state['values']['fields'];
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $mode = (isset($form['#view_mode']) ? $form['#view_mode'] : 'form');

  // Collect children.
  $children = array_fill_keys($form['#groups'], array());
  foreach ($form_values as $name => $value) {
    if (!empty($value['parent'])) {
      // Substitute newly added fields, in case they were dragged directly in a
      // group.
      if ($name == '_add_new_field' && isset($form_state['fields_added']['_add_new_field'])) {
        $name = $form_state['fields_added']['_add_new_field'];
      }
      elseif ($name == '_add_existing_field' && isset($form_state['fields_added']['_add_existing_field'])) {
        $name = $form_state['fields_added']['_add_existing_field'];
      }
      $children[$value['parent']][$name] = $name;
    }
  }

  // Create new group.
  if (!empty($form_values['_add_new_group']['group_name'])) {
    $values = $form_values['_add_new_group'];
    $new_group = (object) array(
      'group_name' => $values['group_name'],
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'mode' => $mode,
      'children' => isset($children['_add_new_group']) ? array_keys($children['_add_new_group']) : array(),
      'parent_name' => $values['parent'],
      'weight' => $values['weight'],
      'label' => $values['label'],
      // @todo currently not present in 'Manage Fields' screen.
      'visible' => isset($values['format']['type']) ? $values['format']['type'] : 'visible',
    );
    field_group_save($new_group);

    // Store new group information for any additional submit handlers.
    $form_state['groups_added']['_add_new_group'] = $new_group->group_name;
    drupal_set_message(t('New group %label succesfully created.', array('%label' => $new_group->label)));

    // Replace the newly created group in the $children array, in case it was
    // dragged directly in an existing field.
    foreach (array_keys($children) as $parent) {
      if (isset($children[$parent]['_add_new_group'])) {
        unset($children[$parent]['_add_new_group']);
        $children[$parent][$new_group->group_name] = $new_group->group_name;
      }
    }
  }

  // Update existing groups.
  $groups = field_group_info_groups($entity_type, $bundle, $mode, TRUE);
  foreach ($form['#groups'] as $group_name) {
    $group = $groups[$group_name];
    $group->children = array_keys($children[$group_name]);
    $group->parent_name = $form_values[$group_name]['parent'];
    $group->weight = $form_values[$group_name]['weight'];
    $group->visible = isset($form_values[$group_name]['format']['type']) ? $form_values[$group_name]['format']['type'] : 'visible';
    field_group_save($group);
  }

  cache_clear_all('field_groups', 'cache_field');
}

/**
 * Returns the region to which a row in the 'Manage fields' screen belongs.
 * @param Array $row A field or field_group row
 * @return String the current region.
 */
function field_group_field_overview_row_region($row) {
  switch ($row['#row_type']) {
    case 'group':
      return 'main';
    case 'add_new_group':
      // If no input in 'label', assume the row has not been dragged out of the
      // 'add new' section.
      if (empty($row['label']['#value'])) {
        return 'add_new';
      }
      return 'main';
  }
}

/**
 * Returns the region to which a row in the 'Manage display' screen belongs.
 * @param Array $row A field or field_group row
 * @return String the current region.
 */
function field_group_display_overview_row_region($row) {
  switch ($row['#row_type']) {
    case 'group':
      return ($row['format']['type']['#value'] == 'hidden' ? 'hidden' : 'visible');
    case 'add_new_group':
      // If no input in 'label', assume the row has not been dragged out of the
      // 'add new' section.
      if (empty($row['label']['#value'])) {
        return 'add_new';
      }
      return ($row['format']['type']['#value'] == 'hidden' ? 'hidden' : 'visible');
  }
}

/**
 * Attach groups to the (form) build.
 * @param Array $element The part of the form.
 * @param String $view_mode The mode for the build.
 */
function field_group_attach_groups(&$element, $view_mode) {
  $entity_type = $element['#entity_type'];
  $bundle = $element['#bundle'];

  $element['#groups'] = field_group_info_groups($entity_type,$bundle, $view_mode);

  // Create a lookup array.
  $group_children = array();
  foreach ($element['#groups'] as $group_name => $group) {
    foreach ($group->children as $child) {
      $group_children[$child] = $group_name;
    }
  }
  $element['#group_children'] = $group_children;

  // Add a pre render or process callback.
  // This is needed since process seems too early for the front view modes.
  $element[$view_mode == 'form' ? '#process': '#pre_render'][] = 'field_group_fields_process';
}


// @todo experiments with setting & summary.

// This does work partially (trying to find out how to save the settings)
// since we check on the form_state just like field_ui.admin.inc does. Not sure if
// we should do that like this, seems like much overhead (although I can't see
// any other way to do that). Should be documented to developers.
//
// The irony of all this is that if we treat fieldgroups as fields
// all this stuff would work out of the box and we could use
// formatters_info & all those hooks (but there should be  a way to tell
// field api that this field will not store any data)

// (YC) Groups are not fields, I don't think we can or should treat them that way.
// You cannot add fields from the 'Manage display' screens - but you can add groups.

// Also, are those settings and summary forms extendable or not from
// other modules. Just thinking how for example I'd like to add
// a Styles select box to every field/fieldgroup from the Display Suite
// module. (I guess form alter should, but will it save also - need to investigate myself)
//
// Maybe this isn't necessary at all and all settings
// should be moved to the edit screen of a field group
// I think it depends whether we want to make it possible to let
// other module developers extend on this field group module to
// add different kinds of fieldgroups or not ...
// Moving it to the edit screen however makes the flow of
// managing your display/form a bit slower.

// (YC) We do want to let other modules add other group 'flavors'. Those then become
// a lot like field formatters. Declared through hook_fieldgroup_formatter_info(),
// with settings and a default value for each setting.
// Field_group.module defines the basic ones :
// - regular group (settings: 'fieldset open', 'collapsible', 'collapsed'),
// - tabs container (settings: 'default tab' ?),
// - VT container ?
// - accordion container ?
// Then each module declaring its group formatters is responsible for providing
// the corresponding settings form and settings summary.
// The 'format' dropdown select lets users pick a group formatter amongst all available formats.

// Or, every possible configuration (like fieldset collapsible, collapsed, open
// must be an option in the formatters $options above.
//
// So as some sort conclusion, these settings stuff should have
// some helper functions to make it easier for other devs I think,
// because you need a duplicate a lot of code and is pretty dangerous
// when Drupal core gets updates

// (YC) Tricky :-/

// (YC) We should probably move the discussion to http://drupal.org/node/824812 :-)
