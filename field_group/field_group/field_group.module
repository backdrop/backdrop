<?php
// $Id$

/**
 * hook_field_group_formatter_info
 * stalski: swentel: API wise : it would b a good idea IMO to model the "pluggable group style" API just
 *  like Field formatters api
 *  hook_field_group_formatter_info(), returning group formats each with
 *  their own settings and default settings values
 * field_group_field_group_formatter_info currently looks like nothing familiar -
 * sticking to Field API formulation is better DX, and it's a somewhat proofed API
 * no, forms have nothing to do with that. I want to know which settings a group
 * formatter has, and what default values should be used
 * stalski: also : make sure you fill in missing defaults when saving and
 * loading a group definition. That saves you doing lots of isset() checks in all
 * the rest of the code. $group becomes 'predictable'
 */

/**
 * @file
 * Fieldgroup module.
 *
 *   PHP HOOKS
 *
 *   hook_field_group_formatter_info()
 *     Creates a format entry for a fieldgroup.
 *     @see field_group_field_group_formatter_info()
 *
 *   hook_field_group_format_settings
 *     Creates a form for the fieldgroup settings of the current group.
 *
 *   hook_field_group_format_summary
 *     Creates a summary for the current group.
 *
 *   hook_field_group_pre_render()
 *     Create an element for the field group
 *
 *   hook_field_group_build_pre_render_alter()
 *     Gives the opportunity to do extra things for
 *     some format cases.
 *
 *   JAVASCRIPT HOOKS
 *
 *   Drupal.FieldGroup.Effects.processHook.execute()
 *
 *
 */

/**
 * Implements hook_menu().
 */
function field_group_menu() {
  $items = array();

  // Ensure the following is not executed until field_bundles is working and
  // tables are updated. Needed to avoid errors on initial installation.
  if (defined('MAINTENANCE_MODE')) {
    return $items;
  }

  // Create tabs for all possible bundles.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if ($entity_info['fieldable']) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract path information from the bundle.
          $path = $bundle_info['admin']['path'];
          // Different bundles can appear on the same path (e.g. %node_type and
          // %comment_node_type). To allow field_ui_menu_load() to extract the
          // actual bundle object from the translated menu router path
          // arguments, we need to identify the argument position of the bundle
          // name string ('bundle argument') and pass that position to the menu
          // loader. The position needs to be casted into a string; otherwise it
          // would be replaced with the bundle name string.
          if (isset($bundle_info['admin']['bundle argument'])) {
            $bundle_arg = $bundle_info['admin']['bundle argument'];
            $bundle_pos = (string) $bundle_arg;
          }
          else {
            $bundle_arg = $bundle_name;
            $bundle_pos = '0';
          }

          // This is the position of the %group_ui_menu placeholder in the
          // items below.
          $group_position = count(explode('/', $path)) + 1;

          // Extract access information, providing defaults.
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $access += array(
            'access callback' => 'user_access',
            'access arguments' => array('administer site configuration'),
          );

          $items["$path/groups/%field_group_menu/delete"] = array(
            'load arguments' => array($entity_type, $bundle_arg, $bundle_pos, '%map'),
            'title' => 'Delete',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('field_group_delete_form', $group_position),
            'type' => MENU_CALLBACK,
            'file' => 'field_group.field_ui.inc',
          ) + $access;
        }
      }
    }
  }

  return $items;
}

/**
 * Menu load
 * Load a group instance based on group and bundle name.
 *
 * @param $group_name
 *   The name of the group, as contained in the path.
 * @param $entity_type
 *   The name of the entity.
 * @param $bundle_name
 *   The name of the bundle, as contained in the path.
 * @param $bundle_pos
 *   The position of $bundle_name in $map.
 * @param $map
 *   The translated menu router path argument map.
 */
function field_group_menu_load($group_name, $entity_type, $bundle_name, $bundle_pos, $map) {
  // A unique group is identified by a [entity_type, bundle, group_name, view_mode] tuple.
  $query = db_select('field_group', 'fg');
  $query->fields('fg');
  $query->condition('group_name', $group_name);
  $query->condition('entity_type', $entity_type);
  $query->condition('bundle', $bundle_name);
  $group = $query->execute()->fetchObject();
  if ($group->id) {
    // @todo should happen in a proper CRUD API function
    $data = unserialize($group->data);
    unset($group->data);
    $group->label = $data['label'];
    $group->weight = $data['weight'];
    $group->children = $data['children'];
    $group->visible = $data['visible'];

    return $group;
  }
  return FALSE;
}

/**
 * Implements hook_features_api().
 */
function field_group_features_api() {
  module_load_include('inc', 'field_group', 'field_group.features');
  return array(
    'field_group' => array(
      'name' => t('Field groups'),
      'default_hook' => 'field_group_default_field_groups',
      'default_file' => FEATURES_DEFAULTS_INCLUDED,
      'feature_source' => TRUE,
    )
  );
}

/**
 * Implements hook_field_info_max_weight().
 */
function field_group_field_info_max_weight($entity_type, $bundle, $context) {
  $weights = array();
  foreach (field_group_info_groups($entity_type, $bundle, $context) as $group) {
    $weights[] = $group->weight;
  }
  return $weights ? max($weights) : NULL;
}

/**
 * Implements hook_field_attach_form().
 */
function field_group_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  $form['#attached']['css'][] = drupal_get_path('module', 'field_group') . '/field_group.field_ui.css';
  field_group_attach_groups($form, 'form');
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Using hook_form_field_ui_field_overview_form_alter.
 */
function field_group_form_field_ui_field_overview_form_alter(&$form, &$form_state) {
  module_load_include('inc', 'field_group', 'field_group.field_ui');
  field_group_field_ui_overview_form_alter($form, $form_state);
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Using hook_form_field_ui_display_overview_form_alter.
 */
function field_group_form_field_ui_display_overview_form_alter(&$form, &$form_state) {
  module_load_include('inc', 'field_group', 'field_group.field_ui');
  field_group_field_ui_overview_form_alter($form, $form_state, TRUE);
}

/**
 * Validate handler for the overview screens.
 * @param Array $form The complete form.
 * @param Array $form_state The state of the form.
 */
function field_group_field_overview_validate($form, &$form_state) {
  $form_values = $form_state['values']['fields'];
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $mode = (isset($form['#view_mode']) ? $form['#view_mode'] : 'form');

  $group = $form_values['_add_new_group'];

  // Validate if any information was provided in the 'add new group' row.
  if (array_filter(array($group['label'], $group['group_name']))) {
    // Missing label.
    if (!$group['label']) {
      form_set_error('fields][_add_new_group][label', t('Add new group: you need to provide a label.'));
    }

    // Missing group name.
    if (!$group['group_name']) {
      form_set_error('fields][_add_new_group][group_name', t('Add new group: you need to provide a group name.'));
    }
    // Group name validation.
    else {
      $group_name = $group['group_name'];

      // Add the 'group_' prefix.
      if (substr($group_name, 0, 6) != 'group_') {
        $group_name = 'group_' . $group_name;
        form_set_value($form['fields']['_add_new_group']['group_name'], $group_name, $form_state);
      }

      // Invalid group name.
      if (!preg_match('!^group_[a-z0-9_]+$!', $group_name)) {
        form_set_error('fields][_add_new_group][group_name', t('Add new group: the group name %group_name is invalid. The name must include only lowercase unaccentuated letters, numbers, and underscores.', array('%group_name' => $group_name)));
      }
      if (strlen($group_name) > 32) {
        form_set_error('fields][_add_new_group][group_name', t("Add new group: the group name %group_name is too long. The name is limited to 32 characters, including the 'group_' prefix.", array('%group_name' => $group_name)));
      }

      // Group name already exists.
      $groups = field_group_read_groups();
      if (!empty($groups[$entity_type][$bundle][$mode][$group_name])) {
        form_set_error('fields][_add_new_group][group_name', t('Add new group: the group name %group_name already exists.', array('%group_name' => $group_name)));
      }
    }
  }
}

/**
 * Submit handler for the overview screens.
 * @param Array $form The complete form.
 * @param Array $form_state The state of the form.
 */
function field_group_field_overview_submit($form, &$form_state) {
  $form_values = $form_state['values']['fields'];
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $mode = (isset($form['#view_mode']) ? $form['#view_mode'] : 'form');

  // Collect children.
  $children = array_fill_keys($form['#groups'], array());
  foreach ($form_values as $name => $value) {
    if (!empty($value['parent'])) {
      // Substitute newly added fields, in case they were dragged directly in a
      // group.
      if ($name == '_add_new_field' && isset($form_state['fields_added']['_add_new_field'])) {
        $name = $form_state['fields_added']['_add_new_field'];
      }
      elseif ($name == '_add_existing_field' && isset($form_state['fields_added']['_add_existing_field'])) {
        $name = $form_state['fields_added']['_add_existing_field'];
      }
      $children[$value['parent']][$name] = $name;
    }
  }

  // Create new group.
  if (!empty($form_values['_add_new_group']['group_name'])) {
    $values = $form_values['_add_new_group'];
    $new_group = (object) array(
      'group_name' => $values['group_name'],
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'mode' => $mode,
      'children' => isset($children['_add_new_group']) ? array_keys($children['_add_new_group']) : array(),
      'parent_name' => $values['parent'],
      'weight' => $values['weight'],
      'label' => $values['label'],
      // @todo currently not present in 'Manage Fields' screen.
      'visible' => isset($values['format']['type']) ? $values['format']['type'] : 'visible',
    );
    field_group_save($new_group);

    // Store new group information for any additional submit handlers.
    $form_state['groups_added']['_add_new_group'] = $new_group->group_name;
    drupal_set_message(t('New group %label succesfully created.', array('%label' => $new_group->label)));

    // Replace the newly created group in the $children array, in case it was
    // dragged directly in an existing field.
    foreach (array_keys($children) as $parent) {
      if (isset($children[$parent]['_add_new_group'])) {
        unset($children[$parent]['_add_new_group']);
        $children[$parent][$new_group->group_name] = $new_group->group_name;
      }
    }
  }

  // Update existing groups.
  $groups = field_group_info_groups($entity_type, $bundle, $mode, TRUE);
  foreach ($form['#groups'] as $group_name) {
    $group = $groups[$group_name];
    $group->children = array_keys($children[$group_name]);
    $group->parent_name = $form_values[$group_name]['parent'];
    $group->weight = $form_values[$group_name]['weight'];
    $group->visible = isset($form_values[$group_name]['format']['type']) ? $form_values[$group_name]['format']['type'] : 'visible';
    field_group_save($group);
  }

  cache_clear_all('field_groups', 'cache_field');
}

/**
 * Implements hook_field_attach_view_alter().
 */
function field_group_field_attach_view_alter(&$element, $context) {
  // Check whether the view mode uses custom display settings or the 'default' mode.
  $view_mode_settings = field_view_mode_settings($element['#entity_type'], $element['#bundle']);
  $view_mode = $context['view_mode'];
  $actual_mode = (!empty($view_mode_settings[$view_mode]['custom_settings']) ? $view_mode : 'default');
  field_group_attach_groups($element, $actual_mode);
}

/**
 * Implements hook_field_group_formatter_info().
 * @return array of available formatting html controls
 * for form and display overview type.
 */
function field_group_field_group_formatter_info() {
  return array(
    'form' => array(
      'fieldset' => t('Fieldset'),
      'tabs' => t('Vertical tabs group'),
      'tab' => t('Vertical tab'),
      'htabs' => t('Horizontal tabs group'),
      'htab' => t('Horizontal tab item'),
      'accordion' => t('Accordion group'),
      'accordion-item' => t('Accordion item'),
    ),
    'display' => array(
      'div' => t('Div'),
      'fieldset' => t('Fieldset'),
      'tabs' => t('Vertical tabs group'),
      'tab' => t('Vertical tab'),
      'htabs' => t('Horizontal tabs group'),
      'htab' => t('Horizontal tab item'),
      'accordion' => t('Accordion group'),
      'accordion-item' => t('Accordion item'),
      'hidden' => t('<Hidden>'),
    ),
  );
}

/**
 * Implements hook_field_group_pre_render().
 * This function (only) gives you the oppertunity to 'create' the given
 * wrapper field.
 * @param Array $elements by address.
 * @param Object $group The Field group info.
 */
function field_group_field_group_pre_render(& $element, $group, & $form) {

  $classes = array($group->visible);
  if (isset($group->format_settings['fieldgroup_settings'])) {
    $collapsible = in_array($group->format_settings['fieldgroup_settings'], array('collapsible', 'open', 'collapsed', 'closed'));
    $collapsed = in_array($group->format_settings['fieldgroup_settings'], array('collapsed', 'closed'));
    if ($collapsible) {
      $classes[] = 'collapsible';
      if ($collapsed) {
        $classes[] = 'collapsed';
      }
    }
  }
  else {
    $collapsible = TRUE;
    $collapsed = FALSE;
    $classes[] = 'collapsible';
  }

  // Javascript has to be able to play along.
  $form['#attached']['js'][] = array(
    'data' => array('field_group' => array($group->visible => TRUE)),
    'type' => 'setting'
  );

  switch ($group->visible) {
    // Fieldset.
    case 'fieldset':
      $element += array(
        '#type' => 'fieldset',
        '#title' => $group->label,
        '#weight' => $group->weight,
        '#collapsible' => $collapsible,
        '#collapsed' => $collapsed,
        '#pre_render' => array(),
        '#attributes' => array('class' => $classes),
      );
      $element['#attached']['js'][] = 'misc/form.js';
      $element['#attached']['js'][] = 'misc/collapse.js';
      break;
    // Normal or collapsible div.
    case 'div':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '<div class="field-group-format '. implode(' ', $classes) . '">
        <span class="field-group-format-toggler">'. $group->label .'</span>
        <div class="field-group-format-wrapper" style="display: '. ($collapsed ? 'none' : 'block') .';">',
        '#suffix' => '</div></div>',
        '#weight' => $group->weight,
      );
      drupal_add_library('system', 'effects.blind');
      break;
    // Horizontal tabs group and accordion group.
    case 'htabs':
    case 'accordion':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '<div class="field-group-'. $group->visible .'-wrapper">',
        '#suffix' => '</div>',
        '#weight' => $group->weight,
      );
      break;
    // Accordion item.
    case 'accordion-item':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '
        <h3 class="field-group-format-toggler '. $group->visible .'">'. $group->label .'</h3>
        <div class="field-group-format-wrapper" style="display: '. ($collapsed ? 'none' : 'block') .';">',
        '#suffix' => '</div>',
        '#weight' => $group->weight,
        //'#attributes' => array('class' => array($group->visible)),
      );
      drupal_add_library('system', 'ui.accordion');
      break;
    // Horizontal tab.
    case 'htab':
      $element += array(
        '#type' => 'markup',
        '#prefix' => '
        <span class="field-group-format-toggler '. $group->visible .'">'. $group->label .'</span>
        <div class="field-group-format-wrapper" style="display: '. ($collapsed ? 'none' : 'block') .';">',
        '#suffix' => '</div>',
        '#weight' => $group->weight,
        '#attributes' => array('class' => $classes),
      );
      drupal_add_library('system', 'effects.blind');
      break;
    // Vertical tabs group.
    case 'tabs':
      $element += array(
        '#type' => 'vertical_tabs',
        '#weight' => $group->weight,
        '#theme_wrappers' => array('vertical_tabs'),
        '#prefix' => '<div class="field-group-'. $group->visible .'-wrapper">',
        '#suffix' => '</div>',
      );
      $form['#attached']['js'][] = 'misc/form.js';
      $form['#attached']['js'][] = 'misc/collapse.js';
      $form['#attached']['js'][] = 'misc/vertical-tabs.js';
      $form['#attached']['css'][] = 'misc/vertical-tabs.css';
      break;
    // Vertical tab.
    case 'tab':
      // For the form, we will keep it in the root.
      if (!isset($form['#view_mode'])) {
        $form['additional_settings'][$group->group_name] = array(
          '#type' => 'fieldset',
          '#title' => $group->label,
          '#weight' => $group->weight,
          '#collapsible' => $collapsible,
          '#collapsed' => $collapsed,
          '#attributes' => array('class' => array($group->visible)),
          '#group' => 'additional_settings',
        );
        foreach (element_children($element) as $fieldname) {
          $form['additional_settings'][$group->group_name][$fieldname] = $element[$fieldname];
          unset($element[$fieldname]);
        }
      }
      else {
        $element += array(
          '#type' => 'fieldset',
          '#title' => $group->label,
          '#weight' => $group->weight,
          '#collapsible' => $collapsible,
          '#collapsed' => $collapsed,
          '#attributes' => array('class' => array($group->visible)),
          '#group' => $group->parent_name,
          // very important. Cannot be added on the form!
          '#parents' => array($group->parent_name),
        );
      }

    break;
  }
}

/**
 * Implements hook_field_group_build_pre_render_alter().
 * @param Array $elements by address.
 */
function field_group_field_group_build_pre_render_alter(& $element) {

  // Dish the fieldgroups with no fields.
  if (isset($element['#view_mode'])) {
    $groups = array_keys($element['#groups']);
    foreach (element_children($element) as $name) {
      if (in_array($name, $groups)) {
        if (field_group_field_group_is_empty($element[$name], $groups)) {
          unset($element[$name]);
        }
      }
    }
  }

  // Place a wrapper around the complete build.
  // TODO check if there is no other way to target only a wrapper where the
  //      fieldgroups are located. Currently javascript use this.
  $element['#attached']['js'][] = drupal_get_path('module', 'field_group') .'/field_group.js';
  $element['#prefix'] = (isset($element['#prefix']) ? $element['#prefix'] : '') . '<div class="field-group-content-wrapper">';
  $element['#suffix'] = '</div>' . (isset($element['#suffix']) ? $element['#suffix'] : '');
}

/**
 * Helper function to recursively tell if the group contains
 * an empty element or maybe one of its children.
 * @param array $element Build array structure
 * @param array $groups Array of group names
 * @return Boolean Is field group empty
 */
function field_group_field_group_is_empty($element, $groups) {
  foreach (element_children($element) as $name) {
    if (in_array($name, $groups)) {
      return field_group_field_group_is_empty($element[$name], $groups);
    }
    else {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Implements hook_field_group_format_settings().
 * If the group has no format settings, default ones will be added.
 * @params Object $group The group object.
 * @return Array $form The form element for the format settings.
 */
function field_group_field_group_format_settings(& $group) {
  $form = array();
  switch ($group->visible) {
    case 'fieldset':
    case 'div':
      if (!isset($group->format_settings['fieldgroup_settings'])) {
        $group->format_settings['fieldgroup_settings'] = 'collapsed';
      }
      $form['fieldgroup_settings'] = array(
        '#title' => t('Fieldgroup settings'),
        '#type' => 'select',
        '#options' => array(
          'open' => t('Open'),
          'collapsible' => t('Collapsible'),
          'collapsed' => t('Collapsed'),
        ),
        '#default_value' => $group->format_settings['fieldgroup_settings'],
        '#weight' => 1,
      );
      break;
    case 'tab':
    case 'accordion-item':
    case 'htab':
      if (!isset($group->format_settings['fieldgroup_settings'])) {
        $group->format_settings['fieldgroup_settings'] = 'closed';
      }
      $form['fieldgroup_settings'] = array(
        '#title' => t('Fieldgroup settings'),
        '#type' => 'select',
        '#options' => array(
          'open' => t('Open'),
          'closed' => t('Closed'),
        ),
        '#default_value' => $group->format_settings['fieldgroup_settings'],
        '#weight' => 1,
      );
      break;
  }
  return $form;
}

/**
 * Implements hook_field_group_format_summary().
 */
function field_group_field_group_format_summary(& $group) {
  $output = '';
  if (isset($group->format_settings['fieldgroup_settings'])) {
    $output = '<strong>'. $group->visible .'</strong> '. $group->format_settings['fieldgroup_settings'] .'';
  }
  return $output;
}

/**
 * Read all groups.
 */
function field_group_read_groups($params = array()) {
  $groups = array();

  $query = db_select('field_group', 'fg');
  $query->fields('fg');

  // Turn the conditions into a query.
  foreach ($params as $key => $value) {
    $query->condition($key, $value);
  }

  $results = $query->execute();
  foreach ($results as $group) {
    // Extract unserialized data.
    $data = unserialize($group->data);
    unset($group->data);
    $group->label = $data['label'];
    $group->weight = $data['weight'];
    $group->children = $data['children'];
    $group->visible = $data['visible'];
    if (isset($data['format_settings'])) {
      $group->format_settings = $data['format_settings'];
    }

    $groups[$group->entity_type][$group->bundle][$group->mode][$group->group_name] = $group;
  }

  return $groups;
}

/**
 * Get all groups.
 *
 * @param $entity_type
 *   The name of the entity.
 * @param $bundle
 *   The name of the bundle.
 * @param $view_mode
 *   The view mode.
 * @param $reset.
 *   Whether to reset the cache or not.
 */
function field_group_info_groups($entity_type = NULL, $bundle = NULL, $view_mode = NULL, $reset = FALSE) {
  static $groups = FALSE;

  if (!$groups || $reset) {
    if ($cached = cache_get('field_groups', 'cache_field')) {
      $groups = $cached->data;
    }
    else {
      $groups = field_group_read_groups();
      cache_set('field_groups', $groups, 'cache_field');
    }
  }

  if (!isset($entity_type)) {
    return $groups;
  }
  else {
    if (isset($groups[$entity_type][$bundle][$view_mode])) {
      return $groups[$entity_type][$bundle][$view_mode];
    }
    else {
      return array();
    }
  }
}

/**
 * Saves a group definition.
 *
 * @param $group
 *   A group definition.
 */
function field_group_save(&$group) {
  // Prepare the record.
  $record = clone $group;
  $record->data = array(
    'label' => $record->label,
    'weight' => $record->weight,
    'children' => $record->children,
    'visible' => $record->visible,
  );
  if (isset($record->format_settings)) {
    $record->data['format_settings'] = $record->format_settings;
  }

  if (isset($record->id)) {
    drupal_write_record('field_group', $record, array('id'));
  }
  else {
    drupal_write_record('field_group', $record);
    $group->id = $record->id;
  }
}

/**
 * Function to retrieve all format possibilities for the fieldgroups.
 */
function field_group_formatter_info($display_overview = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array());
  if (empty($cache)) {
    if ($cached = cache_get('field_group_formatter_info', 'cache_field')) {
      $format_options = $cached->data;
    }
    else {
      $format_options = array();
      $format_options += module_invoke_all('field_group_formatter_info');
      cache_set('field_group_formatter_info', $format_options, 'cache_field');
    }
    $cache = $format_options;
  }
  return $cache;
}

/**
 * Attach groups to the (form) build.
 * @param Array $element The part of the form.
 * @param String $view_mode The mode for the build.
 */
function field_group_attach_groups(&$element, $view_mode) {
  $entity_type = $element['#entity_type'];
  $bundle = $element['#bundle'];

  $element['#groups'] = field_group_info_groups($entity_type,$bundle, $view_mode);

  // Create a lookup array.
  $group_children = array();
  foreach ($element['#groups'] as $group_name => $group) {
    foreach ($group->children as $child) {
      $group_children[$child] = $group_name;
    }
  }
  $element['#group_children'] = $group_children;

  // Add a pre render or process callback.
  // This is needed since process seems too early for the front view modes.
  // TODO Really check what's the difference on forms to use pre_render or process.
  //$element[$view_mode == 'form' ? '#process': '#pre_render'][] = 'field_group_group_pre_render';
  $element['#pre_render'][] = 'field_group_build_pre_render';
  //$element['#process'][] = 'field_group_build_pre_render';
}

/**
 * Process/ Pre-render callback.
 * Depending on whether it is a form build or content build.
 * Form api go through more than a regular build. #process is
 * needed here, where #pre_render is ideal for the regular array.
 * @see called by field_group_attach_groups().
 * @see calls field_group_fields_nest().
 * @param $element Form element
 * @return $element Array with re-arranged fields in forms.
 */
function field_group_build_pre_render($element) {
  // Nest the fields in the corresponding field groups.
  field_group_fields_nest($element, $element);

  // Allow others to alter the pre_rendered build.
  drupal_alter('field_group_build_pre_render', $element);

  return $element;
}

/**
 * Recursive function to nest fields in the field groups.
 * This function will take out all the elements in the form and
 * place them in the correct container element, a fieldgroup.
 * The current group element in the loop is passed recursively so we can
 * stash fields and groups in it while we go deeper in the array.
 * @param Array $element
 *   The current element to analyse for grouping.
 * @param Array $root_element
 *   The root element to control.
 * @param String $parent
 *   the parent name to look for in each level.
 */
function field_group_fields_nest(&$element, &$root_element, $parent_name = NULL) {
  $groups = $root_element['#groups'];
  $group_fields = $root_element['#group_children'];

  foreach ($groups as $name => $group) {

    // Add fieldgroups to the current element. But only if the parent is the current
    // group parent or if we are starting from the root.
    if ((empty($group->parent_name) && !isset($parent_name)) || $parent_name == $group->parent_name) {

      // We first create a new element wrapper, and loop over the fields
      // to detect children. After this point, the fields are stashed
      // in the group element and removed from the root.
      $element[$name] = array();
      foreach ($group_fields as $groupfield => $groupname) {
        // Stash the field in the group.
        if ($groupname == $name && isset($root_element[$groupfield])) {
          $element[$name][$groupfield] = $root_element[$groupfield];
          // We can not meet this field again!
          unset($root_element[$groupfield]);
          unset($root_element['#group_children'][$groupfield]);
        }
        // Or hey, is the field maybe a group, then prepare the array.
        if ($groupname == $name && isset($root_element['#groups'][$groupfield])) {
          $element[$name][$groupfield] = array();
        }
      }
      // Bring extra element wrappers to achieve a grouping of fields.
      // This will mainly be prefix and suffix altering.
      field_group_pre_render($element[$name], $group, $root_element);
      // Go deeper with the current group element and the parent $name.
      field_group_fields_nest($element[$name], $root_element, $name);
    }
  }
}

/**
 * Function to pre render the field group element.
 * @see called by field_group_fields_nest().
 * @param $element Array of group element that needs to be created!
 * @param $group Object with the group information.
 * @param $form The form object itself.
 */
function field_group_pre_render(& $element, $group, & $form) {
  // Only run the pre_render function if the group has elements.
  // $group->group_name
  if ($element == array()) {
    return;
  }
  // Let modules define their wrapping element.
  // Note that the group element has no properties, only elements.
  foreach (module_implements('field_group_pre_render') as $module) {
    $function = $module . '_field_group_pre_render';
    if (function_exists($function)) {
      // The intention here is to have the opportunity to alter the
      // elements, as defined in hook_field_group_formatter_info.
      // Note, implement $element by reference!
      $function($element, $group, $form);
    }
  }
}

/**
 * eof().
 */