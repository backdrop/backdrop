diff --git a/field_group.module b/field_group.module
index 5866b20..601f036 100644
--- a/field_group.module
+++ b/field_group.module
@@ -1718,3 +1718,24 @@ function field_group_pre_render(& $element, $group, & $form) {
     }
   }
 }
+
+
+/**
+ * Implementation of hook_ctools_plugin_directory().
+ * Panels integration
+ */
+function field_group_ctools_plugin_directory($module, $plugin) {
+  if (in_array($module, array('panels', 'ctools', 'page_manager'))) {
+    return 'plugins/' . $plugin;
+  }
+}
diff --git a/plugins/content_types/entity_form_field_group.inc b/plugins/content_types/entity_form_field_group.inc
new file mode 100644
index 0000000..0a65701
--- /dev/null
+++ b/plugins/content_types/entity_form_field_group.inc
@@ -0,0 +1,110 @@
+<?php
+
+/**
+ * @file
+ * Handle rendering fieldgroup form elements
+ */
+$plugin = array(
+  'title' => t('Entity field group'),
+  'defaults' => array('label' => '', 'formatter' => ''),
+  'content type' => 'field_group_entity_form_field_group_content_type_content_type',
+);
+
+/**
+ * Just one subtype.
+ *
+ * Ordinarily this function is meant to get just one subtype. However, we are
+ * using it to deal with the fact that we have changed the subtype names. This
+ * lets us translate the name properly.
+ */
+function field_group_entity_form_field_group_content_type_content_type($subtype) {
+  $types = field_group_entity_form_field_group_content_type_content_types();
+  if (isset($types[$subtype])) {
+    return $types[$subtype];
+  }
+}
+
+/**
+ * return all field group content types availible
+ */
+function field_group_entity_form_field_group_content_type_content_types() {
+  $groups = field_group_read_groups();
+  foreach ($groups as $entity_type => $bundles) {
+    foreach ($bundles as $bundle => $modes) {
+      foreach ($modes as $mode => $fieldgroups) {
+        foreach ($fieldgroups as $group_name => $field_group) {
+          // Only use form field groups
+          if ($field_group->mode == 'form') {
+            $types[$entity_type . ':' . $group_name] = array(
+              'title' => t('Field Group Form: @widget_label', array(
+                '@widget_label' => t($field_group->label),
+              )),
+              'required context' => new ctools_context_required(t('Form'), $entity_type . '_form', array('type' => $bundle)),
+              'category' => t('Form'),
+                    //A icon is missing yet
+                    //'icon' => 'icon_field_group.png',
+            );
+          }
+        }
+      }
+    }
+  }
+  return $types;
+}
+
+/**
+ * Render the custom content type.
+ */
+function field_group_entity_form_field_group_content_type_render($subtype, $conf, $panel_args, $context) {
+  if (empty($context) || empty($context->data)) {
+    return;
+  }
+
+  // Get a shortcut to the entity.
+  $entity = $context->data;
+  list($entity_type, $group_name) = explode(':', $subtype, 2);
+
+  // Load the entity type's information where the fieldgroup is placed
+  $ids = entity_extract_ids($entity_type, $entity);
+  $bundle = $entity->type;
+
+  $list = field_group_read_groups(array('bundle' => $bundle, 'entity_type' => $entity_type, 'mode' => 'form'));
+
+  $group = $list[$entity_type][$bundle]['form'][$group_name];
+
+  // Do not render if the entity type does not have this fieldgroup.
+  if (empty($group)) {
+    return;
+  }
+
+  if (isset($context->form)) {
+
+    if (isset($context->form['#pre_render'])) {
+      foreach ($context->form['#pre_render'] as $function) {
+        if (function_exists($function)) {
+          $context->form = $function($context->form);
+        }
+      }
+      unset($context->form['#pre_render']);
+    }
+
+    $block->content[$group_name] = $context->form[$group_name];
+    unset($context->form[$group_name]);
+  } else {
+    $block->content = t('Entity info.');
+  }
+  return $block;
+}
+
+/**
+ * Returns the administrative title for a type.
+ */
+function field_group_entity_form_field_group_content_type_admin_title($subtype, $conf, $context) {
+  list($entity_type, $group_name) = explode(':', $subtype, 2);
+  return t('"@s" @group_name', array('@s' => $context->identifier, '@group_name' => $group_name));
+}
+
+function field_group_entity_form_field_group_content_type_edit_form($form, &$form_state) {
+  // provide a blank form so we have a place to have context setting.
+  return $form;
+}
\ No newline at end of file
diff --git a/plugins/content_types/field_group.inc b/plugins/content_types/field_group.inc
new file mode 100644
index 0000000..eddffa7
--- /dev/null
+++ b/plugins/content_types/field_group.inc
@@ -0,0 +1,283 @@
+<?php
+
+/**
+ * field_group.inc
+ * Handle rendering fieldgroups as panes.
+ */
+if (!module_exists('field_group')) {
+  return;
+}
+
+$plugin = array(
+  'title' => t('Field Group'),
+  'category' => 'Miscellaneous',
+  'content type' => 'field_group_field_group_content_type',
+  'required context' => new ctools_context_required(t('entity'), 'entity'),
+);
+
+function field_group_field_group_content_type_edit_form($form, &$form_state) {
+  $conf = $form_state['conf'];
+
+  // Force to load this file, that the callbackfunction could be loaded.
+  $form_state['build_info']['files'][] = array(
+    'type' => 'inc',
+    'module' => 'field_group',
+    'name' => 'plugins/content_types/field_group',
+  );
+
+  // Ajax Call when the Entity is changed.
+  $form['context']['#ajax'] = array(
+    'event' => 'change',
+    'path' => 'ctools/content/ajax',
+    'wrapper' => 'field-group-bundles-container',
+    'callback' => 'field_group_bundle_callback'
+  );
+  $form['context']['#submit'] = array('field_group_field_group_content_type_submit_temporary');
+  $form['context']['#executes_submit_callback'] = TRUE;
+
+  if (empty($conf['context'])) {
+    $context = reset($form_state['contexts']);
+  }
+  else {
+    $context = $form_state['contexts'][$conf['context']];
+  }
+
+  $entity_id = $context->argument;
+  $entity_type = $context->type[2];
+  $entity_info = entity_get_info($entity_type);
+
+  if (empty($conf['bundle'])) {
+    $bundle_key = $entity['bundle keys']['bundle'];
+    if (!empty($bundle_key)) {
+      $bundle = $context->data->$bundle_key;
+//      $bundle_check = $context->data->$bundle_key;
+    }
+  }
+  else {
+    $bundle = $conf['bundle'];
+  }
+
+//  dsm($form_state);
+  //What if user? or no bundle?
+  //Check if a bundle is already set by context, otherwise give the opportunity to choose one.
+//  if (empty($bundle_check)) {
+  $groups = field_group_read_groups(array('entity_type' => $entity_type));
+  foreach ($groups as $entitys => $entity) {
+    foreach (array_keys($entity) as $key => $value) {
+      $bundles[$value] = $value;
+    }
+  }
+  $form['bundle'] = array(
+    '#title' => t('Bundle'),
+    '#type' => 'select',
+    '#description' => t('Select a bundle for this @entity_type.', array('@entity_type' => $entity_info['label'])),
+    '#options' => $bundles,
+    '#default_value' => $conf['bundle'],
+    '#ajax' => array(
+      'event' => 'change',
+      'path' => 'ctools/content/ajax',
+      'wrapper' => 'field-group-build-mode-container',
+      'callback' => 'field_group_build_mode_callback'
+    ),
+    '#submit' => array('field_group_field_group_content_type_submit_temporary'),
+    '#executes_submit_callback' => TRUE,
+  );
+
+  if (empty($conf['bundle'])) {
+    $bundle = reset($bundles);
+  }
+//  }
+
+  // Get all build_modes for the current selection of entity_type + bundle.
+  // Even just the build_modes are wanted use ctools api function, because it has internal caching.
+  $field_groups = ctools_export_load_object('field_group', 'conditions', array(
+    'entity_type' => $entity_type,
+    'bundle' => $bundle,
+  ));
+  foreach ($field_groups as $field_group) {
+    $build_mode_options[$field_group->mode] = $field_group->mode;
+  }
+
+  if (empty($conf['build_mode'])) {
+    $conf['build_mode'] = reset($build_mode_options);
+  }
+
+  $form['build_mode'] = array(
+    '#title' => t('Build mode'),
+    '#type' => 'select',
+    '#description' => t('Select a build mode for this @entity_type.', array('@entity_type' => $entity_info['label'])),
+    '#options' => $build_mode_options,
+    '#default_value' => $conf['build_mode'],
+    '#ajax' => array(
+      'event' => 'change',
+      'path' => 'ctools/content/ajax',
+      'wrapper' => 'field-group-field-group-container',
+      'callback' => 'field_group_avalible_field_groups_callback'
+    ),
+    '#submit' => array('field_group_field_group_content_type_submit_temporary'),
+    '#executes_submit_callback' => TRUE,
+  );
+
+
+  // Get all field_groups for the current selectin of mode + bundle + entity_type.
+  $field_groups = array();
+  $groups = field_group_read_groups(array('entity_type' => $entity_type, 'mode' => $conf['build_mode'], 'bundle' => $bundle));
+  foreach ($groups as $entitys => $entity) {
+    foreach ($entity as $bundles => $bundle) {
+      foreach ($bundle as $modes => $mode) {
+        foreach ($mode as $fielgoups => $value) {
+          $field_groups[$value->group_name] = $value->group_name;
+        }
+      }
+    }
+  }
+
+  if (empty($conf['build_mode'])) {
+    $conf['build_mode'] = reset($field_groups);
+  }
+
+  $form['field_group'] = array(
+    '#type' => 'select',
+    '#options' => $field_groups,
+    '#default_value' => $conf['field_group'],
+    '#title' => t('Select Field Group'),
+  );
+
+  
+  $form['#pre_render'][] = 'field_group_group_content_type_pre_render';
+  return $form;
+}
+
+/**
+ * A pre_render function to move the fields into different divs, so ajax can work as expected, but it dowsent -.-"
+ */
+function field_group_group_content_type_pre_render($form) {
+  $field_group = $form['field_group'];
+  $form['field_group'] = array(
+    '#type' => 'container',
+    '#attributes' => array('id' => 'field-group-bundles-container'),
+    // On pre_render the weight of other elements is already done, so 0 would move the element before the context selection.
+    '#weight' => 1,
+  );
+  $form['field_group']['bundle'] = $form['bundle'];
+  unset($form['bundle']);
+  
+  $form['field_group']['build_mode_container'] = array(
+    '#type' => 'container',
+    '#attributes' => array('id' => 'field-group-build-mode-container'),
+    '#weight' => 1,
+  );
+  $form['field_group']['build_mode_container']['build_mode'] = $form['build_mode'];
+  unset($form['build_mode']);
+
+  $form['field_group']['build_mode_container']['field_group_container'] = array(
+    '#type' => 'container',
+    '#attributes' => array('id' => 'field-group-field-group-container'),
+    '#weight' => 1,
+  );
+  $form['field_group']['build_mode_container']['field_group_container']['field_group'] = $field_group;
+
+  return $form;
+}
+
+function field_group_field_group_content_type_submit_temporary($form, &$form_state) {
+  $form_state['conf']['context'] = $form_state['values']['context'];
+  $form_state['conf']['label'] = $form_state['values']['label'];
+  $form_state['conf']['bundle'] = $form_state['values']['bundle'];
+  $form_state['conf']['build_mode'] = $form_state['values']['build_mode'];
+  $form_state['conf']['field_group'] = $form_state['values']['field_group'];
+
+  $form_state['rebuild'] = TRUE;
+  $form_state['rerender'] = TRUE;
+}
+
+/**
+ * Ajax callback to return the bundles container.
+ *
+ * The pre_render function is called manually to be able to return the container, not only the form element.
+ */
+function field_group_bundle_callback($form, &$form_state) {
+  $form = field_group_group_content_type_pre_render($form);
+  return $form['field_group'];
+}
+
+/**
+ * Ajax callback to return the build_modes container.
+ *
+ * The pre_render function is called manually to be able to return the container, not only the form element.
+ */
+function field_group_build_mode_callback($form, &$form_state) {
+  $form = field_group_group_content_type_pre_render($form);
+  return $form['field_group']['build_mode_container'];
+}
+
+/**
+ * Ajax callback to return the field_groups.
+ *
+ * The pre_render function is called manually to be able to return the container, not only the form element.
+ */
+function field_group_avalible_field_groups_callback($form, &$form_state) {
+  $form = field_group_group_content_type_pre_render($form);
+  return $form['field_group']['build_mode_container']['field_group_container'];
+}
+
+/**
+ * Validate the node selection.
+ */
+function field_group_field_group_content_type_edit_form_submit($form, &$form_state) {
+  foreach (array('context', 'build_mode', 'field_group', 'bundle') as $key) {
+    $form_state['conf'][$key] = $form_state['values'][$key];
+  }
+}
+
+/**
+ * Render a field_group as pane.
+ */
+function field_group_field_group_content_type_render($subtype, $conf, $panel_args, $context) {
+
+  // Get a shortcut to the entity.
+  list($entity_type, $bundle, $group_name) = explode(":", $subtype);
+  $view_mode = $conf['build_mode'];
+
+  // Load the entitys
+  $entitys = entity_get_info($entity_type);
+  $entity_key = $entitys['entity keys']['id'];
+  $bundle_key = $entitys['bundle keys']['bundle'];
+
+  $entity = isset($context->data) ? clone($context->data) : NULL;
+  $entity_id = $entity->$entity_key;
+
+  $elements = entity_view($entity_type, array($entity_id => $entity), $view_mode);
+  $entity_types = $entity_type . 's';
+  $element = $elements[$entity_types][$entity_id];
+
+  if (isset($element['#pre_render'])) {
+    foreach ($element['#pre_render'] as $function) {
+      if (function_exists($function)) {
+        $element = $function($element);
+      }
+    }
+    unset($element['#pre_render']);
+  }
+
+  $block = new StdClass();
+  $block->module = 'field_group_panels';
+  $block->delta = 'field_group';
+  $block->content = drupal_render($element[$group_name]);
+
+  return $block;
+}
+
+/**
+ * Returns the administrative title for a type.
+ */
+function field_group_field_group_content_type_admin_title($subtype, $conf, $context) {
+  $entity_type = $context->type[2];
+  if (empty($conf['field_group'])) {
+    $group_name = t('undefined');
+  }
+  else {
+    $group_name = $conf['field_group'];
+  }
+  return t('"@s" @group_name', array('@s' => $entity_type, '@group_name' => $group_name));
+}
